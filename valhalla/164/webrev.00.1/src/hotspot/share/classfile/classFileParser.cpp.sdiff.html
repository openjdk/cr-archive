<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/aarch64/templateTable_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */

  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;jvm.h&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/defaultMethods.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/moduleEntry.hpp&quot;
  36 #include &quot;classfile/packageEntry.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/verificationType.hpp&quot;
  40 #include &quot;classfile/verifier.hpp&quot;
  41 #include &quot;classfile/vmSymbols.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logStream.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/metadataFactory.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/annotations.hpp&quot;
  50 #include &quot;oops/constantPool.inline.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;

  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  54 #include &quot;oops/klass.inline.hpp&quot;
  55 #include &quot;oops/klassVtable.hpp&quot;
  56 #include &quot;oops/metadata.hpp&quot;
  57 #include &quot;oops/method.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/recordComponent.hpp&quot;
  60 #include &quot;oops/symbol.hpp&quot;
  61 #include &quot;prims/jvmtiExport.hpp&quot;
  62 #include &quot;prims/jvmtiThreadState.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/javaCalls.hpp&quot;
  67 #include &quot;runtime/os.hpp&quot;
  68 #include &quot;runtime/perfData.hpp&quot;
  69 #include &quot;runtime/reflection.hpp&quot;
  70 #include &quot;runtime/safepointVerifiers.hpp&quot;
  71 #include &quot;runtime/signature.hpp&quot;
  72 #include &quot;runtime/timer.hpp&quot;
  73 #include &quot;services/classLoadingService.hpp&quot;
  74 #include &quot;services/threadService.hpp&quot;
  75 #include &quot;utilities/align.hpp&quot;
  76 #include &quot;utilities/bitMap.inline.hpp&quot;
  77 #include &quot;utilities/copy.hpp&quot;
  78 #include &quot;utilities/exceptions.hpp&quot;
  79 #include &quot;utilities/globalDefinitions.hpp&quot;
  80 #include &quot;utilities/growableArray.hpp&quot;
  81 #include &quot;utilities/macros.hpp&quot;
  82 #include &quot;utilities/ostream.hpp&quot;
  83 #include &quot;utilities/resourceHash.hpp&quot;

  84 #include &quot;utilities/utf8.hpp&quot;
  85 
  86 #if INCLUDE_CDS
  87 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  88 #endif
  89 #if INCLUDE_JFR
  90 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  91 #endif
  92 
  93 // We generally try to create the oops directly when parsing, rather than
  94 // allocating temporary data structures and copying the bytes twice. A
  95 // temporary area is only needed when parsing utf8 entries in the constant
  96 // pool and when parsing line number tables.
  97 
  98 // We add assert in debug mode when class format is not checked.
  99 
 100 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 101 #define JAVA_MIN_SUPPORTED_VERSION        45
 102 #define JAVA_PREVIEW_MINOR_VERSION        65535
 103 
</pre>
<hr />
<pre>
 117 
 118 // Extension method support.
 119 #define JAVA_8_VERSION                    52
 120 
 121 #define JAVA_9_VERSION                    53
 122 
 123 #define JAVA_10_VERSION                   54
 124 
 125 #define JAVA_11_VERSION                   55
 126 
 127 #define JAVA_12_VERSION                   56
 128 
 129 #define JAVA_13_VERSION                   57
 130 
 131 #define JAVA_14_VERSION                   58
 132 
 133 #define JAVA_15_VERSION                   59
 134 
 135 #define JAVA_16_VERSION                   60
 136 


 137 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 138   assert((bad_constant == JVM_CONSTANT_Module ||
 139           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 140          &quot;Unexpected bad constant pool entry&quot;);
 141   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 142 }
 143 
 144 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 145                                                   ConstantPool* cp,
 146                                                   const int length,
 147                                                   TRAPS) {
 148   assert(stream != NULL, &quot;invariant&quot;);
 149   assert(cp != NULL, &quot;invariant&quot;);
 150 
 151   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 152   // this function (_current can be allocated in a register, with scalar
 153   // replacement of aggregates). The _current pointer is copied back to
 154   // stream() when this function returns. DON&#39;T call another method within
 155   // this method that uses stream().
 156   const ClassFileStream cfs1 = *stream;
 157   const ClassFileStream* const cfs = &amp;cfs1;
 158 
 159   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 160   debug_only(const u1* const old_current = stream-&gt;current();)
 161 
 162   // Used for batching symbol allocations.
 163   const char* names[SymbolTable::symbol_alloc_batch_size];
 164   int lengths[SymbolTable::symbol_alloc_batch_size];
 165   int indices[SymbolTable::symbol_alloc_batch_size];
 166   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 167   int names_count = 0;
 168 
 169   // parsing  Index 0 is unused
 170   for (int index = 1; index &lt; length; index++) {
 171     // Each of the following case guarantees one more byte in the stream
 172     // for the following tag or the access_flags following constant pool,
 173     // so we don&#39;t need bounds-check for reading tag.
 174     const u1 tag = cfs-&gt;get_u1_fast();
 175     switch (tag) {
<span class="line-modified"> 176       case JVM_CONSTANT_Class : {</span>
 177         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 178         const u2 name_index = cfs-&gt;get_u2_fast();
 179         cp-&gt;klass_index_at_put(index, name_index);
 180         break;
 181       }
 182       case JVM_CONSTANT_Fieldref: {
 183         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 184         const u2 class_index = cfs-&gt;get_u2_fast();
 185         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 186         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 187         break;
 188       }
 189       case JVM_CONSTANT_Methodref: {
 190         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 191         const u2 class_index = cfs-&gt;get_u2_fast();
 192         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 193         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 194         break;
 195       }
 196       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
<hr />
<pre>
 486         check_property(valid_symbol_at(name_ref_index),
 487           &quot;Invalid constant pool index %u in class file %s&quot;,
 488           name_ref_index, CHECK);
 489         check_property(valid_symbol_at(signature_ref_index),
 490           &quot;Invalid constant pool index %u in class file %s&quot;,
 491           signature_ref_index, CHECK);
 492         break;
 493       }
 494       case JVM_CONSTANT_Utf8:
 495         break;
 496       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 497       case JVM_CONSTANT_UnresolvedClassInError: {
 498         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 499         break;
 500       }
 501       case JVM_CONSTANT_ClassIndex: {
 502         const int class_index = cp-&gt;klass_index_at(index);
 503         check_property(valid_symbol_at(class_index),
 504           &quot;Invalid constant pool index %u in class file %s&quot;,
 505           class_index, CHECK);
<span class="line-modified"> 506         cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>







 507         break;
 508       }
 509       case JVM_CONSTANT_StringIndex: {
 510         const int string_index = cp-&gt;string_index_at(index);
 511         check_property(valid_symbol_at(string_index),
 512           &quot;Invalid constant pool index %u in class file %s&quot;,
 513           string_index, CHECK);
 514         Symbol* const sym = cp-&gt;symbol_at(string_index);
 515         cp-&gt;unresolved_string_at_put(index, sym);
 516         break;
 517       }
 518       case JVM_CONSTANT_MethodHandle: {
 519         const int ref_index = cp-&gt;method_handle_index_at(index);
 520         check_property(valid_cp_range(ref_index, length),
 521           &quot;Invalid constant pool index %u in class file %s&quot;,
 522           ref_index, CHECK);
 523         const constantTag tag = cp-&gt;tag_at(ref_index);
 524         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 525 
 526         switch (ref_kind) {
</pre>
<hr />
<pre>
 740             classfile_parse_error(
 741               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 742               name_ref_index, CHECK);
 743           }
 744         }
 745         break;
 746       }
 747       case JVM_CONSTANT_MethodHandle: {
 748         const int ref_index = cp-&gt;method_handle_index_at(index);
 749         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 750         switch (ref_kind) {
 751           case JVM_REF_invokeVirtual:
 752           case JVM_REF_invokeStatic:
 753           case JVM_REF_invokeSpecial:
 754           case JVM_REF_newInvokeSpecial: {
 755             const int name_and_type_ref_index =
 756               cp-&gt;name_and_type_ref_index_at(ref_index);
 757             const int name_ref_index =
 758               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 759             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<span class="line-modified"> 760             if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-modified"> 761               if (name != vmSymbols::object_initializer_name()) {</span>
 762                 classfile_parse_error(
 763                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 764                     name_ref_index, CHECK);
 765               }
 766             } else {
<span class="line-modified"> 767               if (name == vmSymbols::object_initializer_name()) {</span>











 768                 classfile_parse_error(
 769                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 770                   name_ref_index, CHECK);
 771               }
 772             }
 773             break;
 774           }
 775           // Other ref_kinds are already fully checked in previous pass.
 776         } // switch(ref_kind)
 777         break;
 778       }
 779       case JVM_CONSTANT_MethodType: {
 780         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 781         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 782         verify_legal_method_signature(no_name, signature, CHECK);
 783         break;
 784       }
 785       case JVM_CONSTANT_Utf8: {
 786         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 787       }
</pre>
<hr />
<pre>
 906   while (entry != NULL) {
 907     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 908       return false;
 909     }
 910     entry = entry-&gt;_next;
 911   }
 912 
 913   // No duplicate is found, allocate a new entry and fill it.
 914   entry = new NameSigHash();
 915   entry-&gt;_name = name;
 916   entry-&gt;_sig = sig;
 917 
 918   // Insert into hash table
 919   entry-&gt;_next = table[index];
 920   table[index] = entry;
 921 
 922   return true;
 923 }
 924 
 925 // Side-effects: populates the _local_interfaces field
<span class="line-modified"> 926 void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,</span>
<span class="line-modified"> 927                                        const int itfs_len,</span>
<span class="line-modified"> 928                                        ConstantPool* const cp,</span>

 929                                        bool* const has_nonstatic_concrete_methods,







 930                                        TRAPS) {
 931   assert(stream != NULL, &quot;invariant&quot;);
 932   assert(cp != NULL, &quot;invariant&quot;);
 933   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 934 
 935   if (itfs_len == 0) {
<span class="line-modified"> 936     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
 937   } else {
 938     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 939     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-modified"> 940 </span>
<span class="line-removed"> 941     int index;</span>
 942     for (index = 0; index &lt; itfs_len; index++) {
 943       const u2 interface_index = stream-&gt;get_u2(CHECK);
 944       Klass* interf;
 945       check_property(
 946         valid_klass_reference_at(interface_index),
 947         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 948         interface_index, CHECK);
 949       if (cp-&gt;tag_at(interface_index).is_klass()) {
 950         interf = cp-&gt;resolved_klass_at(interface_index);
 951       } else {
 952         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 953 
 954         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 955         // But need to make sure it&#39;s not an array type.
 956         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 957                            &quot;Bad interface name in class file %s&quot;, CHECK);
 958 
<span class="line-modified"> 959         // Call resolve_super so classcircularity is checked</span>
 960         interf = SystemDictionary::resolve_super_or_fail(
 961                                                   _class_name,
 962                                                   unresolved_klass,
 963                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 964                                                   _protection_domain,
 965                                                   false,
 966                                                   CHECK);
 967       }
 968 
 969       if (!interf-&gt;is_interface()) {
 970         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 971                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
 972                           _class_name-&gt;as_klass_external_name(),
 973                           interf-&gt;external_name(),
 974                           interf-&gt;class_in_module_of_loader()));
 975       }
 976 
<span class="line-modified"> 977       if (InstanceKlass::cast(interf)-&gt;has_nonstatic_concrete_methods()) {</span>













 978         *has_nonstatic_concrete_methods = true;
 979       }
<span class="line-modified"> 980       _local_interfaces-&gt;at_put(index, InstanceKlass::cast(interf));</span>






 981     }
 982 
 983     if (!_need_verify || itfs_len &lt;= 1) {
 984       return;
 985     }
 986 
 987     // Check if there&#39;s any duplicates in interfaces
 988     ResourceMark rm(THREAD);
 989     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
 990                                                                  NameSigHash*,
 991                                                                  HASH_ROW_SIZE);
 992     initialize_hashtable(interface_names);
 993     bool dup = false;
 994     const Symbol* name = NULL;
 995     {
 996       debug_only(NoSafepointVerifier nsv;)
 997       for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified"> 998         const InstanceKlass* const k = _local_interfaces-&gt;at(index);</span>
 999         name = k-&gt;name();
1000         // If no duplicates, add (name, NULL) in hashtable interface_names.
1001         if (!put_after_lookup(name, NULL, interface_names)) {
1002           dup = true;
1003           break;
1004         }
1005       }
1006     }
1007     if (dup) {
1008       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1009                              name-&gt;as_C_string(), CHECK);
1010     }
1011   }
1012 }
1013 
1014 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1015                                            int constantvalue_index,
1016                                            int signature_index,
1017                                            TRAPS) const {
1018   // Make sure the constant pool entry is of a type appropriate to this field
</pre>
<hr />
<pre>
1454                                             CHECK);
1455   parsed_annotations-&gt;set_field_annotations(a);
1456   a = assemble_annotations(runtime_visible_type_annotations,
1457                            runtime_visible_type_annotations_length,
1458                            runtime_invisible_type_annotations,
1459                            runtime_invisible_type_annotations_length,
1460                            CHECK);
1461   parsed_annotations-&gt;set_field_type_annotations(a);
1462   return;
1463 }
1464 
1465 
1466 // Field allocation types. Used for computing field offsets.
1467 
1468 enum FieldAllocationType {
1469   STATIC_OOP,           // Oops
1470   STATIC_BYTE,          // Boolean, Byte, char
1471   STATIC_SHORT,         // shorts
1472   STATIC_WORD,          // ints
1473   STATIC_DOUBLE,        // aligned long or double

1474   NONSTATIC_OOP,
1475   NONSTATIC_BYTE,
1476   NONSTATIC_SHORT,
1477   NONSTATIC_WORD,
1478   NONSTATIC_DOUBLE,

1479   MAX_FIELD_ALLOCATION_TYPE,
1480   BAD_ALLOCATION_TYPE = -1
1481 };
1482 
1483 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1484   BAD_ALLOCATION_TYPE, // 0
1485   BAD_ALLOCATION_TYPE, // 1
1486   BAD_ALLOCATION_TYPE, // 2
1487   BAD_ALLOCATION_TYPE, // 3
1488   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1489   NONSTATIC_SHORT,     // T_CHAR        =  5,
1490   NONSTATIC_WORD,      // T_FLOAT       =  6,
1491   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1492   NONSTATIC_BYTE,      // T_BYTE        =  8,
1493   NONSTATIC_SHORT,     // T_SHORT       =  9,
1494   NONSTATIC_WORD,      // T_INT         = 10,
1495   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1496   NONSTATIC_OOP,       // T_OBJECT      = 12,
1497   NONSTATIC_OOP,       // T_ARRAY       = 13,
<span class="line-modified">1498   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">1499   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">1500   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">1501   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">1502   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">1503   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>

1504   BAD_ALLOCATION_TYPE, // 0
1505   BAD_ALLOCATION_TYPE, // 1
1506   BAD_ALLOCATION_TYPE, // 2
1507   BAD_ALLOCATION_TYPE, // 3
1508   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1509   STATIC_SHORT,        // T_CHAR        =  5,
1510   STATIC_WORD,         // T_FLOAT       =  6,
1511   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1512   STATIC_BYTE,         // T_BYTE        =  8,
1513   STATIC_SHORT,        // T_SHORT       =  9,
1514   STATIC_WORD,         // T_INT         = 10,
1515   STATIC_DOUBLE,       // T_LONG        = 11,
1516   STATIC_OOP,          // T_OBJECT      = 12,
1517   STATIC_OOP,          // T_ARRAY       = 13,
<span class="line-modified">1518   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">1519   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">1520   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">1521   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">1522   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">1523   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>

1524 };
1525 
<span class="line-modified">1526 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {</span>
1527   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1528   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1529   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);



1530   return result;
1531 }
1532 
1533 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1534  public:
1535   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1536 
1537   FieldAllocationCount() {
1538     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1539       count[i] = 0;
1540     }
1541   }
1542 
<span class="line-modified">1543   FieldAllocationType update(bool is_static, BasicType type) {</span>
<span class="line-modified">1544     FieldAllocationType atype = basic_type_to_atype(is_static, type);</span>
1545     if (atype != BAD_ALLOCATION_TYPE) {
1546       // Make sure there is no overflow with injected fields.
1547       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1548       count[atype]++;
1549     }
1550     return atype;
1551   }
1552 };
1553 
1554 // Side-effects: populates the _fields, _fields_annotations,
1555 // _fields_type_annotations fields
1556 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1557                                    bool is_interface,

1558                                    FieldAllocationCount* const fac,
1559                                    ConstantPool* cp,
1560                                    const int cp_size,
1561                                    u2* const java_fields_count_ptr,
1562                                    TRAPS) {
1563 
1564   assert(cfs != NULL, &quot;invariant&quot;);
1565   assert(fac != NULL, &quot;invariant&quot;);
1566   assert(cp != NULL, &quot;invariant&quot;);
1567   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1568 
1569   assert(NULL == _fields, &quot;invariant&quot;);
1570   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1571   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1572 
1573   cfs-&gt;guarantee_more(2, CHECK);  // length
1574   const u2 length = cfs-&gt;get_u2_fast();
1575   *java_fields_count_ptr = length;
1576 
1577   int num_injected = 0;
1578   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1579                                                                   &amp;num_injected);
<span class="line-modified">1580   const int total_fields = length + num_injected;</span>




1581 
1582   // The field array starts with tuples of shorts
1583   // [access, name index, sig index, initial value index, byte offset].
1584   // A generic signature slot only exists for field with generic
1585   // signature attribute. And the access flag is set with
1586   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1587   // signature slots are at the end of the field array and after all
1588   // other fields data.
1589   //
1590   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1591   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1592   //       ...
1593   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1594   //       [generic signature index]
1595   //       [generic signature index]
1596   //       ...
1597   //
1598   // Allocate a temporary resource array for field data. For each field,
1599   // a slot is reserved in the temporary array for the generic signature
1600   // index. After parsing all fields, the data are copied to a permanent
1601   // array and any unused slots will be discarded.
1602   ResourceMark rm(THREAD);
1603   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1604                                               u2,
1605                                               total_fields * (FieldInfo::field_slots + 1));
1606 
1607   // The generic signature slots start after all other fields&#39; data.
1608   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1609   int num_generic_signature = 0;

1610   for (int n = 0; n &lt; length; n++) {
1611     // access_flags, name_index, descriptor_index, attributes_count
1612     cfs-&gt;guarantee_more(8, CHECK);
1613 




1614     AccessFlags access_flags;
<span class="line-removed">1615     const jint flags = cfs-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-removed">1616     verify_legal_field_modifiers(flags, is_interface, CHECK);</span>
1617     access_flags.set_flags(flags);
1618 
1619     const u2 name_index = cfs-&gt;get_u2_fast();
1620     check_property(valid_symbol_at(name_index),
1621       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1622       name_index, CHECK);
1623     const Symbol* const name = cp-&gt;symbol_at(name_index);
1624     verify_legal_field_name(name, CHECK);
1625 
1626     const u2 signature_index = cfs-&gt;get_u2_fast();
1627     check_property(valid_symbol_at(signature_index),
1628       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1629       signature_index, CHECK);
1630     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1631     verify_legal_field_signature(name, sig, CHECK);

1632 
1633     u2 constantvalue_index = 0;
1634     bool is_synthetic = false;
1635     u2 generic_signature_index = 0;
1636     const bool is_static = access_flags.is_static();
1637     FieldAnnotationCollector parsed_annotations(_loader_data);
1638 
1639     const u2 attributes_count = cfs-&gt;get_u2_fast();
1640     if (attributes_count &gt; 0) {
1641       parse_field_attributes(cfs,
1642                              attributes_count,
1643                              is_static,
1644                              signature_index,
1645                              &amp;constantvalue_index,
1646                              &amp;is_synthetic,
1647                              &amp;generic_signature_index,
1648                              &amp;parsed_annotations,
1649                              CHECK);
1650 
1651       if (parsed_annotations.field_annotations() != NULL) {
</pre>
<hr />
<pre>
1671 
1672       if (is_synthetic) {
1673         access_flags.set_is_synthetic();
1674       }
1675       if (generic_signature_index != 0) {
1676         access_flags.set_field_has_generic_signature();
1677         fa[generic_signature_slot] = generic_signature_index;
1678         generic_signature_slot ++;
1679         num_generic_signature ++;
1680       }
1681     }
1682 
1683     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1684     field-&gt;initialize(access_flags.as_short(),
1685                       name_index,
1686                       signature_index,
1687                       constantvalue_index);
1688     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1689 
1690     // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1691     const FieldAllocationType atype = fac-&gt;update(is_static, type);</span>
1692     field-&gt;set_allocation_type(atype);
1693 
1694     // After field is initialized with type, we can augment it with aux info
1695     if (parsed_annotations.has_any_annotations()) {
1696       parsed_annotations.apply_to(field);
1697       if (field-&gt;is_contended()) {
1698         _has_contended_fields = true;
1699       }
1700     }
1701   }
1702 
1703   int index = length;
1704   if (num_injected != 0) {
1705     for (int n = 0; n &lt; num_injected; n++) {
1706       // Check for duplicates
1707       if (injected[n].may_be_java) {
1708         const Symbol* const name      = injected[n].name();
1709         const Symbol* const signature = injected[n].signature();
1710         bool duplicate = false;
1711         for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
1716             duplicate = true;
1717             break;
1718           }
1719         }
1720         if (duplicate) {
1721           // These will be removed from the field array at the end
1722           continue;
1723         }
1724       }
1725 
1726       // Injected field
1727       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1728       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1729                         injected[n].name_index,
1730                         injected[n].signature_index,
1731                         0);
1732 
1733       const BasicType type = Signature::basic_type(injected[n].signature());
1734 
1735       // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1736       const FieldAllocationType atype = fac-&gt;update(false, type);</span>
1737       field-&gt;set_allocation_type(atype);
1738       index++;
1739     }
1740   }
1741 





























1742   assert(NULL == _fields, &quot;invariant&quot;);
1743 
1744   _fields =
1745     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1746                                    index * FieldInfo::field_slots + num_generic_signature,
1747                                    CHECK);
1748   // Sometimes injected fields already exist in the Java source so
1749   // the fields array could be too long.  In that case the
1750   // fields array is trimed. Also unused slots that were reserved
1751   // for generic signature indexes are discarded.
1752   {
1753     int i = 0;
1754     for (; i &lt; index * FieldInfo::field_slots; i++) {
1755       _fields-&gt;at_put(i, fa[i]);
1756     }
1757     for (int j = total_fields * FieldInfo::field_slots;
1758          j &lt; generic_signature_slot; j++) {
1759       _fields-&gt;at_put(i++, fa[j]);
1760     }
1761     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
2037         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2038         checked_exception, CHECK_NULL);
2039     }
2040   }
2041   // check exceptions attribute length
2042   if (_need_verify) {
2043     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2044                                                    sizeof(u2) * size),
2045                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2046   }
2047   return checked_exceptions_start;
2048 }
2049 
2050 void ClassFileParser::throwIllegalSignature(const char* type,
2051                                             const Symbol* name,
2052                                             const Symbol* sig,
2053                                             TRAPS) const {
2054   assert(name != NULL, &quot;invariant&quot;);
2055   assert(sig != NULL, &quot;invariant&quot;);
2056 





2057   ResourceMark rm(THREAD);
2058   Exceptions::fthrow(THREAD_AND_LOCATION,
2059       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">2060       &quot;%s \&quot;%s\&quot; in class %s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">2061       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), sig-&gt;as_C_string());</span>
2062 }
2063 
2064 AnnotationCollector::ID
2065 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2066                                       const Symbol* name,
2067                                       const bool can_access_vm_annotations) {
2068   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2069   // Privileged code can use all annotations.  Other code silently drops some.
2070   const bool privileged = loader_data-&gt;is_boot_class_loader_data() ||
2071                           loader_data-&gt;is_platform_class_loader_data() ||
2072                           can_access_vm_annotations;
2073   switch (sid) {
2074     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2075       if (_location != _in_method)  break;  // only allow for methods
2076       if (!privileged)              break;  // only allow in privileged code
2077       return _method_CallerSensitive;
2078     }
2079     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2080       if (_location != _in_method)  break;  // only allow for methods
2081       if (!privileged)              break;  // only allow in privileged code
</pre>
<hr />
<pre>
2306                              runtime_visible_type_annotations_length,
2307                              runtime_invisible_type_annotations,
2308                              runtime_invisible_type_annotations_length,
2309                              CHECK);
2310     cm-&gt;set_type_annotations(a);
2311   }
2312 }
2313 
2314 
2315 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2316 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2317 // Method* to save footprint, so we only know the size of the resulting Method* when the
2318 // entire method attribute is parsed.
2319 //
2320 // The promoted_flags parameter is used to pass relevant access_flags
2321 // from the method back up to the containing klass. These flag values
2322 // are added to klass&#39;s access_flags.
2323 
2324 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2325                                       bool is_interface,

2326                                       const ConstantPool* cp,
2327                                       AccessFlags* const promoted_flags,
2328                                       TRAPS) {
2329   assert(cfs != NULL, &quot;invariant&quot;);
2330   assert(cp != NULL, &quot;invariant&quot;);
2331   assert(promoted_flags != NULL, &quot;invariant&quot;);
2332 
2333   ResourceMark rm(THREAD);
2334   // Parse fixed parts:
2335   // access_flags, name_index, descriptor_index, attributes_count
2336   cfs-&gt;guarantee_more(8, CHECK_NULL);
2337 
2338   int flags = cfs-&gt;get_u2_fast();
2339   const u2 name_index = cfs-&gt;get_u2_fast();
2340   const int cp_size = cp-&gt;length();
2341   check_property(
2342     valid_symbol_at(name_index),
2343     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2344     name_index, CHECK_NULL);
2345   const Symbol* const name = cp-&gt;symbol_at(name_index);
2346   verify_legal_method_name(name, CHECK_NULL);
2347 
2348   const u2 signature_index = cfs-&gt;get_u2_fast();
2349   guarantee_property(
2350     valid_symbol_at(signature_index),
2351     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2352     signature_index, CHECK_NULL);
2353   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2354 
2355   if (name == vmSymbols::class_initializer_name()) {
2356     // We ignore the other access flags for a valid class initializer.
2357     // (JVM Spec 2nd ed., chapter 4.6)
2358     if (_major_version &lt; 51) { // backward compatibility
2359       flags = JVM_ACC_STATIC;
2360     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2361       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2362     } else {
2363       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2364     }
2365   } else {
<span class="line-modified">2366     verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);</span>
<span class="line-modified">2367   }</span>
<span class="line-modified">2368 </span>
<span class="line-modified">2369   if (name == vmSymbols::object_initializer_name() &amp;&amp; is_interface) {</span>
<span class="line-modified">2370     classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>













































2371   }
2372 
2373   int args_size = -1;  // only used when _need_verify is true
2374   if (_need_verify) {
2375     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2376                  verify_legal_method_signature(name, signature, CHECK_NULL);
2377     if (args_size &gt; MAX_ARGS_SIZE) {
2378       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2379     }
2380   }
2381 
2382   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2383 
2384   // Default values for code and exceptions attribute elements
2385   u2 max_stack = 0;
2386   u2 max_locals = 0;
2387   u4 code_length = 0;
2388   const u1* code_start = 0;
2389   u2 exception_table_length = 0;
2390   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
</pre>
<hr />
<pre>
2901       _has_finalizer = true;
2902     }
2903   }
2904   if (name == vmSymbols::object_initializer_name() &amp;&amp;
2905       signature == vmSymbols::void_method_signature() &amp;&amp;
2906       m-&gt;is_vanilla_constructor()) {
2907     _has_vanilla_constructor = true;
2908   }
2909 
2910   NOT_PRODUCT(m-&gt;verify());
2911   return m;
2912 }
2913 
2914 
2915 // The promoted_flags parameter is used to pass relevant access_flags
2916 // from the methods back up to the containing klass. These flag values
2917 // are added to klass&#39;s access_flags.
2918 // Side-effects: populates the _methods field in the parser
2919 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
2920                                     bool is_interface,

2921                                     AccessFlags* promoted_flags,
2922                                     bool* has_final_method,
2923                                     bool* declares_nonstatic_concrete_methods,
2924                                     TRAPS) {
2925   assert(cfs != NULL, &quot;invariant&quot;);
2926   assert(promoted_flags != NULL, &quot;invariant&quot;);
2927   assert(has_final_method != NULL, &quot;invariant&quot;);
2928   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
2929 
2930   assert(NULL == _methods, &quot;invariant&quot;);
2931 
2932   cfs-&gt;guarantee_more(2, CHECK);  // length
2933   const u2 length = cfs-&gt;get_u2_fast();
2934   if (length == 0) {
2935     _methods = Universe::the_empty_method_array();
2936   } else {
2937     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
2938                                                    length,
2939                                                    NULL,
2940                                                    CHECK);
2941 
2942     for (int index = 0; index &lt; length; index++) {
2943       Method* method = parse_method(cfs,
2944                                     is_interface,

2945                                     _cp,
2946                                     promoted_flags,
2947                                     CHECK);
2948 
2949       if (method-&gt;is_final()) {
2950         *has_final_method = true;
2951       }
2952       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
2953       // used for interface initialization, and default method inheritance analysis
2954       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
2955         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
2956         *declares_nonstatic_concrete_methods = true;
2957       }
2958       _methods-&gt;at_put(index, method);
2959     }
2960 
2961     if (_need_verify &amp;&amp; length &gt; 1) {
2962       // Check duplicated methods
2963       ResourceMark rm(THREAD);
2964       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
</pre>
<hr />
<pre>
3117       valid_klass_reference_at(inner_class_info_index),
3118       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3119       inner_class_info_index, CHECK_0);
3120     // Outer class index
3121     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3122     check_property(
3123       outer_class_info_index == 0 ||
3124         valid_klass_reference_at(outer_class_info_index),
3125       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3126       outer_class_info_index, CHECK_0);
3127     // Inner class name
3128     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3129     check_property(
3130       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3131       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3132       inner_name_index, CHECK_0);
3133     if (_need_verify) {
3134       guarantee_property(inner_class_info_index != outer_class_info_index,
3135                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3136     }
<span class="line-modified">3137     // Access flags</span>
<span class="line-modified">3138     jint flags;</span>
3139     // JVM_ACC_MODULE is defined in JDK-9 and later.
3140     if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">3141       flags = cfs-&gt;get_u2_fast() &amp; (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-modified">3142     } else {</span>
<span class="line-modified">3143       flags = cfs-&gt;get_u2_fast() &amp; RECOGNIZED_INNER_CLASS_MODIFIERS;</span>


3144     }




3145     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3146       // Set abstract bit for old class files for backward compatibility
3147       flags |= JVM_ACC_ABSTRACT;
3148     }
3149     verify_legal_class_modifiers(flags, CHECK_0);
3150     AccessFlags inner_access_flags(flags);
3151 
3152     inner_classes-&gt;at_put(index++, inner_class_info_index);
3153     inner_classes-&gt;at_put(index++, outer_class_info_index);
3154     inner_classes-&gt;at_put(index++, inner_name_index);
3155     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3156   }
3157 
3158   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3159   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3160     for(int i = 0; i &lt; length * 4; i += 4) {
3161       for(int j = i + 4; j &lt; length * 4; j += 4) {
3162         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3163                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3164                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
</pre>
<hr />
<pre>
3497     operands-&gt;at_put(operand_fill_index++, argument_count);
3498 
3499     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3500     for (int j = 0; j &lt; argument_count; j++) {
3501       const u2 argument_index = cfs-&gt;get_u2_fast();
3502       check_property(
3503         valid_cp_range(argument_index, cp_size) &amp;&amp;
3504         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3505         &quot;argument_index %u has bad constant type in class file %s&quot;,
3506         argument_index,
3507         CHECK);
3508       operands-&gt;at_put(operand_fill_index++, argument_index);
3509     }
3510   }
3511   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3512                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3513                      CHECK);
3514 }
3515 
3516 bool ClassFileParser::supports_sealed_types() {
<span class="line-modified">3517   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;</span>
<span class="line-modified">3518          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;</span>
<span class="line-removed">3519          Arguments::enable_preview();</span>
3520 }
3521 
3522 bool ClassFileParser::supports_records() {
3523   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
3524          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
3525          Arguments::enable_preview();
3526 }
3527 
3528 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3529                                                  ConstantPool* cp,
3530                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3531                                                  TRAPS) {
3532   assert(cfs != NULL, &quot;invariant&quot;);
3533   assert(cp != NULL, &quot;invariant&quot;);
3534   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3535 
3536   // Set inner classes attribute to default sentinel
3537   _inner_classes = Universe::the_empty_short_array();
3538   // Set nest members attribute to default sentinel
3539   _nest_members = Universe::the_empty_short_array();
</pre>
<hr />
<pre>
3984       }
3985     }
3986     if (runtime_invisible_annotations != NULL) {
3987       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
3988         int append = runtime_visible_annotations_length+i;
3989         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
3990       }
3991     }
3992   }
3993   return annotations;
3994 }
3995 
3996 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
3997                                                         const int super_class_index,
3998                                                         const bool need_verify,
3999                                                         TRAPS) {
4000   assert(cp != NULL, &quot;invariant&quot;);
4001   const InstanceKlass* super_klass = NULL;
4002 
4003   if (super_class_index == 0) {
<span class="line-modified">4004     check_property(_class_name == vmSymbols::java_lang_Object(),</span>

4005                    &quot;Invalid superclass index %u in class file %s&quot;,
4006                    super_class_index,
4007                    CHECK_NULL);
4008   } else {
4009     check_property(valid_klass_reference_at(super_class_index),
4010                    &quot;Invalid superclass index %u in class file %s&quot;,
4011                    super_class_index,
4012                    CHECK_NULL);
4013     // The class name should be legal because it is checked when parsing constant pool.
4014     // However, make sure it is not an array type.
4015     bool is_array = false;
4016     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4017       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4018       if (need_verify)
4019         is_array = super_klass-&gt;is_array_klass();
4020     } else if (need_verify) {
4021       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4022     }
4023     if (need_verify) {
4024       guarantee_property(!is_array,
</pre>
<hr />
<pre>
4127 }
4128 
4129 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4130   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4131   if (_nonstatic_oop_map_count &gt; 0) {
4132     OopMapBlock* map = _nonstatic_oop_maps;
4133     OopMapBlock* last_map = last_oop_map();
4134     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4135     while (map &lt;= last_map) {
4136       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4137                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4138       map++;
4139     }
4140   }
4141 }
4142 
4143 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4144   print_on(st);
4145 }
4146 



















4147 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4148   assert(ik != NULL, &quot;invariant&quot;);
4149 
4150   const Klass* const super = ik-&gt;super();
4151 
4152   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4153   // in which case we don&#39;t have to register objects as finalizable
4154   if (!_has_empty_finalizer) {
4155     if (_has_finalizer ||
4156         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4157       ik-&gt;set_has_finalizer();
4158     }
4159   }
4160 
4161 #ifdef ASSERT
4162   bool f = false;
4163   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4164                                            vmSymbols::void_method_signature());
4165   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4166       f = true;
4167   }
4168 
4169   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4170   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4171   // will not work as expected we shouldn&#39;t abort vm in this case
4172   if (!ik-&gt;has_redefined_this_or_super()) {
4173     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4174   }
4175 #endif
4176 
4177   // Check if this klass supports the java.lang.Cloneable interface
4178   if (SystemDictionary::Cloneable_klass_loaded()) {
4179     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {





4180       ik-&gt;set_is_cloneable();
4181     }
4182   }
4183 
4184   // Check if this klass has a vanilla default constructor
4185   if (super == NULL) {
4186     // java.lang.Object has empty default constructor
4187     ik-&gt;set_has_vanilla_constructor();
4188   } else {
4189     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4190         _has_vanilla_constructor) {
4191       ik-&gt;set_has_vanilla_constructor();
4192     }
4193 #ifdef ASSERT
4194     bool v = false;
4195     if (super-&gt;has_vanilla_constructor()) {
4196       const Method* const constructor =
4197         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4198                        vmSymbols::void_method_signature());
4199       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4200         v = true;
4201       }
4202     }
4203     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4204 #endif
4205   }
4206 
4207   // If it cannot be fast-path allocated, set a bit in the layout helper.
4208   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4209   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4210   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4211       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4212       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4213       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4214     // Forbid fast-path allocation.
4215     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4216     ik-&gt;set_layout_helper(lh);
4217   }
4218 }
4219 





4220 // utility methods for appending an array with check for duplicates
4221 
4222 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4223                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4224   // iterate over new interfaces
4225   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4226     InstanceKlass* const e = ifs-&gt;at(i);
4227     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4228     // add new interface
4229     result-&gt;append_if_missing(e);
4230   }
4231 }
4232 
4233 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
4234                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
4235                                                             ClassLoaderData* loader_data,
4236                                                             TRAPS) {
4237   assert(local_ifs != NULL, &quot;invariant&quot;);
4238   assert(loader_data != NULL, &quot;invariant&quot;);
4239 
</pre>
<hr />
<pre>
4243   // Add superclass transitive interfaces size
4244   if (super != NULL) {
4245     super_size = super-&gt;transitive_interfaces()-&gt;length();
4246     max_transitive_size += super_size;
4247   }
4248   // Add local interfaces&#39; super interfaces
4249   const int local_size = local_ifs-&gt;length();
4250   for (int i = 0; i &lt; local_size; i++) {
4251     InstanceKlass* const l = local_ifs-&gt;at(i);
4252     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
4253   }
4254   // Finally add local interfaces
4255   max_transitive_size += local_size;
4256   // Construct array
4257   if (max_transitive_size == 0) {
4258     // no interfaces, use canonicalized array
4259     return Universe::the_empty_instance_klass_array();
4260   } else if (max_transitive_size == super_size) {
4261     // no new local interfaces added, share superklass&#39; transitive interface array
4262     return super-&gt;transitive_interfaces();
<span class="line-modified">4263   } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">4264     // only local interfaces added, share local interface array</span>
<span class="line-modified">4265     return local_ifs;</span>

4266   } else {
4267     ResourceMark rm;
4268     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
4269 
4270     // Copy down from superclass
4271     if (super != NULL) {
4272       append_interfaces(result, super-&gt;transitive_interfaces());
4273     }
4274 
4275     // Copy down from local interfaces&#39; superinterfaces
4276     for (int i = 0; i &lt; local_size; i++) {
4277       InstanceKlass* const l = local_ifs-&gt;at(i);
4278       append_interfaces(result, l-&gt;transitive_interfaces());
4279     }
4280     // Finally add local interfaces
4281     append_interfaces(result, local_ifs);
4282 
4283     // length will be less than the max_transitive_size if duplicates were removed
4284     const int length = result-&gt;length();
4285     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);





4286     Array&lt;InstanceKlass*&gt;* const new_result =
4287       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4288     for (int i = 0; i &lt; length; i++) {
4289       InstanceKlass* const e = result-&gt;at(i);
4290       assert(e != NULL, &quot;just checking&quot;);
4291       new_result-&gt;at_put(i, e);
4292     }
4293     return new_result;
4294   }
4295 }
4296 
4297 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4298   assert(this_klass != NULL, &quot;invariant&quot;);
4299   const Klass* const super = this_klass-&gt;super();
4300 
4301   if (super != NULL) {
4302     const InstanceKlass* super_ik = InstanceKlass::cast(super);
4303 
4304     if (super-&gt;is_final()) {
4305       ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
4498     const Method* const m = methods-&gt;at(index);
4499     // if m is static and not the init method, throw a verify error
4500     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
4501       ResourceMark rm(THREAD);
4502       Exceptions::fthrow(
4503         THREAD_AND_LOCATION,
4504         vmSymbols::java_lang_VerifyError(),
4505         &quot;Illegal static method %s in interface %s&quot;,
4506         m-&gt;name()-&gt;as_C_string(),
4507         this_klass-&gt;external_name()
4508       );
4509       return;
4510     }
4511   }
4512 }
4513 
4514 // utility methods for format checking
4515 
4516 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
4517   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;

4518   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);

4519   if (is_module) {
4520     ResourceMark rm(THREAD);
4521     Exceptions::fthrow(
4522       THREAD_AND_LOCATION,
4523       vmSymbols::java_lang_NoClassDefFoundError(),
4524       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
4525       _class_name-&gt;as_C_string());
4526     return;
4527   }
4528 










4529   if (!_need_verify) { return; }
4530 
4531   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
4532   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
4533   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
4534   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
4535   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
4536   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
4537   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4538   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
4539 
4540   if ((is_abstract &amp;&amp; is_final) ||
4541       (is_interface &amp;&amp; !is_abstract) ||
4542       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<span class="line-modified">4543       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation)) {</span>

4544     ResourceMark rm(THREAD);


4545     Exceptions::fthrow(
4546       THREAD_AND_LOCATION,
4547       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">4548       &quot;Illegal class modifiers in class %s: 0x%X&quot;,</span>
<span class="line-modified">4549       _class_name-&gt;as_C_string(), flags</span>
4550     );
4551     return;
4552   }
4553 }
4554 
4555 static bool has_illegal_visibility(jint flags) {
4556   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4557   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4558   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4559 
4560   return ((is_public &amp;&amp; is_protected) ||
4561           (is_public &amp;&amp; is_private) ||
4562           (is_protected &amp;&amp; is_private));
4563 }
4564 
4565 // A legal major_version.minor_version must be one of the following:
4566 //
4567 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
4568 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
4569 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
</pre>
<hr />
<pre>
4608     if (!Arguments::enable_preview()) {
4609       Exceptions::fthrow(
4610         THREAD_AND_LOCATION,
4611         vmSymbols::java_lang_UnsupportedClassVersionError(),
4612         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
4613         class_name-&gt;as_C_string(), major, minor);
4614       return;
4615     }
4616 
4617   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
4618     Exceptions::fthrow(
4619         THREAD_AND_LOCATION,
4620         vmSymbols::java_lang_UnsupportedClassVersionError(),
4621         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
4622         class_name-&gt;as_C_string(), major, minor);
4623   }
4624 }
4625 
4626 void ClassFileParser::verify_legal_field_modifiers(jint flags,
4627                                                    bool is_interface,

4628                                                    TRAPS) const {
4629   if (!_need_verify) { return; }
4630 
4631   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4632   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4633   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4634   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
4635   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
4636   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
4637   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
4638   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
4639   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4640 
4641   bool is_illegal = false;
4642 
4643   if (is_interface) {
4644     if (!is_public || !is_static || !is_final || is_private ||
4645         is_protected || is_volatile || is_transient ||
4646         (major_gte_1_5 &amp;&amp; is_enum)) {
4647       is_illegal = true;
4648     }
4649   } else { // not interface
4650     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
4651       is_illegal = true;




4652     }
4653   }
4654 
4655   if (is_illegal) {
4656     ResourceMark rm(THREAD);
4657     Exceptions::fthrow(
4658       THREAD_AND_LOCATION,
4659       vmSymbols::java_lang_ClassFormatError(),
4660       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
4661       _class_name-&gt;as_C_string(), flags);
4662     return;
4663   }
4664 }
4665 
4666 void ClassFileParser::verify_legal_method_modifiers(jint flags,
4667                                                     bool is_interface,

4668                                                     const Symbol* name,
4669                                                     TRAPS) const {
4670   if (!_need_verify) { return; }
4671 
4672   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
4673   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
4674   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
4675   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
4676   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
4677   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
4678   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
4679   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
4680   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
4681   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
4682   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
4683   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
4684   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
4685 
4686   bool is_illegal = false;
4687 


4688   if (is_interface) {
4689     if (major_gte_8) {
4690       // Class file version is JAVA_8_VERSION or later Methods of
4691       // interfaces may set any of the flags except ACC_PROTECTED,
4692       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
4693       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
4694       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
4695           (is_native || is_protected || is_final || is_synchronized) ||
4696           // If a specific method of a class or interface has its
4697           // ACC_ABSTRACT flag set, it must not have any of its
4698           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
4699           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
4700           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
4701           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
4702           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
4703         is_illegal = true;
4704       }
4705     } else if (major_gte_1_5) {
4706       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
4707       if (!is_public || is_private || is_protected || is_static || is_final ||
4708           is_synchronized || is_native || !is_abstract || is_strict) {
4709         is_illegal = true;
4710       }
4711     } else {
4712       // Class file version is pre-JAVA_1_5_VERSION
4713       if (!is_public || is_static || is_final || is_native || !is_abstract) {
4714         is_illegal = true;
4715       }
4716     }
4717   } else { // not interface
4718     if (has_illegal_visibility(flags)) {
4719       is_illegal = true;
4720     } else {
4721       if (is_initializer) {
<span class="line-modified">4722         if (is_static || is_final || is_synchronized || is_native ||</span>
4723             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
4724           is_illegal = true;
4725         }









4726       } else { // not initializer
<span class="line-modified">4727         if (is_abstract) {</span>
<span class="line-modified">4728           if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-modified">4729               (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-modified">4730             is_illegal = true;</span>





4731           }
4732         }
4733       }
4734     }
4735   }
4736 
4737   if (is_illegal) {
4738     ResourceMark rm(THREAD);
4739     Exceptions::fthrow(
4740       THREAD_AND_LOCATION,
4741       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">4742       &quot;Method %s in class %s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">4743       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), flags);</span>
4744     return;
4745   }
4746 }
4747 
4748 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
4749                                         int length,
4750                                         TRAPS) const {
4751   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
4752   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
4753     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
4754   }
4755 }
4756 
4757 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
4758 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
4759 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
4760 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
4761 // method.  Because these names have been checked as special cases before
4762 // calling this method in verify_legal_method_name.
4763 //
</pre>
<hr />
<pre>
4881 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
4882 // Return a pointer to just past the signature.
4883 // Return NULL if no legal signature is found.
4884 const char* ClassFileParser::skip_over_field_signature(const char* signature,
4885                                                        bool void_ok,
4886                                                        unsigned int length,
4887                                                        TRAPS) const {
4888   unsigned int array_dim = 0;
4889   while (length &gt; 0) {
4890     switch (signature[0]) {
4891     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
4892     case JVM_SIGNATURE_BOOLEAN:
4893     case JVM_SIGNATURE_BYTE:
4894     case JVM_SIGNATURE_CHAR:
4895     case JVM_SIGNATURE_SHORT:
4896     case JVM_SIGNATURE_INT:
4897     case JVM_SIGNATURE_FLOAT:
4898     case JVM_SIGNATURE_LONG:
4899     case JVM_SIGNATURE_DOUBLE:
4900       return signature + 1;
<span class="line-modified">4901     case JVM_SIGNATURE_CLASS: {</span>









4902       if (_major_version &lt; JAVA_1_5_VERSION) {
4903         // Skip over the class name if one is there
4904         const char* const p = skip_over_field_name(signature + 1, true, --length);
4905 
4906         // The next character better be a semicolon
4907         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
4908           return p + 1;
4909         }
4910       }
4911       else {
<span class="line-modified">4912         // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;</span>
4913         signature++;
4914         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
4915         // Format check signature
4916         if (c != NULL) {
4917           int newlen = c - (char*) signature;
4918           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
4919           if (!legal) {
4920             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
4921                                   &quot;in descriptor in class file %s&quot;,
4922                                   CHECK_NULL);
4923             return NULL;
4924           }
4925           return signature + newlen + 1;
4926         }
4927       }
4928       return NULL;
4929     }
4930     case JVM_SIGNATURE_ARRAY:
4931       array_dim++;
4932       if (array_dim &gt; 255) {
</pre>
<hr />
<pre>
4947 
4948 // Checks if name is a legal class name.
4949 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
4950   if (!_need_verify || _relax_verify) { return; }
4951 
4952   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
4953   char* bytes = (char*)name-&gt;bytes();
4954   unsigned int length = name-&gt;utf8_length();
4955   bool legal = false;
4956 
4957   if (length &gt; 0) {
4958     const char* p;
4959     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
4960       p = skip_over_field_signature(bytes, false, length, CHECK);
4961       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
4962     } else if (_major_version &lt; JAVA_1_5_VERSION) {
4963       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
4964         p = skip_over_field_name(bytes, true, length);
4965         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
4966       }



4967     } else {
4968       // 4900761: relax the constraints based on JSR202 spec
4969       // Class names may be drawn from the entire Unicode character set.
4970       // Identifiers between &#39;/&#39; must be unqualified names.
4971       // The utf8 string has been verified when parsing cpool entries.
4972       legal = verify_unqualified_name(bytes, length, LegalClass);
4973     }
4974   }
4975   if (!legal) {
4976     ResourceMark rm(THREAD);
4977     assert(_class_name != NULL, &quot;invariant&quot;);
4978     Exceptions::fthrow(
4979       THREAD_AND_LOCATION,
4980       vmSymbols::java_lang_ClassFormatError(),
4981       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
4982       _class_name-&gt;as_C_string()
4983     );
4984     return;
4985   }
4986 }
</pre>
<hr />
<pre>
5096   const char* nextp;
5097 
5098   // The first character must be a &#39;(&#39;
5099   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5100     length--;
5101     // Skip over legal field signatures
5102     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5103     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5104       args_size++;
5105       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5106         args_size++;
5107       }
5108       length -= nextp - p;
5109       p = nextp;
5110       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5111     }
5112     // The first non-signature thing better be a &#39;)&#39;
5113     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5114       length--;
5115       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">5116         // All internal methods must return void</span>
5117         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5118           return args_size;
5119         }
















5120       } else {
5121         // Now we better just have a return value
5122         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5123         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5124           return args_size;
5125         }
5126       }
5127     }
5128   }
5129   // Report error
5130   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5131   return 0;
5132 }
5133 
5134 int ClassFileParser::static_field_size() const {
5135   assert(_field_info != NULL, &quot;invariant&quot;);
5136   return _field_info-&gt;_static_field_size;
5137 }
5138 
5139 int ClassFileParser::total_oop_map_count() const {
</pre>
<hr />
<pre>
5257 
5258 
5259   if (ik-&gt;should_store_fingerprint()) {
5260     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
5261   }
5262 
5263   ik-&gt;set_has_passed_fingerprint_check(false);
5264   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
5265     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
5266     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
5267     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
5268       // This class matches with a class saved in an AOT library
5269       ik-&gt;set_has_passed_fingerprint_check(true);
5270     } else {
5271       ResourceMark rm;
5272       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
5273                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
5274     }
5275   }
5276 






5277   return ik;
5278 }
5279 


































5280 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
5281                                           bool changed_by_loadhook,
5282                                           const ClassInstanceInfo&amp; cl_inst_info,
5283                                           TRAPS) {
5284   assert(ik != NULL, &quot;invariant&quot;);
5285 
5286   // Set name and CLD before adding to CLD
5287   ik-&gt;set_class_loader_data(_loader_data);
5288   ik-&gt;set_name(_class_name);
5289 
5290   // Add all classes to our internal class loader list here,
5291   // including classes in the bootstrap (NULL) class loader.
5292   const bool publicize = !is_internal();
5293 
5294   _loader_data-&gt;add_class(ik, publicize);
5295 
5296   set_klass_to_deallocate(ik);
5297 
5298   assert(_field_info != NULL, &quot;invariant&quot;);
5299   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
5300   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
5301          &quot;sanity&quot;);
5302 
5303   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
5304   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
5305 
5306   // Fill in information already parsed
5307   ik-&gt;set_should_verify_class(_need_verify);
5308 
5309   // Not yet: supers are done below to support the new subtype-checking fields
5310   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
5311   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);















5312   assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">5313   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);</span>
5314 
5315   // this transfers ownership of a lot of arrays from
5316   // the parser onto the InstanceKlass*
5317   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5318 
5319   // can only set dynamic nest-host after static nest information is set
5320   if (cl_inst_info.dynamic_nest_host() != NULL) {
5321     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
5322   }
5323 
5324   // note that is not safe to use the fields in the parser from this point on
5325   assert(NULL == _cp, &quot;invariant&quot;);
5326   assert(NULL == _fields, &quot;invariant&quot;);
5327   assert(NULL == _methods, &quot;invariant&quot;);
5328   assert(NULL == _inner_classes, &quot;invariant&quot;);
5329   assert(NULL == _nest_members, &quot;invariant&quot;);
5330   assert(NULL == _combined_annotations, &quot;invariant&quot;);
5331   assert(NULL == _record_components, &quot;invariant&quot;);
5332   assert(NULL == _permitted_subclasses, &quot;invariant&quot;);
5333 
</pre>
<hr />
<pre>
5343   // has to be changed accordingly.
5344   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5345 
5346   ik-&gt;set_this_class_index(_this_class_index);
5347 
5348   if (_is_hidden || is_unsafe_anonymous()) {
5349     // _this_class_index is a CONSTANT_Class entry that refers to this
5350     // hidden or anonymous class itself. If this class needs to refer to its own
5351     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
5352     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
5353     // not stored in SystemDictionary), _this_class_index cannot be resolved
5354     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
5355     // Therefore, we must eagerly resolve _this_class_index now.
5356     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
5357   }
5358 
5359   ik-&gt;set_minor_version(_minor_version);
5360   ik-&gt;set_major_version(_major_version);
5361   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
5362   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);



5363 
5364   if (_unsafe_anonymous_host != NULL) {
5365     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
5366     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
5367   }
5368   if (_is_hidden) {
5369     ik-&gt;set_is_hidden();
5370   }
5371 
5372   // Set PackageEntry for this_klass
5373   oop cl = ik-&gt;class_loader();
5374   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
5375   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
5376   ik-&gt;set_package(cld, NULL, CHECK);
5377 
5378   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
5379   assert(methods != NULL, &quot;invariant&quot;);
5380   const int methods_len = methods-&gt;length();
5381 
5382   check_methods_for_intrinsics(ik, methods);
</pre>
<hr />
<pre>
5454 
5455   assert(_all_mirandas != NULL, &quot;invariant&quot;);
5456 
5457   // Generate any default methods - default methods are public interface methods
5458   // that have a default implementation.  This is new with Java 8.
5459   if (_has_nonstatic_concrete_methods) {
5460     DefaultMethods::generate_default_methods(ik,
5461                                              _all_mirandas,
5462                                              CHECK);
5463   }
5464 
5465   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
5466   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
5467       !module_entry-&gt;has_default_read_edges()) {
5468     if (!module_entry-&gt;set_has_default_read_edges()) {
5469       // We won a potential race
5470       JvmtiExport::add_default_read_edges(module_handle, THREAD);
5471     }
5472   }
5473 






























5474   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
5475 
5476   if (!is_internal()) {
5477     if (log_is_enabled(Info, class, load)) {
5478       ResourceMark rm;
5479       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
5480       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
5481     }
5482 
5483     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
5484         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
5485         log_is_enabled(Info, class, preview)) {
5486       ResourceMark rm;
5487       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
5488                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
5489     }
5490 
5491     if (log_is_enabled(Debug, class, resolve))  {
5492       ResourceMark rm;
5493       // print out the superclass.
</pre>
<hr />
<pre>
5503         const int length = local_interfaces-&gt;length();
5504         for (int i = 0; i &lt; length; i++) {
5505           const InstanceKlass* const k = local_interfaces-&gt;at(i);
5506           const char * to = k-&gt;external_name();
5507           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
5508         }
5509       }
5510     }
5511   }
5512 
5513   JFR_ONLY(INIT_ID(ik);)
5514 
5515   // If we reach here, all is well.
5516   // Now remove the InstanceKlass* from the _klass_to_deallocate field
5517   // in order for it to not be destroyed in the ClassFileParser destructor.
5518   set_klass_to_deallocate(NULL);
5519 
5520   // it&#39;s official
5521   set_klass(ik);
5522 




5523   debug_only(ik-&gt;verify();)
5524 }
5525 
5526 void ClassFileParser::update_class_name(Symbol* new_class_name) {
5527   // Decrement the refcount in the old name, since we&#39;re clobbering it.
5528   _class_name-&gt;decrement_refcount();
5529 
5530   _class_name = new_class_name;
5531   // Increment the refcount of the new name.
5532   // Now the ClassFileParser owns this name and will decrement in
5533   // the destructor.
5534   _class_name-&gt;increment_refcount();
5535 }
5536 
5537 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
5538 // package by prepending its host class&#39;s package name to its class name and setting
5539 // its _class_name field.
5540 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
5541   ResourceMark rm(THREAD);
5542   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
</pre>
<hr />
<pre>
5605   _stream(stream),
5606   _class_name(NULL),
5607   _loader_data(loader_data),
5608   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
5609   _cp_patches(cl_info-&gt;cp_patches()),
5610   _is_hidden(cl_info-&gt;is_hidden()),
5611   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
5612   _num_patched_klasses(0),
5613   _max_num_patched_klasses(0),
5614   _orig_cp_size(0),
5615   _first_patched_klass_resolved_index(0),
5616   _super_klass(),
5617   _cp(NULL),
5618   _fields(NULL),
5619   _methods(NULL),
5620   _inner_classes(NULL),
5621   _nest_members(NULL),
5622   _nest_host(0),
5623   _permitted_subclasses(NULL),
5624   _record_components(NULL),

5625   _local_interfaces(NULL),
5626   _transitive_interfaces(NULL),
5627   _combined_annotations(NULL),
5628   _class_annotations(NULL),
5629   _class_type_annotations(NULL),
5630   _fields_annotations(NULL),
5631   _fields_type_annotations(NULL),
5632   _klass(NULL),
5633   _klass_to_deallocate(NULL),
5634   _parsed_annotations(NULL),
5635   _fac(NULL),
5636   _field_info(NULL),
5637   _method_ordering(NULL),
5638   _all_mirandas(NULL),
5639   _vtable_size(0),
5640   _itable_size(0),
5641   _num_miranda_methods(0),
5642   _rt(REF_NONE),
5643   _protection_domain(cl_info-&gt;protection_domain()),
5644   _access_flags(),
5645   _pub_level(pub_level),
5646   _bad_constant_seen(0),
5647   _synthetic_flag(false),
5648   _sde_length(false),
5649   _sde_buffer(NULL),
5650   _sourcefile_index(0),
5651   _generic_signature_index(0),
5652   _major_version(0),
5653   _minor_version(0),
5654   _this_class_index(0),
5655   _super_class_index(0),
5656   _itfs_len(0),
5657   _java_fields_count(0),
5658   _need_verify(false),
5659   _relax_verify(false),
5660   _has_nonstatic_concrete_methods(false),
5661   _declares_nonstatic_concrete_methods(false),
5662   _has_final_method(false),
5663   _has_contended_fields(false),









5664   _has_finalizer(false),
5665   _has_empty_finalizer(false),
5666   _has_vanilla_constructor(false),
5667   _max_bootstrap_specifier_index(-1) {
5668 
5669   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
5670   _class_name-&gt;increment_refcount();
5671 
5672   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
5673   assert(_loader_data != NULL, &quot;invariant&quot;);
5674   assert(stream != NULL, &quot;invariant&quot;);
5675   assert(_stream != NULL, &quot;invariant&quot;);
5676   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
5677   assert(_class_name != NULL, &quot;invariant&quot;);
5678   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
5679 
5680   // Figure out whether we can skip format checking (matching classic VM behavior)
5681   if (DumpSharedSpaces) {
5682     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
5683     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
5854   } else {
5855     if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
5856       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
5857     }
5858     cp_size += _max_num_patched_klasses;
5859   }
5860 
5861   _cp = ConstantPool::allocate(_loader_data,
5862                                cp_size,
5863                                CHECK);
5864 
5865   ConstantPool* const cp = _cp;
5866 
5867   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
5868 
5869   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
5870 
5871   // ACCESS FLAGS
5872   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
5873 
<span class="line-modified">5874   // Access flags</span>
<span class="line-removed">5875   jint flags;</span>
5876   // JVM_ACC_MODULE is defined in JDK-9 and later.
5877   if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">5878     flags = stream-&gt;get_u2_fast() &amp; (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-modified">5879   } else {</span>
<span class="line-modified">5880     flags = stream-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS;</span>


5881   }
5882 



5883   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
5884     // Set abstract bit for old class files for backward compatibility
5885     flags |= JVM_ACC_ABSTRACT;
5886   }
5887 
5888   verify_legal_class_modifiers(flags, CHECK);
5889 
5890   short bad_constant = class_bad_constant_seen();
5891   if (bad_constant != 0) {
5892     // Do not throw CFE until after the access_flags are checked because if
5893     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
5894     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
5895   }
5896 
5897   _access_flags.set_flags(flags);
5898 
5899   // This class and superclass
5900   _this_class_index = stream-&gt;get_u2_fast();
5901   check_property(
5902     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
</pre>
<hr />
<pre>
6020           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6021           classlist_file-&gt;flush();
6022         }
6023       }
6024     }
6025 #endif
6026   }
6027 
6028   // SUPERKLASS
6029   _super_class_index = stream-&gt;get_u2_fast();
6030   _super_klass = parse_super_class(cp,
6031                                    _super_class_index,
6032                                    _need_verify,
6033                                    CHECK);
6034 
6035   // Interfaces
6036   _itfs_len = stream-&gt;get_u2_fast();
6037   parse_interfaces(stream,
6038                    _itfs_len,
6039                    cp,

6040                    &amp;_has_nonstatic_concrete_methods,

6041                    CHECK);
6042 
<span class="line-modified">6043   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
6044 
6045   // Fields (offsets are filled in later)
6046   _fac = new FieldAllocationCount();
6047   parse_fields(stream,
<span class="line-modified">6048                _access_flags.is_interface(),</span>

6049                _fac,
6050                cp,
6051                cp_size,
6052                &amp;_java_fields_count,
6053                CHECK);
6054 
6055   assert(_fields != NULL, &quot;invariant&quot;);
6056 
6057   // Methods
6058   AccessFlags promoted_flags;
6059   parse_methods(stream,
<span class="line-modified">6060                 _access_flags.is_interface(),</span>

6061                 &amp;promoted_flags,
6062                 &amp;_has_final_method,
6063                 &amp;_declares_nonstatic_concrete_methods,
6064                 CHECK);
6065 
6066   assert(_methods != NULL, &quot;invariant&quot;);
6067 
6068   // promote flags from parse_methods() to the klass&#39; flags
6069   _access_flags.add_promoted_flags(promoted_flags.as_int());
6070 
6071   if (_declares_nonstatic_concrete_methods) {
6072     _has_nonstatic_concrete_methods = true;
6073   }
6074 
6075   // Additional attributes/annotations
6076   _parsed_annotations = new ClassAnnotationCollector();
6077   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6078 
6079   assert(_inner_classes != NULL, &quot;invariant&quot;);
6080 
</pre>
<hr />
<pre>
6111 
6112   // Update this_class_index&#39;s slot in the constant pool with the new Utf8 entry.
6113   // We have to update the resolved_klass_index and the name_index together
6114   // so extract the existing resolved_klass_index first.
6115   CPKlassSlot cp_klass_slot = _cp-&gt;klass_slot_at(_this_class_index);
6116   int resolved_klass_index = cp_klass_slot.resolved_klass_index();
6117   _cp-&gt;unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);
6118   assert(_cp-&gt;klass_slot_at(_this_class_index).name_index() == _orig_cp_size,
6119          &quot;Bad name_index&quot;);
6120 }
6121 
6122 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6123                                                  ConstantPool* cp,
6124                                                  TRAPS) {
6125   assert(stream != NULL, &quot;invariant&quot;);
6126   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6127   assert(cp != NULL, &quot;invariant&quot;);
6128   assert(_loader_data != NULL, &quot;invariant&quot;);
6129 
6130   if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">6131     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),</span>
<span class="line-modified">6132                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">6133                    CHECK);</span>
6134   }
6135   // We check super class after class file is parsed and format is checked
6136   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6137     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">6138     if (_access_flags.is_interface()) {</span>
6139       // Before attempting to resolve the superclass, check for class format
6140       // errors not checked yet.
6141       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6142         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6143         CHECK);
6144     }
6145     Handle loader(THREAD, _loader_data-&gt;class_loader());
6146     _super_klass = (const InstanceKlass*)
6147                        SystemDictionary::resolve_super_or_fail(_class_name,
6148                                                                super_class_name,
6149                                                                loader,
6150                                                                _protection_domain,
6151                                                                true,
6152                                                                CHECK);
6153   }
6154 
6155   if (_super_klass != NULL) {
6156     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6157       _has_nonstatic_concrete_methods = true;
6158     }



6159 
6160     if (_super_klass-&gt;is_interface()) {
6161       ResourceMark rm(THREAD);
6162       Exceptions::fthrow(
6163         THREAD_AND_LOCATION,
6164         vmSymbols::java_lang_IncompatibleClassChangeError(),
6165         &quot;class %s has interface %s as super class&quot;,
6166         _class_name-&gt;as_klass_external_name(),
6167         _super_klass-&gt;external_name()
6168       );
6169       return;
6170     }




























6171   }
6172 




























6173   // Compute the transitive list of all unique interfaces implemented by this class
6174   _transitive_interfaces =
6175     compute_transitive_interfaces(_super_klass,
6176                                   _local_interfaces,
6177                                   _loader_data,
6178                                   CHECK);
6179 
6180   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6181 
6182   // sort methods
6183   _method_ordering = sort_methods(_methods);
6184 
6185   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6186 
6187   Handle loader(THREAD, _loader_data-&gt;class_loader());
6188   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6189                                                     &amp;_num_miranda_methods,
6190                                                     _all_mirandas,
6191                                                     _super_klass,
6192                                                     _methods,
6193                                                     _access_flags,
6194                                                     _major_version,
6195                                                     loader,
6196                                                     _class_name,
6197                                                     _local_interfaces,
6198                                                     CHECK);
6199 
6200   // Size of Java itable (in words)
<span class="line-modified">6201   _itable_size = _access_flags.is_interface() ? 0 :</span>
6202     klassItable::compute_itable_size(_transitive_interfaces);
6203 
6204   assert(_fac != NULL, &quot;invariant&quot;);
6205   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6206 












6207   _field_info = new FieldLayoutInfo();
6208   FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">6209                         _parsed_annotations-&gt;is_contended(), _field_info);</span>
<span class="line-modified">6210   lb.build_layout();</span>







6211 
<span class="line-modified">6212   // Compute reference typ</span>
6213   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
<span class="line-removed">6214 </span>
6215 }
6216 
6217 void ClassFileParser::set_klass(InstanceKlass* klass) {
6218 
6219 #ifdef ASSERT
6220   if (klass != NULL) {
6221     assert(NULL == _klass, &quot;leaking?&quot;);
6222   }
6223 #endif
6224 
6225   _klass = klass;
6226 }
6227 
6228 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6229 
6230 #ifdef ASSERT
6231   if (klass != NULL) {
6232     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
6233   }
6234 #endif
6235 
6236   _klass_to_deallocate = klass;
6237 }
6238 
6239 // Caller responsible for ResourceMark
6240 // clone stream with rewound position
6241 const ClassFileStream* ClassFileParser::clone_stream() const {
6242   assert(_stream != NULL, &quot;invariant&quot;);
6243 
6244   return _stream-&gt;clone();
6245 }

6246 // ----------------------------------------------------------------------------
6247 // debugging
6248 
6249 #ifdef ASSERT
6250 
6251 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
6252 bool ClassFileParser::is_internal_format(Symbol* class_name) {
6253   if (class_name != NULL) {
6254     ResourceMark rm;
6255     char* name = class_name-&gt;as_C_string();
6256     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
6257   } else {
6258     return true;
6259   }
6260 }
6261 
6262 #endif
</pre>
</td>
<td>
<hr />
<pre>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
<span class="line-added">  24 </span>
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/defaultMethods.hpp&quot;
  33 #include &quot;classfile/dictionary.hpp&quot;
  34 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/moduleEntry.hpp&quot;
  37 #include &quot;classfile/packageEntry.hpp&quot;
  38 #include &quot;classfile/symbolTable.hpp&quot;
  39 #include &quot;classfile/systemDictionary.hpp&quot;
  40 #include &quot;classfile/verificationType.hpp&quot;
  41 #include &quot;classfile/verifier.hpp&quot;
  42 #include &quot;classfile/vmSymbols.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;logging/logStream.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/annotations.hpp&quot;
  51 #include &quot;oops/constantPool.inline.hpp&quot;
  52 #include &quot;oops/fieldStreams.inline.hpp&quot;
<span class="line-added">  53 #include &quot;oops/inlineKlass.inline.hpp&quot;</span>
  54 #include &quot;oops/instanceKlass.hpp&quot;
  55 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  56 #include &quot;oops/klass.inline.hpp&quot;
  57 #include &quot;oops/klassVtable.hpp&quot;
  58 #include &quot;oops/metadata.hpp&quot;
  59 #include &quot;oops/method.inline.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;oops/recordComponent.hpp&quot;
  62 #include &quot;oops/symbol.hpp&quot;
  63 #include &quot;prims/jvmtiExport.hpp&quot;
  64 #include &quot;prims/jvmtiThreadState.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/javaCalls.hpp&quot;
  69 #include &quot;runtime/os.hpp&quot;
  70 #include &quot;runtime/perfData.hpp&quot;
  71 #include &quot;runtime/reflection.hpp&quot;
  72 #include &quot;runtime/safepointVerifiers.hpp&quot;
  73 #include &quot;runtime/signature.hpp&quot;
  74 #include &quot;runtime/timer.hpp&quot;
  75 #include &quot;services/classLoadingService.hpp&quot;
  76 #include &quot;services/threadService.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/bitMap.inline.hpp&quot;
  79 #include &quot;utilities/copy.hpp&quot;
  80 #include &quot;utilities/exceptions.hpp&quot;
  81 #include &quot;utilities/globalDefinitions.hpp&quot;
  82 #include &quot;utilities/growableArray.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #include &quot;utilities/ostream.hpp&quot;
  85 #include &quot;utilities/resourceHash.hpp&quot;
<span class="line-added">  86 #include &quot;utilities/stringUtils.hpp&quot;</span>
  87 #include &quot;utilities/utf8.hpp&quot;
  88 
  89 #if INCLUDE_CDS
  90 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  91 #endif
  92 #if INCLUDE_JFR
  93 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  94 #endif
  95 
  96 // We generally try to create the oops directly when parsing, rather than
  97 // allocating temporary data structures and copying the bytes twice. A
  98 // temporary area is only needed when parsing utf8 entries in the constant
  99 // pool and when parsing line number tables.
 100 
 101 // We add assert in debug mode when class format is not checked.
 102 
 103 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 104 #define JAVA_MIN_SUPPORTED_VERSION        45
 105 #define JAVA_PREVIEW_MINOR_VERSION        65535
 106 
</pre>
<hr />
<pre>
 120 
 121 // Extension method support.
 122 #define JAVA_8_VERSION                    52
 123 
 124 #define JAVA_9_VERSION                    53
 125 
 126 #define JAVA_10_VERSION                   54
 127 
 128 #define JAVA_11_VERSION                   55
 129 
 130 #define JAVA_12_VERSION                   56
 131 
 132 #define JAVA_13_VERSION                   57
 133 
 134 #define JAVA_14_VERSION                   58
 135 
 136 #define JAVA_15_VERSION                   59
 137 
 138 #define JAVA_16_VERSION                   60
 139 
<span class="line-added"> 140 #define CONSTANT_CLASS_DESCRIPTORS        60</span>
<span class="line-added"> 141 </span>
 142 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 143   assert((bad_constant == JVM_CONSTANT_Module ||
 144           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 145          &quot;Unexpected bad constant pool entry&quot;);
 146   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 147 }
 148 
 149 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 150                                                   ConstantPool* cp,
 151                                                   const int length,
 152                                                   TRAPS) {
 153   assert(stream != NULL, &quot;invariant&quot;);
 154   assert(cp != NULL, &quot;invariant&quot;);
 155 
 156   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 157   // this function (_current can be allocated in a register, with scalar
 158   // replacement of aggregates). The _current pointer is copied back to
 159   // stream() when this function returns. DON&#39;T call another method within
 160   // this method that uses stream().
 161   const ClassFileStream cfs1 = *stream;
 162   const ClassFileStream* const cfs = &amp;cfs1;
 163 
 164   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 165   debug_only(const u1* const old_current = stream-&gt;current();)
 166 
 167   // Used for batching symbol allocations.
 168   const char* names[SymbolTable::symbol_alloc_batch_size];
 169   int lengths[SymbolTable::symbol_alloc_batch_size];
 170   int indices[SymbolTable::symbol_alloc_batch_size];
 171   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 172   int names_count = 0;
 173 
 174   // parsing  Index 0 is unused
 175   for (int index = 1; index &lt; length; index++) {
 176     // Each of the following case guarantees one more byte in the stream
 177     // for the following tag or the access_flags following constant pool,
 178     // so we don&#39;t need bounds-check for reading tag.
 179     const u1 tag = cfs-&gt;get_u1_fast();
 180     switch (tag) {
<span class="line-modified"> 181       case JVM_CONSTANT_Class: {</span>
 182         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 183         const u2 name_index = cfs-&gt;get_u2_fast();
 184         cp-&gt;klass_index_at_put(index, name_index);
 185         break;
 186       }
 187       case JVM_CONSTANT_Fieldref: {
 188         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 189         const u2 class_index = cfs-&gt;get_u2_fast();
 190         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 191         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 192         break;
 193       }
 194       case JVM_CONSTANT_Methodref: {
 195         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 196         const u2 class_index = cfs-&gt;get_u2_fast();
 197         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 198         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 199         break;
 200       }
 201       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
<hr />
<pre>
 491         check_property(valid_symbol_at(name_ref_index),
 492           &quot;Invalid constant pool index %u in class file %s&quot;,
 493           name_ref_index, CHECK);
 494         check_property(valid_symbol_at(signature_ref_index),
 495           &quot;Invalid constant pool index %u in class file %s&quot;,
 496           signature_ref_index, CHECK);
 497         break;
 498       }
 499       case JVM_CONSTANT_Utf8:
 500         break;
 501       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 502       case JVM_CONSTANT_UnresolvedClassInError: {
 503         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 504         break;
 505       }
 506       case JVM_CONSTANT_ClassIndex: {
 507         const int class_index = cp-&gt;klass_index_at(index);
 508         check_property(valid_symbol_at(class_index),
 509           &quot;Invalid constant pool index %u in class file %s&quot;,
 510           class_index, CHECK);
<span class="line-modified"> 511 </span>
<span class="line-added"> 512         Symbol* const name = cp-&gt;symbol_at(class_index);</span>
<span class="line-added"> 513         const unsigned int name_len = name-&gt;utf8_length();</span>
<span class="line-added"> 514         if (name-&gt;is_Q_signature()) {</span>
<span class="line-added"> 515           cp-&gt;unresolved_qdescriptor_at_put(index, class_index, num_klasses++);</span>
<span class="line-added"> 516         } else {</span>
<span class="line-added"> 517           cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>
<span class="line-added"> 518         }</span>
 519         break;
 520       }
 521       case JVM_CONSTANT_StringIndex: {
 522         const int string_index = cp-&gt;string_index_at(index);
 523         check_property(valid_symbol_at(string_index),
 524           &quot;Invalid constant pool index %u in class file %s&quot;,
 525           string_index, CHECK);
 526         Symbol* const sym = cp-&gt;symbol_at(string_index);
 527         cp-&gt;unresolved_string_at_put(index, sym);
 528         break;
 529       }
 530       case JVM_CONSTANT_MethodHandle: {
 531         const int ref_index = cp-&gt;method_handle_index_at(index);
 532         check_property(valid_cp_range(ref_index, length),
 533           &quot;Invalid constant pool index %u in class file %s&quot;,
 534           ref_index, CHECK);
 535         const constantTag tag = cp-&gt;tag_at(ref_index);
 536         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 537 
 538         switch (ref_kind) {
</pre>
<hr />
<pre>
 752             classfile_parse_error(
 753               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 754               name_ref_index, CHECK);
 755           }
 756         }
 757         break;
 758       }
 759       case JVM_CONSTANT_MethodHandle: {
 760         const int ref_index = cp-&gt;method_handle_index_at(index);
 761         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 762         switch (ref_kind) {
 763           case JVM_REF_invokeVirtual:
 764           case JVM_REF_invokeStatic:
 765           case JVM_REF_invokeSpecial:
 766           case JVM_REF_newInvokeSpecial: {
 767             const int name_and_type_ref_index =
 768               cp-&gt;name_and_type_ref_index_at(ref_index);
 769             const int name_ref_index =
 770               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 771             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<span class="line-modified"> 772             if (name != vmSymbols::object_initializer_name()) {</span>
<span class="line-modified"> 773               if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
 774                 classfile_parse_error(
 775                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 776                     name_ref_index, CHECK);
 777               }
 778             } else {
<span class="line-modified"> 779               // The allowed invocation mode of &lt;init&gt; depends on its signature.</span>
<span class="line-added"> 780               // This test corresponds to verify_invoke_instructions in the verifier.</span>
<span class="line-added"> 781               const int signature_ref_index =</span>
<span class="line-added"> 782                 cp-&gt;signature_ref_index_at(name_and_type_ref_index);</span>
<span class="line-added"> 783               const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);</span>
<span class="line-added"> 784               if (signature-&gt;is_void_method_signature()</span>
<span class="line-added"> 785                   &amp;&amp; ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-added"> 786                 // OK, could be a constructor call</span>
<span class="line-added"> 787               } else if (!signature-&gt;is_void_method_signature()</span>
<span class="line-added"> 788                          &amp;&amp; ref_kind == JVM_REF_invokeStatic) {</span>
<span class="line-added"> 789                 // also OK, could be a static factory call</span>
<span class="line-added"> 790               } else {</span>
 791                 classfile_parse_error(
 792                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 793                   name_ref_index, CHECK);
 794               }
 795             }
 796             break;
 797           }
 798           // Other ref_kinds are already fully checked in previous pass.
 799         } // switch(ref_kind)
 800         break;
 801       }
 802       case JVM_CONSTANT_MethodType: {
 803         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 804         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 805         verify_legal_method_signature(no_name, signature, CHECK);
 806         break;
 807       }
 808       case JVM_CONSTANT_Utf8: {
 809         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 810       }
</pre>
<hr />
<pre>
 929   while (entry != NULL) {
 930     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 931       return false;
 932     }
 933     entry = entry-&gt;_next;
 934   }
 935 
 936   // No duplicate is found, allocate a new entry and fill it.
 937   entry = new NameSigHash();
 938   entry-&gt;_name = name;
 939   entry-&gt;_sig = sig;
 940 
 941   // Insert into hash table
 942   entry-&gt;_next = table[index];
 943   table[index] = entry;
 944 
 945   return true;
 946 }
 947 
 948 // Side-effects: populates the _local_interfaces field
<span class="line-modified"> 949 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,</span>
<span class="line-modified"> 950                                        int itfs_len,</span>
<span class="line-modified"> 951                                        ConstantPool* cp,</span>
<span class="line-added"> 952                                        bool is_inline_type,</span>
 953                                        bool* const has_nonstatic_concrete_methods,
<span class="line-added"> 954                                        // FIXME: lots of these functions</span>
<span class="line-added"> 955                                        // declare their parameters as const,</span>
<span class="line-added"> 956                                        // which adds only noise to the code.</span>
<span class="line-added"> 957                                        // Remove the spurious const modifiers.</span>
<span class="line-added"> 958                                        // Many are of the form &quot;const int x&quot;</span>
<span class="line-added"> 959                                        // or &quot;T* const x&quot;.</span>
<span class="line-added"> 960                                        bool* const is_declared_atomic,</span>
 961                                        TRAPS) {
 962   assert(stream != NULL, &quot;invariant&quot;);
 963   assert(cp != NULL, &quot;invariant&quot;);
 964   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 965 
 966   if (itfs_len == 0) {
<span class="line-modified"> 967     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(0);</span>
 968   } else {
 969     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 970     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(itfs_len);</span>
<span class="line-modified"> 971     int index = 0;</span>

 972     for (index = 0; index &lt; itfs_len; index++) {
 973       const u2 interface_index = stream-&gt;get_u2(CHECK);
 974       Klass* interf;
 975       check_property(
 976         valid_klass_reference_at(interface_index),
 977         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 978         interface_index, CHECK);
 979       if (cp-&gt;tag_at(interface_index).is_klass()) {
 980         interf = cp-&gt;resolved_klass_at(interface_index);
 981       } else {
 982         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 983 
 984         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 985         // But need to make sure it&#39;s not an array type.
 986         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 987                            &quot;Bad interface name in class file %s&quot;, CHECK);
 988 
<span class="line-modified"> 989         // Call resolve_super so class circularity is checked</span>
 990         interf = SystemDictionary::resolve_super_or_fail(
 991                                                   _class_name,
 992                                                   unresolved_klass,
 993                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 994                                                   _protection_domain,
 995                                                   false,
 996                                                   CHECK);
 997       }
 998 
 999       if (!interf-&gt;is_interface()) {
1000         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
1001                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
1002                           _class_name-&gt;as_klass_external_name(),
1003                           interf-&gt;external_name(),
1004                           interf-&gt;class_in_module_of_loader()));
1005       }
1006 
<span class="line-modified">1007       InstanceKlass* ik = InstanceKlass::cast(interf);</span>
<span class="line-added">1008       if (is_inline_type &amp;&amp; ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">1009         ResourceMark rm(THREAD);</span>
<span class="line-added">1010         Exceptions::fthrow(</span>
<span class="line-added">1011           THREAD_AND_LOCATION,</span>
<span class="line-added">1012           vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">1013           &quot;Inline type %s attempts to implement interface java.lang.IdentityObject&quot;,</span>
<span class="line-added">1014           _class_name-&gt;as_klass_external_name());</span>
<span class="line-added">1015         return;</span>
<span class="line-added">1016       }</span>
<span class="line-added">1017       if (ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">1018         set_invalid_inline_super();</span>
<span class="line-added">1019       }</span>
<span class="line-added">1020       if (ik-&gt;has_nonstatic_concrete_methods()) {</span>
1021         *has_nonstatic_concrete_methods = true;
1022       }
<span class="line-modified">1023       if (ik-&gt;is_declared_atomic()) {</span>
<span class="line-added">1024         *is_declared_atomic = true;</span>
<span class="line-added">1025       }</span>
<span class="line-added">1026       if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">1027         _implements_identityObject = true;</span>
<span class="line-added">1028       }</span>
<span class="line-added">1029       _temp_local_interfaces-&gt;append(ik);</span>
1030     }
1031 
1032     if (!_need_verify || itfs_len &lt;= 1) {
1033       return;
1034     }
1035 
1036     // Check if there&#39;s any duplicates in interfaces
1037     ResourceMark rm(THREAD);
1038     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1039                                                                  NameSigHash*,
1040                                                                  HASH_ROW_SIZE);
1041     initialize_hashtable(interface_names);
1042     bool dup = false;
1043     const Symbol* name = NULL;
1044     {
1045       debug_only(NoSafepointVerifier nsv;)
1046       for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified">1047         const InstanceKlass* const k = _temp_local_interfaces-&gt;at(index);</span>
1048         name = k-&gt;name();
1049         // If no duplicates, add (name, NULL) in hashtable interface_names.
1050         if (!put_after_lookup(name, NULL, interface_names)) {
1051           dup = true;
1052           break;
1053         }
1054       }
1055     }
1056     if (dup) {
1057       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1058                              name-&gt;as_C_string(), CHECK);
1059     }
1060   }
1061 }
1062 
1063 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1064                                            int constantvalue_index,
1065                                            int signature_index,
1066                                            TRAPS) const {
1067   // Make sure the constant pool entry is of a type appropriate to this field
</pre>
<hr />
<pre>
1503                                             CHECK);
1504   parsed_annotations-&gt;set_field_annotations(a);
1505   a = assemble_annotations(runtime_visible_type_annotations,
1506                            runtime_visible_type_annotations_length,
1507                            runtime_invisible_type_annotations,
1508                            runtime_invisible_type_annotations_length,
1509                            CHECK);
1510   parsed_annotations-&gt;set_field_type_annotations(a);
1511   return;
1512 }
1513 
1514 
1515 // Field allocation types. Used for computing field offsets.
1516 
1517 enum FieldAllocationType {
1518   STATIC_OOP,           // Oops
1519   STATIC_BYTE,          // Boolean, Byte, char
1520   STATIC_SHORT,         // shorts
1521   STATIC_WORD,          // ints
1522   STATIC_DOUBLE,        // aligned long or double
<span class="line-added">1523   STATIC_INLINE,        // inline type field</span>
1524   NONSTATIC_OOP,
1525   NONSTATIC_BYTE,
1526   NONSTATIC_SHORT,
1527   NONSTATIC_WORD,
1528   NONSTATIC_DOUBLE,
<span class="line-added">1529   NONSTATIC_INLINE,</span>
1530   MAX_FIELD_ALLOCATION_TYPE,
1531   BAD_ALLOCATION_TYPE = -1
1532 };
1533 
1534 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1535   BAD_ALLOCATION_TYPE, // 0
1536   BAD_ALLOCATION_TYPE, // 1
1537   BAD_ALLOCATION_TYPE, // 2
1538   BAD_ALLOCATION_TYPE, // 3
1539   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1540   NONSTATIC_SHORT,     // T_CHAR        =  5,
1541   NONSTATIC_WORD,      // T_FLOAT       =  6,
1542   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1543   NONSTATIC_BYTE,      // T_BYTE        =  8,
1544   NONSTATIC_SHORT,     // T_SHORT       =  9,
1545   NONSTATIC_WORD,      // T_INT         = 10,
1546   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1547   NONSTATIC_OOP,       // T_OBJECT      = 12,
1548   NONSTATIC_OOP,       // T_ARRAY       = 13,
<span class="line-modified">1549   NONSTATIC_OOP,       // T_INLINE_TYPE = 14,</span>
<span class="line-modified">1550   BAD_ALLOCATION_TYPE, // T_VOID        = 15,</span>
<span class="line-modified">1551   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,</span>
<span class="line-modified">1552   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,</span>
<span class="line-modified">1553   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,</span>
<span class="line-modified">1554   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,</span>
<span class="line-added">1555   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20,</span>
1556   BAD_ALLOCATION_TYPE, // 0
1557   BAD_ALLOCATION_TYPE, // 1
1558   BAD_ALLOCATION_TYPE, // 2
1559   BAD_ALLOCATION_TYPE, // 3
1560   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1561   STATIC_SHORT,        // T_CHAR        =  5,
1562   STATIC_WORD,         // T_FLOAT       =  6,
1563   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1564   STATIC_BYTE,         // T_BYTE        =  8,
1565   STATIC_SHORT,        // T_SHORT       =  9,
1566   STATIC_WORD,         // T_INT         = 10,
1567   STATIC_DOUBLE,       // T_LONG        = 11,
1568   STATIC_OOP,          // T_OBJECT      = 12,
1569   STATIC_OOP,          // T_ARRAY       = 13,
<span class="line-modified">1570   STATIC_OOP,          // T_INLINE_TYPE = 14,</span>
<span class="line-modified">1571   BAD_ALLOCATION_TYPE, // T_VOID        = 15,</span>
<span class="line-modified">1572   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,</span>
<span class="line-modified">1573   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,</span>
<span class="line-modified">1574   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,</span>
<span class="line-modified">1575   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,</span>
<span class="line-added">1576   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20</span>
1577 };
1578 
<span class="line-modified">1579 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_inline_type) {</span>
1580   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1581   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1582   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
<span class="line-added">1583   if (is_inline_type) {</span>
<span class="line-added">1584     result = is_static ? STATIC_INLINE : NONSTATIC_INLINE;</span>
<span class="line-added">1585   }</span>
1586   return result;
1587 }
1588 
1589 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1590  public:
1591   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1592 
1593   FieldAllocationCount() {
1594     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1595       count[i] = 0;
1596     }
1597   }
1598 
<span class="line-modified">1599   FieldAllocationType update(bool is_static, BasicType type, bool is_inline_type) {</span>
<span class="line-modified">1600     FieldAllocationType atype = basic_type_to_atype(is_static, type, is_inline_type);</span>
1601     if (atype != BAD_ALLOCATION_TYPE) {
1602       // Make sure there is no overflow with injected fields.
1603       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1604       count[atype]++;
1605     }
1606     return atype;
1607   }
1608 };
1609 
1610 // Side-effects: populates the _fields, _fields_annotations,
1611 // _fields_type_annotations fields
1612 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1613                                    bool is_interface,
<span class="line-added">1614                                    bool is_inline_type,</span>
1615                                    FieldAllocationCount* const fac,
1616                                    ConstantPool* cp,
1617                                    const int cp_size,
1618                                    u2* const java_fields_count_ptr,
1619                                    TRAPS) {
1620 
1621   assert(cfs != NULL, &quot;invariant&quot;);
1622   assert(fac != NULL, &quot;invariant&quot;);
1623   assert(cp != NULL, &quot;invariant&quot;);
1624   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1625 
1626   assert(NULL == _fields, &quot;invariant&quot;);
1627   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1628   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1629 
1630   cfs-&gt;guarantee_more(2, CHECK);  // length
1631   const u2 length = cfs-&gt;get_u2_fast();
1632   *java_fields_count_ptr = length;
1633 
1634   int num_injected = 0;
1635   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1636                                                                   &amp;num_injected);
<span class="line-modified">1637 </span>
<span class="line-added">1638   // two more slots are required for inline classes:</span>
<span class="line-added">1639   // one for the static field with a reference to the pre-allocated default value</span>
<span class="line-added">1640   // one for the field the JVM injects when detecting an empty inline class</span>
<span class="line-added">1641   const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);</span>
1642 
1643   // The field array starts with tuples of shorts
1644   // [access, name index, sig index, initial value index, byte offset].
1645   // A generic signature slot only exists for field with generic
1646   // signature attribute. And the access flag is set with
1647   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1648   // signature slots are at the end of the field array and after all
1649   // other fields data.
1650   //
1651   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1652   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1653   //       ...
1654   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1655   //       [generic signature index]
1656   //       [generic signature index]
1657   //       ...
1658   //
1659   // Allocate a temporary resource array for field data. For each field,
1660   // a slot is reserved in the temporary array for the generic signature
1661   // index. After parsing all fields, the data are copied to a permanent
1662   // array and any unused slots will be discarded.
1663   ResourceMark rm(THREAD);
1664   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1665                                               u2,
1666                                               total_fields * (FieldInfo::field_slots + 1));
1667 
1668   // The generic signature slots start after all other fields&#39; data.
1669   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1670   int num_generic_signature = 0;
<span class="line-added">1671   int instance_fields_count = 0;</span>
1672   for (int n = 0; n &lt; length; n++) {
1673     // access_flags, name_index, descriptor_index, attributes_count
1674     cfs-&gt;guarantee_more(8, CHECK);
1675 
<span class="line-added">1676     jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-added">1677 </span>
<span class="line-added">1678     const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">1679     verify_legal_field_modifiers(flags, is_interface, is_inline_type, CHECK);</span>
1680     AccessFlags access_flags;


1681     access_flags.set_flags(flags);
1682 
1683     const u2 name_index = cfs-&gt;get_u2_fast();
1684     check_property(valid_symbol_at(name_index),
1685       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1686       name_index, CHECK);
1687     const Symbol* const name = cp-&gt;symbol_at(name_index);
1688     verify_legal_field_name(name, CHECK);
1689 
1690     const u2 signature_index = cfs-&gt;get_u2_fast();
1691     check_property(valid_symbol_at(signature_index),
1692       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1693       signature_index, CHECK);
1694     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1695     verify_legal_field_signature(name, sig, CHECK);
<span class="line-added">1696     if (!access_flags.is_static()) instance_fields_count++;</span>
1697 
1698     u2 constantvalue_index = 0;
1699     bool is_synthetic = false;
1700     u2 generic_signature_index = 0;
1701     const bool is_static = access_flags.is_static();
1702     FieldAnnotationCollector parsed_annotations(_loader_data);
1703 
1704     const u2 attributes_count = cfs-&gt;get_u2_fast();
1705     if (attributes_count &gt; 0) {
1706       parse_field_attributes(cfs,
1707                              attributes_count,
1708                              is_static,
1709                              signature_index,
1710                              &amp;constantvalue_index,
1711                              &amp;is_synthetic,
1712                              &amp;generic_signature_index,
1713                              &amp;parsed_annotations,
1714                              CHECK);
1715 
1716       if (parsed_annotations.field_annotations() != NULL) {
</pre>
<hr />
<pre>
1736 
1737       if (is_synthetic) {
1738         access_flags.set_is_synthetic();
1739       }
1740       if (generic_signature_index != 0) {
1741         access_flags.set_field_has_generic_signature();
1742         fa[generic_signature_slot] = generic_signature_index;
1743         generic_signature_slot ++;
1744         num_generic_signature ++;
1745       }
1746     }
1747 
1748     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1749     field-&gt;initialize(access_flags.as_short(),
1750                       name_index,
1751                       signature_index,
1752                       constantvalue_index);
1753     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1754 
1755     // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1756     const FieldAllocationType atype = fac-&gt;update(is_static, type, type == T_INLINE_TYPE);</span>
1757     field-&gt;set_allocation_type(atype);
1758 
1759     // After field is initialized with type, we can augment it with aux info
1760     if (parsed_annotations.has_any_annotations()) {
1761       parsed_annotations.apply_to(field);
1762       if (field-&gt;is_contended()) {
1763         _has_contended_fields = true;
1764       }
1765     }
1766   }
1767 
1768   int index = length;
1769   if (num_injected != 0) {
1770     for (int n = 0; n &lt; num_injected; n++) {
1771       // Check for duplicates
1772       if (injected[n].may_be_java) {
1773         const Symbol* const name      = injected[n].name();
1774         const Symbol* const signature = injected[n].signature();
1775         bool duplicate = false;
1776         for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
1781             duplicate = true;
1782             break;
1783           }
1784         }
1785         if (duplicate) {
1786           // These will be removed from the field array at the end
1787           continue;
1788         }
1789       }
1790 
1791       // Injected field
1792       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1793       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1794                         injected[n].name_index,
1795                         injected[n].signature_index,
1796                         0);
1797 
1798       const BasicType type = Signature::basic_type(injected[n].signature());
1799 
1800       // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1801       const FieldAllocationType atype = fac-&gt;update(false, type, false);</span>
1802       field-&gt;set_allocation_type(atype);
1803       index++;
1804     }
1805   }
1806 
<span class="line-added">1807   if (is_inline_type) {</span>
<span class="line-added">1808     FieldInfo* const field = FieldInfo::from_field_array(fa, index);</span>
<span class="line-added">1809     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,</span>
<span class="line-added">1810                       vmSymbols::default_value_name_enum,</span>
<span class="line-added">1811                       vmSymbols::object_signature_enum,</span>
<span class="line-added">1812                       0);</span>
<span class="line-added">1813     const BasicType type = Signature::basic_type(vmSymbols::object_signature());</span>
<span class="line-added">1814     const FieldAllocationType atype = fac-&gt;update(true, type, false);</span>
<span class="line-added">1815     field-&gt;set_allocation_type(atype);</span>
<span class="line-added">1816     index++;</span>
<span class="line-added">1817   }</span>
<span class="line-added">1818 </span>
<span class="line-added">1819   if (is_inline_type &amp;&amp; instance_fields_count == 0) {</span>
<span class="line-added">1820     _is_empty_inline_type = true;</span>
<span class="line-added">1821     FieldInfo* const field = FieldInfo::from_field_array(fa, index);</span>
<span class="line-added">1822     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,</span>
<span class="line-added">1823         vmSymbols::empty_marker_name_enum,</span>
<span class="line-added">1824         vmSymbols::byte_signature_enum,</span>
<span class="line-added">1825         0);</span>
<span class="line-added">1826     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());</span>
<span class="line-added">1827     const FieldAllocationType atype = fac-&gt;update(false, type, false);</span>
<span class="line-added">1828     field-&gt;set_allocation_type(atype);</span>
<span class="line-added">1829     index++;</span>
<span class="line-added">1830   }</span>
<span class="line-added">1831 </span>
<span class="line-added">1832   if (instance_fields_count &gt; 0) {</span>
<span class="line-added">1833     _has_nonstatic_fields = true;</span>
<span class="line-added">1834   }</span>
<span class="line-added">1835 </span>
1836   assert(NULL == _fields, &quot;invariant&quot;);
1837 
1838   _fields =
1839     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1840                                    index * FieldInfo::field_slots + num_generic_signature,
1841                                    CHECK);
1842   // Sometimes injected fields already exist in the Java source so
1843   // the fields array could be too long.  In that case the
1844   // fields array is trimed. Also unused slots that were reserved
1845   // for generic signature indexes are discarded.
1846   {
1847     int i = 0;
1848     for (; i &lt; index * FieldInfo::field_slots; i++) {
1849       _fields-&gt;at_put(i, fa[i]);
1850     }
1851     for (int j = total_fields * FieldInfo::field_slots;
1852          j &lt; generic_signature_slot; j++) {
1853       _fields-&gt;at_put(i++, fa[j]);
1854     }
1855     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
2131         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2132         checked_exception, CHECK_NULL);
2133     }
2134   }
2135   // check exceptions attribute length
2136   if (_need_verify) {
2137     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2138                                                    sizeof(u2) * size),
2139                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2140   }
2141   return checked_exceptions_start;
2142 }
2143 
2144 void ClassFileParser::throwIllegalSignature(const char* type,
2145                                             const Symbol* name,
2146                                             const Symbol* sig,
2147                                             TRAPS) const {
2148   assert(name != NULL, &quot;invariant&quot;);
2149   assert(sig != NULL, &quot;invariant&quot;);
2150 
<span class="line-added">2151   const char* class_note = &quot;&quot;;</span>
<span class="line-added">2152   if (is_inline_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">2153     class_note = &quot; (an inline class)&quot;;</span>
<span class="line-added">2154   }</span>
<span class="line-added">2155 </span>
2156   ResourceMark rm(THREAD);
2157   Exceptions::fthrow(THREAD_AND_LOCATION,
2158       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">2159       &quot;%s \&quot;%s\&quot; in class %s%s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">2160       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, sig-&gt;as_C_string());</span>
2161 }
2162 
2163 AnnotationCollector::ID
2164 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2165                                       const Symbol* name,
2166                                       const bool can_access_vm_annotations) {
2167   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2168   // Privileged code can use all annotations.  Other code silently drops some.
2169   const bool privileged = loader_data-&gt;is_boot_class_loader_data() ||
2170                           loader_data-&gt;is_platform_class_loader_data() ||
2171                           can_access_vm_annotations;
2172   switch (sid) {
2173     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2174       if (_location != _in_method)  break;  // only allow for methods
2175       if (!privileged)              break;  // only allow in privileged code
2176       return _method_CallerSensitive;
2177     }
2178     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2179       if (_location != _in_method)  break;  // only allow for methods
2180       if (!privileged)              break;  // only allow in privileged code
</pre>
<hr />
<pre>
2405                              runtime_visible_type_annotations_length,
2406                              runtime_invisible_type_annotations,
2407                              runtime_invisible_type_annotations_length,
2408                              CHECK);
2409     cm-&gt;set_type_annotations(a);
2410   }
2411 }
2412 
2413 
2414 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2415 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2416 // Method* to save footprint, so we only know the size of the resulting Method* when the
2417 // entire method attribute is parsed.
2418 //
2419 // The promoted_flags parameter is used to pass relevant access_flags
2420 // from the method back up to the containing klass. These flag values
2421 // are added to klass&#39;s access_flags.
2422 
2423 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2424                                       bool is_interface,
<span class="line-added">2425                                       bool is_inline_type,</span>
2426                                       const ConstantPool* cp,
2427                                       AccessFlags* const promoted_flags,
2428                                       TRAPS) {
2429   assert(cfs != NULL, &quot;invariant&quot;);
2430   assert(cp != NULL, &quot;invariant&quot;);
2431   assert(promoted_flags != NULL, &quot;invariant&quot;);
2432 
2433   ResourceMark rm(THREAD);
2434   // Parse fixed parts:
2435   // access_flags, name_index, descriptor_index, attributes_count
2436   cfs-&gt;guarantee_more(8, CHECK_NULL);
2437 
2438   int flags = cfs-&gt;get_u2_fast();
2439   const u2 name_index = cfs-&gt;get_u2_fast();
2440   const int cp_size = cp-&gt;length();
2441   check_property(
2442     valid_symbol_at(name_index),
2443     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2444     name_index, CHECK_NULL);
2445   const Symbol* const name = cp-&gt;symbol_at(name_index);
2446   verify_legal_method_name(name, CHECK_NULL);
2447 
2448   const u2 signature_index = cfs-&gt;get_u2_fast();
2449   guarantee_property(
2450     valid_symbol_at(signature_index),
2451     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2452     signature_index, CHECK_NULL);
2453   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2454 
2455   if (name == vmSymbols::class_initializer_name()) {
2456     // We ignore the other access flags for a valid class initializer.
2457     // (JVM Spec 2nd ed., chapter 4.6)
2458     if (_major_version &lt; 51) { // backward compatibility
2459       flags = JVM_ACC_STATIC;
2460     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2461       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2462     } else {
2463       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2464     }
2465   } else {
<span class="line-modified">2466     verify_legal_method_modifiers(flags, is_interface, is_inline_type, name, CHECK_NULL);</span>
<span class="line-modified">2467   }</span>
<span class="line-modified">2468 </span>
<span class="line-modified">2469   if (name == vmSymbols::object_initializer_name()) {</span>
<span class="line-modified">2470     if (is_interface) {</span>
<span class="line-added">2471       classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>
<span class="line-added">2472     } else if (!is_inline_type &amp;&amp; signature-&gt;is_void_method_signature()) {</span>
<span class="line-added">2473       // OK, a constructor</span>
<span class="line-added">2474     } else if (is_inline_type &amp;&amp; !signature-&gt;is_void_method_signature()) {</span>
<span class="line-added">2475       // also OK, a static factory, as long as the return value is good</span>
<span class="line-added">2476       bool ok = false;</span>
<span class="line-added">2477       SignatureStream ss((Symbol*) signature, true);</span>
<span class="line-added">2478       while (!ss.at_return_type())  ss.next();</span>
<span class="line-added">2479       if (ss.is_reference()) {</span>
<span class="line-added">2480         Symbol* ret = ss.as_symbol();</span>
<span class="line-added">2481         const Symbol* required = class_name();</span>
<span class="line-added">2482         if (is_hidden()) {</span>
<span class="line-added">2483           // The original class name in hidden classes gets changed.  So using</span>
<span class="line-added">2484           // the original name in the return type is no longer valid.</span>
<span class="line-added">2485           // Note that expecting the return type for inline hidden class factory</span>
<span class="line-added">2486           // methods to be java.lang.Object works around a JVM Spec issue for</span>
<span class="line-added">2487           // hidden classes.</span>
<span class="line-added">2488           required = vmSymbols::java_lang_Object();</span>
<span class="line-added">2489         }</span>
<span class="line-added">2490         ok = (ret == required);</span>
<span class="line-added">2491       }</span>
<span class="line-added">2492       if (!ok) {</span>
<span class="line-added">2493         throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);</span>
<span class="line-added">2494       }</span>
<span class="line-added">2495     } else {</span>
<span class="line-added">2496       // not OK, so throw the same error as in verify_legal_method_signature.</span>
<span class="line-added">2497       throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);</span>
<span class="line-added">2498     }</span>
<span class="line-added">2499     // A declared &lt;init&gt; method must always be either a non-static</span>
<span class="line-added">2500     // object constructor, with a void return, or else it must be a</span>
<span class="line-added">2501     // static factory method, with a non-void return.  No other</span>
<span class="line-added">2502     // definition of &lt;init&gt; is possible.</span>
<span class="line-added">2503     //</span>
<span class="line-added">2504     // The verifier (in verify_invoke_instructions) will inspect the</span>
<span class="line-added">2505     // signature of any attempt to invoke &lt;init&gt;, and ensures that it</span>
<span class="line-added">2506     // returns non-void if and only if it is being invoked by</span>
<span class="line-added">2507     // invokestatic, and void if and only if it is being invoked by</span>
<span class="line-added">2508     // invokespecial.</span>
<span class="line-added">2509     //</span>
<span class="line-added">2510     // When a symbolic reference to &lt;init&gt; is resolved for a</span>
<span class="line-added">2511     // particular invocation mode (special or static), the mode is</span>
<span class="line-added">2512     // matched to the JVM_ACC_STATIC modifier of the &lt;init&gt; method.</span>
<span class="line-added">2513     // Thus, it is impossible to statically invoke a constructor, and</span>
<span class="line-added">2514     // impossible to &quot;new + invokespecial&quot; a static factory, either</span>
<span class="line-added">2515     // through bytecode or through reflection.</span>
2516   }
2517 
2518   int args_size = -1;  // only used when _need_verify is true
2519   if (_need_verify) {
2520     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2521                  verify_legal_method_signature(name, signature, CHECK_NULL);
2522     if (args_size &gt; MAX_ARGS_SIZE) {
2523       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2524     }
2525   }
2526 
2527   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2528 
2529   // Default values for code and exceptions attribute elements
2530   u2 max_stack = 0;
2531   u2 max_locals = 0;
2532   u4 code_length = 0;
2533   const u1* code_start = 0;
2534   u2 exception_table_length = 0;
2535   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
</pre>
<hr />
<pre>
3046       _has_finalizer = true;
3047     }
3048   }
3049   if (name == vmSymbols::object_initializer_name() &amp;&amp;
3050       signature == vmSymbols::void_method_signature() &amp;&amp;
3051       m-&gt;is_vanilla_constructor()) {
3052     _has_vanilla_constructor = true;
3053   }
3054 
3055   NOT_PRODUCT(m-&gt;verify());
3056   return m;
3057 }
3058 
3059 
3060 // The promoted_flags parameter is used to pass relevant access_flags
3061 // from the methods back up to the containing klass. These flag values
3062 // are added to klass&#39;s access_flags.
3063 // Side-effects: populates the _methods field in the parser
3064 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
3065                                     bool is_interface,
<span class="line-added">3066                                     bool is_inline_type,</span>
3067                                     AccessFlags* promoted_flags,
3068                                     bool* has_final_method,
3069                                     bool* declares_nonstatic_concrete_methods,
3070                                     TRAPS) {
3071   assert(cfs != NULL, &quot;invariant&quot;);
3072   assert(promoted_flags != NULL, &quot;invariant&quot;);
3073   assert(has_final_method != NULL, &quot;invariant&quot;);
3074   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
3075 
3076   assert(NULL == _methods, &quot;invariant&quot;);
3077 
3078   cfs-&gt;guarantee_more(2, CHECK);  // length
3079   const u2 length = cfs-&gt;get_u2_fast();
3080   if (length == 0) {
3081     _methods = Universe::the_empty_method_array();
3082   } else {
3083     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
3084                                                    length,
3085                                                    NULL,
3086                                                    CHECK);
3087 
3088     for (int index = 0; index &lt; length; index++) {
3089       Method* method = parse_method(cfs,
3090                                     is_interface,
<span class="line-added">3091                                     is_inline_type,</span>
3092                                     _cp,
3093                                     promoted_flags,
3094                                     CHECK);
3095 
3096       if (method-&gt;is_final()) {
3097         *has_final_method = true;
3098       }
3099       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
3100       // used for interface initialization, and default method inheritance analysis
3101       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
3102         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
3103         *declares_nonstatic_concrete_methods = true;
3104       }
3105       _methods-&gt;at_put(index, method);
3106     }
3107 
3108     if (_need_verify &amp;&amp; length &gt; 1) {
3109       // Check duplicated methods
3110       ResourceMark rm(THREAD);
3111       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
</pre>
<hr />
<pre>
3264       valid_klass_reference_at(inner_class_info_index),
3265       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3266       inner_class_info_index, CHECK_0);
3267     // Outer class index
3268     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3269     check_property(
3270       outer_class_info_index == 0 ||
3271         valid_klass_reference_at(outer_class_info_index),
3272       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3273       outer_class_info_index, CHECK_0);
3274     // Inner class name
3275     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3276     check_property(
3277       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3278       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3279       inner_name_index, CHECK_0);
3280     if (_need_verify) {
3281       guarantee_property(inner_class_info_index != outer_class_info_index,
3282                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3283     }
<span class="line-modified">3284 </span>
<span class="line-modified">3285     jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;</span>
3286     // JVM_ACC_MODULE is defined in JDK-9 and later.
3287     if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">3288       recognized_modifiers |= JVM_ACC_MODULE;</span>
<span class="line-modified">3289     }</span>
<span class="line-modified">3290     // JVM_ACC_INLINE is defined for class file version 55 and later</span>
<span class="line-added">3291     if (supports_inline_types()) {</span>
<span class="line-added">3292       recognized_modifiers |= JVM_ACC_INLINE;</span>
3293     }
<span class="line-added">3294 </span>
<span class="line-added">3295     // Access flags</span>
<span class="line-added">3296     jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">3297 </span>
3298     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3299       // Set abstract bit for old class files for backward compatibility
3300       flags |= JVM_ACC_ABSTRACT;
3301     }
3302     verify_legal_class_modifiers(flags, CHECK_0);
3303     AccessFlags inner_access_flags(flags);
3304 
3305     inner_classes-&gt;at_put(index++, inner_class_info_index);
3306     inner_classes-&gt;at_put(index++, outer_class_info_index);
3307     inner_classes-&gt;at_put(index++, inner_name_index);
3308     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3309   }
3310 
3311   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3312   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3313     for(int i = 0; i &lt; length * 4; i += 4) {
3314       for(int j = i + 4; j &lt; length * 4; j += 4) {
3315         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3316                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3317                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
</pre>
<hr />
<pre>
3650     operands-&gt;at_put(operand_fill_index++, argument_count);
3651 
3652     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3653     for (int j = 0; j &lt; argument_count; j++) {
3654       const u2 argument_index = cfs-&gt;get_u2_fast();
3655       check_property(
3656         valid_cp_range(argument_index, cp_size) &amp;&amp;
3657         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3658         &quot;argument_index %u has bad constant type in class file %s&quot;,
3659         argument_index,
3660         CHECK);
3661       operands-&gt;at_put(operand_fill_index++, argument_index);
3662     }
3663   }
3664   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3665                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3666                      CHECK);
3667 }
3668 
3669 bool ClassFileParser::supports_sealed_types() {
<span class="line-modified">3670   // temporarily disable the sealed type preview feature check</span>
<span class="line-modified">3671   return _major_version == JVM_CLASSFILE_MAJOR_VERSION;</span>

3672 }
3673 
3674 bool ClassFileParser::supports_records() {
3675   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
3676          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
3677          Arguments::enable_preview();
3678 }
3679 
3680 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3681                                                  ConstantPool* cp,
3682                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3683                                                  TRAPS) {
3684   assert(cfs != NULL, &quot;invariant&quot;);
3685   assert(cp != NULL, &quot;invariant&quot;);
3686   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3687 
3688   // Set inner classes attribute to default sentinel
3689   _inner_classes = Universe::the_empty_short_array();
3690   // Set nest members attribute to default sentinel
3691   _nest_members = Universe::the_empty_short_array();
</pre>
<hr />
<pre>
4136       }
4137     }
4138     if (runtime_invisible_annotations != NULL) {
4139       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
4140         int append = runtime_visible_annotations_length+i;
4141         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
4142       }
4143     }
4144   }
4145   return annotations;
4146 }
4147 
4148 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
4149                                                         const int super_class_index,
4150                                                         const bool need_verify,
4151                                                         TRAPS) {
4152   assert(cp != NULL, &quot;invariant&quot;);
4153   const InstanceKlass* super_klass = NULL;
4154 
4155   if (super_class_index == 0) {
<span class="line-modified">4156     check_property(_class_name == vmSymbols::java_lang_Object()</span>
<span class="line-added">4157                    || (_access_flags.get_flags() &amp; JVM_ACC_INLINE),</span>
4158                    &quot;Invalid superclass index %u in class file %s&quot;,
4159                    super_class_index,
4160                    CHECK_NULL);
4161   } else {
4162     check_property(valid_klass_reference_at(super_class_index),
4163                    &quot;Invalid superclass index %u in class file %s&quot;,
4164                    super_class_index,
4165                    CHECK_NULL);
4166     // The class name should be legal because it is checked when parsing constant pool.
4167     // However, make sure it is not an array type.
4168     bool is_array = false;
4169     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4170       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4171       if (need_verify)
4172         is_array = super_klass-&gt;is_array_klass();
4173     } else if (need_verify) {
4174       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4175     }
4176     if (need_verify) {
4177       guarantee_property(!is_array,
</pre>
<hr />
<pre>
4280 }
4281 
4282 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4283   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4284   if (_nonstatic_oop_map_count &gt; 0) {
4285     OopMapBlock* map = _nonstatic_oop_maps;
4286     OopMapBlock* last_map = last_oop_map();
4287     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4288     while (map &lt;= last_map) {
4289       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4290                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4291       map++;
4292     }
4293   }
4294 }
4295 
4296 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4297   print_on(st);
4298 }
4299 
<span class="line-added">4300 void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-added">4301                                                 const char* msg,</span>
<span class="line-added">4302                                                 const Symbol* name,</span>
<span class="line-added">4303                                                 const Symbol* sig) const {</span>
<span class="line-added">4304 </span>
<span class="line-added">4305   ResourceMark rm(THREAD);</span>
<span class="line-added">4306   if (name == NULL || sig == NULL) {</span>
<span class="line-added">4307     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,</span>
<span class="line-added">4308         vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">4309         &quot;class: %s - %s&quot;, _class_name-&gt;as_C_string(), msg);</span>
<span class="line-added">4310   }</span>
<span class="line-added">4311   else {</span>
<span class="line-added">4312     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,</span>
<span class="line-added">4313         vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">4314         &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),</span>
<span class="line-added">4315         _class_name-&gt;as_C_string(), msg);</span>
<span class="line-added">4316   }</span>
<span class="line-added">4317 }</span>
<span class="line-added">4318 </span>
4319 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4320   assert(ik != NULL, &quot;invariant&quot;);
4321 
4322   const Klass* const super = ik-&gt;super();
4323 
4324   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4325   // in which case we don&#39;t have to register objects as finalizable
4326   if (!_has_empty_finalizer) {
4327     if (_has_finalizer ||
4328         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4329       ik-&gt;set_has_finalizer();
4330     }
4331   }
4332 
4333 #ifdef ASSERT
4334   bool f = false;
4335   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4336                                            vmSymbols::void_method_signature());
4337   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4338       f = true;
4339   }
4340 
4341   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4342   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4343   // will not work as expected we shouldn&#39;t abort vm in this case
4344   if (!ik-&gt;has_redefined_this_or_super()) {
4345     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4346   }
4347 #endif
4348 
4349   // Check if this klass supports the java.lang.Cloneable interface
4350   if (SystemDictionary::Cloneable_klass_loaded()) {
4351     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
<span class="line-added">4352       if (ik-&gt;is_inline_klass()) {</span>
<span class="line-added">4353         Thread *THREAD = Thread::current();</span>
<span class="line-added">4354         throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support Cloneable&quot;);</span>
<span class="line-added">4355         return;</span>
<span class="line-added">4356       }</span>
4357       ik-&gt;set_is_cloneable();
4358     }
4359   }
4360 
4361   // Check if this klass has a vanilla default constructor
4362   if (super == NULL) {
4363     // java.lang.Object has empty default constructor
4364     ik-&gt;set_has_vanilla_constructor();
4365   } else {
4366     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4367         _has_vanilla_constructor) {
4368       ik-&gt;set_has_vanilla_constructor();
4369     }
4370 #ifdef ASSERT
4371     bool v = false;
4372     if (super-&gt;has_vanilla_constructor()) {
4373       const Method* const constructor =
4374         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4375                        vmSymbols::void_method_signature());
4376       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4377         v = true;
4378       }
4379     }
4380     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4381 #endif
4382   }
4383 
4384   // If it cannot be fast-path allocated, set a bit in the layout helper.
4385   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4386   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4387   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4388       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4389       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4390       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4391     // Forbid fast-path allocation.
4392     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4393     ik-&gt;set_layout_helper(lh);
4394   }
4395 }
4396 
<span class="line-added">4397 bool ClassFileParser::supports_inline_types() const {</span>
<span class="line-added">4398   // Inline types are only supported by class file version 55 and later</span>
<span class="line-added">4399   return _major_version &gt;= JAVA_11_VERSION;</span>
<span class="line-added">4400 }</span>
<span class="line-added">4401 </span>
4402 // utility methods for appending an array with check for duplicates
4403 
4404 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4405                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4406   // iterate over new interfaces
4407   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4408     InstanceKlass* const e = ifs-&gt;at(i);
4409     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4410     // add new interface
4411     result-&gt;append_if_missing(e);
4412   }
4413 }
4414 
4415 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
4416                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
4417                                                             ClassLoaderData* loader_data,
4418                                                             TRAPS) {
4419   assert(local_ifs != NULL, &quot;invariant&quot;);
4420   assert(loader_data != NULL, &quot;invariant&quot;);
4421 
</pre>
<hr />
<pre>
4425   // Add superclass transitive interfaces size
4426   if (super != NULL) {
4427     super_size = super-&gt;transitive_interfaces()-&gt;length();
4428     max_transitive_size += super_size;
4429   }
4430   // Add local interfaces&#39; super interfaces
4431   const int local_size = local_ifs-&gt;length();
4432   for (int i = 0; i &lt; local_size; i++) {
4433     InstanceKlass* const l = local_ifs-&gt;at(i);
4434     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
4435   }
4436   // Finally add local interfaces
4437   max_transitive_size += local_size;
4438   // Construct array
4439   if (max_transitive_size == 0) {
4440     // no interfaces, use canonicalized array
4441     return Universe::the_empty_instance_klass_array();
4442   } else if (max_transitive_size == super_size) {
4443     // no new local interfaces added, share superklass&#39; transitive interface array
4444     return super-&gt;transitive_interfaces();
<span class="line-modified">4445     // The three lines below are commented to work around bug JDK-8245487</span>
<span class="line-modified">4446 //  } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">4447 //    // only local interfaces added, share local interface array</span>
<span class="line-added">4448 //    return local_ifs;</span>
4449   } else {
4450     ResourceMark rm;
4451     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
4452 
4453     // Copy down from superclass
4454     if (super != NULL) {
4455       append_interfaces(result, super-&gt;transitive_interfaces());
4456     }
4457 
4458     // Copy down from local interfaces&#39; superinterfaces
4459     for (int i = 0; i &lt; local_size; i++) {
4460       InstanceKlass* const l = local_ifs-&gt;at(i);
4461       append_interfaces(result, l-&gt;transitive_interfaces());
4462     }
4463     // Finally add local interfaces
4464     append_interfaces(result, local_ifs);
4465 
4466     // length will be less than the max_transitive_size if duplicates were removed
4467     const int length = result-&gt;length();
4468     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
<span class="line-added">4469 </span>
<span class="line-added">4470     if (length == 1 &amp;&amp; result-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">4471       return Universe::the_single_IdentityObject_klass_array();</span>
<span class="line-added">4472     }</span>
<span class="line-added">4473 </span>
4474     Array&lt;InstanceKlass*&gt;* const new_result =
4475       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4476     for (int i = 0; i &lt; length; i++) {
4477       InstanceKlass* const e = result-&gt;at(i);
4478       assert(e != NULL, &quot;just checking&quot;);
4479       new_result-&gt;at_put(i, e);
4480     }
4481     return new_result;
4482   }
4483 }
4484 
4485 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4486   assert(this_klass != NULL, &quot;invariant&quot;);
4487   const Klass* const super = this_klass-&gt;super();
4488 
4489   if (super != NULL) {
4490     const InstanceKlass* super_ik = InstanceKlass::cast(super);
4491 
4492     if (super-&gt;is_final()) {
4493       ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
4686     const Method* const m = methods-&gt;at(index);
4687     // if m is static and not the init method, throw a verify error
4688     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
4689       ResourceMark rm(THREAD);
4690       Exceptions::fthrow(
4691         THREAD_AND_LOCATION,
4692         vmSymbols::java_lang_VerifyError(),
4693         &quot;Illegal static method %s in interface %s&quot;,
4694         m-&gt;name()-&gt;as_C_string(),
4695         this_klass-&gt;external_name()
4696       );
4697       return;
4698     }
4699   }
4700 }
4701 
4702 // utility methods for format checking
4703 
4704 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
4705   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
<span class="line-added">4706   const bool is_inline_type = (flags &amp; JVM_ACC_INLINE) != 0;</span>
4707   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
<span class="line-added">4708   assert(supports_inline_types() || !is_inline_type, &quot;JVM_ACC_INLINE should not be set&quot;);</span>
4709   if (is_module) {
4710     ResourceMark rm(THREAD);
4711     Exceptions::fthrow(
4712       THREAD_AND_LOCATION,
4713       vmSymbols::java_lang_NoClassDefFoundError(),
4714       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
4715       _class_name-&gt;as_C_string());
4716     return;
4717   }
4718 
<span class="line-added">4719   if (is_inline_type &amp;&amp; !EnableValhalla) {</span>
<span class="line-added">4720     ResourceMark rm(THREAD);</span>
<span class="line-added">4721     Exceptions::fthrow(</span>
<span class="line-added">4722       THREAD_AND_LOCATION,</span>
<span class="line-added">4723       vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">4724       &quot;Class modifier ACC_INLINE in class %s requires option -XX:+EnableValhalla&quot;,</span>
<span class="line-added">4725       _class_name-&gt;as_C_string()</span>
<span class="line-added">4726     );</span>
<span class="line-added">4727   }</span>
<span class="line-added">4728 </span>
4729   if (!_need_verify) { return; }
4730 
4731   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
4732   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
4733   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
4734   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
4735   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
4736   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
4737   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4738   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
4739 
4740   if ((is_abstract &amp;&amp; is_final) ||
4741       (is_interface &amp;&amp; !is_abstract) ||
4742       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<span class="line-modified">4743       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation) ||</span>
<span class="line-added">4744       (is_inline_type &amp;&amp; (is_interface || is_abstract || is_enum || !is_final))) {</span>
4745     ResourceMark rm(THREAD);
<span class="line-added">4746     const char* class_note = &quot;&quot;;</span>
<span class="line-added">4747     if (is_inline_type)  class_note = &quot; (an inline class)&quot;;</span>
4748     Exceptions::fthrow(
4749       THREAD_AND_LOCATION,
4750       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">4751       &quot;Illegal class modifiers in class %s%s: 0x%X&quot;,</span>
<span class="line-modified">4752       _class_name-&gt;as_C_string(), class_note, flags</span>
4753     );
4754     return;
4755   }
4756 }
4757 
4758 static bool has_illegal_visibility(jint flags) {
4759   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4760   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4761   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4762 
4763   return ((is_public &amp;&amp; is_protected) ||
4764           (is_public &amp;&amp; is_private) ||
4765           (is_protected &amp;&amp; is_private));
4766 }
4767 
4768 // A legal major_version.minor_version must be one of the following:
4769 //
4770 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
4771 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
4772 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
</pre>
<hr />
<pre>
4811     if (!Arguments::enable_preview()) {
4812       Exceptions::fthrow(
4813         THREAD_AND_LOCATION,
4814         vmSymbols::java_lang_UnsupportedClassVersionError(),
4815         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
4816         class_name-&gt;as_C_string(), major, minor);
4817       return;
4818     }
4819 
4820   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
4821     Exceptions::fthrow(
4822         THREAD_AND_LOCATION,
4823         vmSymbols::java_lang_UnsupportedClassVersionError(),
4824         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
4825         class_name-&gt;as_C_string(), major, minor);
4826   }
4827 }
4828 
4829 void ClassFileParser::verify_legal_field_modifiers(jint flags,
4830                                                    bool is_interface,
<span class="line-added">4831                                                    bool is_inline_type,</span>
4832                                                    TRAPS) const {
4833   if (!_need_verify) { return; }
4834 
4835   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4836   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4837   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4838   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
4839   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
4840   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
4841   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
4842   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
4843   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4844 
4845   bool is_illegal = false;
4846 
4847   if (is_interface) {
4848     if (!is_public || !is_static || !is_final || is_private ||
4849         is_protected || is_volatile || is_transient ||
4850         (major_gte_1_5 &amp;&amp; is_enum)) {
4851       is_illegal = true;
4852     }
4853   } else { // not interface
4854     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
4855       is_illegal = true;
<span class="line-added">4856     } else {</span>
<span class="line-added">4857       if (is_inline_type &amp;&amp; !is_static &amp;&amp; !is_final) {</span>
<span class="line-added">4858         is_illegal = true;</span>
<span class="line-added">4859       }</span>
4860     }
4861   }
4862 
4863   if (is_illegal) {
4864     ResourceMark rm(THREAD);
4865     Exceptions::fthrow(
4866       THREAD_AND_LOCATION,
4867       vmSymbols::java_lang_ClassFormatError(),
4868       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
4869       _class_name-&gt;as_C_string(), flags);
4870     return;
4871   }
4872 }
4873 
4874 void ClassFileParser::verify_legal_method_modifiers(jint flags,
4875                                                     bool is_interface,
<span class="line-added">4876                                                     bool is_inline_type,</span>
4877                                                     const Symbol* name,
4878                                                     TRAPS) const {
4879   if (!_need_verify) { return; }
4880 
4881   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
4882   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
4883   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
4884   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
4885   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
4886   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
4887   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
4888   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
4889   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
4890   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
4891   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
4892   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
4893   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
4894 
4895   bool is_illegal = false;
4896 
<span class="line-added">4897   const char* class_note = &quot;&quot;;</span>
<span class="line-added">4898 </span>
4899   if (is_interface) {
4900     if (major_gte_8) {
4901       // Class file version is JAVA_8_VERSION or later Methods of
4902       // interfaces may set any of the flags except ACC_PROTECTED,
4903       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
4904       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
4905       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
4906           (is_native || is_protected || is_final || is_synchronized) ||
4907           // If a specific method of a class or interface has its
4908           // ACC_ABSTRACT flag set, it must not have any of its
4909           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
4910           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
4911           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
4912           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
4913           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
4914         is_illegal = true;
4915       }
4916     } else if (major_gte_1_5) {
4917       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
4918       if (!is_public || is_private || is_protected || is_static || is_final ||
4919           is_synchronized || is_native || !is_abstract || is_strict) {
4920         is_illegal = true;
4921       }
4922     } else {
4923       // Class file version is pre-JAVA_1_5_VERSION
4924       if (!is_public || is_static || is_final || is_native || !is_abstract) {
4925         is_illegal = true;
4926       }
4927     }
4928   } else { // not interface
4929     if (has_illegal_visibility(flags)) {
4930       is_illegal = true;
4931     } else {
4932       if (is_initializer) {
<span class="line-modified">4933         if (is_final || is_synchronized || is_native ||</span>
4934             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
4935           is_illegal = true;
4936         }
<span class="line-added">4937         if (!is_static &amp;&amp; !is_inline_type) {</span>
<span class="line-added">4938           // OK, an object constructor in a regular class</span>
<span class="line-added">4939         } else if (is_static &amp;&amp; is_inline_type) {</span>
<span class="line-added">4940           // OK, a static init factory in an inline class</span>
<span class="line-added">4941         } else {</span>
<span class="line-added">4942           // but no other combinations are allowed</span>
<span class="line-added">4943           is_illegal = true;</span>
<span class="line-added">4944           class_note = (is_inline_type ? &quot; (an inline class)&quot; : &quot; (not an inline class)&quot;);</span>
<span class="line-added">4945         }</span>
4946       } else { // not initializer
<span class="line-modified">4947         if (is_inline_type &amp;&amp; is_synchronized &amp;&amp; !is_static) {</span>
<span class="line-modified">4948           is_illegal = true;</span>
<span class="line-modified">4949           class_note = &quot; (an inline class)&quot;;</span>
<span class="line-modified">4950         } else {</span>
<span class="line-added">4951           if (is_abstract) {</span>
<span class="line-added">4952             if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-added">4953                 (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-added">4954               is_illegal = true;</span>
<span class="line-added">4955             }</span>
4956           }
4957         }
4958       }
4959     }
4960   }
4961 
4962   if (is_illegal) {
4963     ResourceMark rm(THREAD);
4964     Exceptions::fthrow(
4965       THREAD_AND_LOCATION,
4966       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">4967       &quot;Method %s in class %s%s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">4968       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, flags);</span>
4969     return;
4970   }
4971 }
4972 
4973 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
4974                                         int length,
4975                                         TRAPS) const {
4976   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
4977   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
4978     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
4979   }
4980 }
4981 
4982 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
4983 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
4984 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
4985 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
4986 // method.  Because these names have been checked as special cases before
4987 // calling this method in verify_legal_method_name.
4988 //
</pre>
<hr />
<pre>
5106 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5107 // Return a pointer to just past the signature.
5108 // Return NULL if no legal signature is found.
5109 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5110                                                        bool void_ok,
5111                                                        unsigned int length,
5112                                                        TRAPS) const {
5113   unsigned int array_dim = 0;
5114   while (length &gt; 0) {
5115     switch (signature[0]) {
5116     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5117     case JVM_SIGNATURE_BOOLEAN:
5118     case JVM_SIGNATURE_BYTE:
5119     case JVM_SIGNATURE_CHAR:
5120     case JVM_SIGNATURE_SHORT:
5121     case JVM_SIGNATURE_INT:
5122     case JVM_SIGNATURE_FLOAT:
5123     case JVM_SIGNATURE_LONG:
5124     case JVM_SIGNATURE_DOUBLE:
5125       return signature + 1;
<span class="line-modified">5126     case JVM_SIGNATURE_INLINE_TYPE:</span>
<span class="line-added">5127       // Can&#39;t enable this check until JDK upgrades the bytecode generators</span>
<span class="line-added">5128       // if (_major_version &lt; CONSTANT_CLASS_DESCRIPTORS ) {</span>
<span class="line-added">5129       //   classfile_parse_error(&quot;Class name contains illegal Q-signature &quot;</span>
<span class="line-added">5130       //                                    &quot;in descriptor in class file %s&quot;,</span>
<span class="line-added">5131       //                                    CHECK_0);</span>
<span class="line-added">5132       // }</span>
<span class="line-added">5133       // fall through</span>
<span class="line-added">5134     case JVM_SIGNATURE_CLASS:</span>
<span class="line-added">5135     {</span>
5136       if (_major_version &lt; JAVA_1_5_VERSION) {
5137         // Skip over the class name if one is there
5138         const char* const p = skip_over_field_name(signature + 1, true, --length);
5139 
5140         // The next character better be a semicolon
5141         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5142           return p + 1;
5143         }
5144       }
5145       else {
<span class="line-modified">5146         // Skip leading &#39;L&#39; or &#39;Q&#39; and ignore first appearance of &#39;;&#39;</span>
5147         signature++;
5148         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5149         // Format check signature
5150         if (c != NULL) {
5151           int newlen = c - (char*) signature;
5152           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5153           if (!legal) {
5154             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5155                                   &quot;in descriptor in class file %s&quot;,
5156                                   CHECK_NULL);
5157             return NULL;
5158           }
5159           return signature + newlen + 1;
5160         }
5161       }
5162       return NULL;
5163     }
5164     case JVM_SIGNATURE_ARRAY:
5165       array_dim++;
5166       if (array_dim &gt; 255) {
</pre>
<hr />
<pre>
5181 
5182 // Checks if name is a legal class name.
5183 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5184   if (!_need_verify || _relax_verify) { return; }
5185 
5186   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5187   char* bytes = (char*)name-&gt;bytes();
5188   unsigned int length = name-&gt;utf8_length();
5189   bool legal = false;
5190 
5191   if (length &gt; 0) {
5192     const char* p;
5193     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5194       p = skip_over_field_signature(bytes, false, length, CHECK);
5195       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5196     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5197       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5198         p = skip_over_field_name(bytes, true, length);
5199         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5200       }
<span class="line-added">5201     } else if (_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS &amp;&amp; bytes[length - 1] == &#39;;&#39; ) {</span>
<span class="line-added">5202       // Support for L...; and Q...; descriptors</span>
<span class="line-added">5203       legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);</span>
5204     } else {
5205       // 4900761: relax the constraints based on JSR202 spec
5206       // Class names may be drawn from the entire Unicode character set.
5207       // Identifiers between &#39;/&#39; must be unqualified names.
5208       // The utf8 string has been verified when parsing cpool entries.
5209       legal = verify_unqualified_name(bytes, length, LegalClass);
5210     }
5211   }
5212   if (!legal) {
5213     ResourceMark rm(THREAD);
5214     assert(_class_name != NULL, &quot;invariant&quot;);
5215     Exceptions::fthrow(
5216       THREAD_AND_LOCATION,
5217       vmSymbols::java_lang_ClassFormatError(),
5218       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5219       _class_name-&gt;as_C_string()
5220     );
5221     return;
5222   }
5223 }
</pre>
<hr />
<pre>
5333   const char* nextp;
5334 
5335   // The first character must be a &#39;(&#39;
5336   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5337     length--;
5338     // Skip over legal field signatures
5339     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5340     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5341       args_size++;
5342       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5343         args_size++;
5344       }
5345       length -= nextp - p;
5346       p = nextp;
5347       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5348     }
5349     // The first non-signature thing better be a &#39;)&#39;
5350     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5351       length--;
5352       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">5353         // All constructor methods must return void</span>
5354         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5355           return args_size;
5356         }
<span class="line-added">5357         // All static init methods must return the current class</span>
<span class="line-added">5358         if ((length &gt;= 3) &amp;&amp; (p[length-1] == JVM_SIGNATURE_ENDCLASS)</span>
<span class="line-added">5359             &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">5360           nextp = skip_over_field_signature(p, true, length, CHECK_0);</span>
<span class="line-added">5361           if (nextp &amp;&amp; ((int)length == (nextp - p))) {</span>
<span class="line-added">5362             // The actual class will be checked against current class</span>
<span class="line-added">5363             // when the method is defined (see parse_method).</span>
<span class="line-added">5364             // A reference to a static init with a bad return type</span>
<span class="line-added">5365             // will load and verify OK, but will fail to link.</span>
<span class="line-added">5366             return args_size;</span>
<span class="line-added">5367           }</span>
<span class="line-added">5368         }</span>
<span class="line-added">5369         // The distinction between static factory methods and</span>
<span class="line-added">5370         // constructors depends on the JVM_ACC_STATIC modifier.</span>
<span class="line-added">5371         // This distinction must be reflected in a void or non-void</span>
<span class="line-added">5372         // return. For declared methods, the check is in parse_method.</span>
5373       } else {
5374         // Now we better just have a return value
5375         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5376         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5377           return args_size;
5378         }
5379       }
5380     }
5381   }
5382   // Report error
5383   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5384   return 0;
5385 }
5386 
5387 int ClassFileParser::static_field_size() const {
5388   assert(_field_info != NULL, &quot;invariant&quot;);
5389   return _field_info-&gt;_static_field_size;
5390 }
5391 
5392 int ClassFileParser::total_oop_map_count() const {
</pre>
<hr />
<pre>
5510 
5511 
5512   if (ik-&gt;should_store_fingerprint()) {
5513     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
5514   }
5515 
5516   ik-&gt;set_has_passed_fingerprint_check(false);
5517   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
5518     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
5519     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
5520     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
5521       // This class matches with a class saved in an AOT library
5522       ik-&gt;set_has_passed_fingerprint_check(true);
5523     } else {
5524       ResourceMark rm;
5525       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
5526                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
5527     }
5528   }
5529 
<span class="line-added">5530   if (ik-&gt;is_inline_klass()) {</span>
<span class="line-added">5531     InlineKlass* vk = InlineKlass::cast(ik);</span>
<span class="line-added">5532     oop val = ik-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">5533     vk-&gt;set_default_value(val);</span>
<span class="line-added">5534   }</span>
<span class="line-added">5535 </span>
5536   return ik;
5537 }
5538 
<span class="line-added">5539 // Return true if the specified class is not a valid super class for an inline type.</span>
<span class="line-added">5540 // A valid super class for an inline type is abstract, has no instance fields,</span>
<span class="line-added">5541 // does not implement interface java.lang.IdentityObject (checked elsewhere), has</span>
<span class="line-added">5542 // an empty body-less no-arg constructor, and no synchronized instance methods.</span>
<span class="line-added">5543 // This function doesn&#39;t check if the class&#39;s super types are invalid.  Those checks</span>
<span class="line-added">5544 // are done elsewhere.  The final determination of whether or not a class is an</span>
<span class="line-added">5545 // invalid super type for an inline class is done in fill_instance_klass().</span>
<span class="line-added">5546 bool ClassFileParser::is_invalid_super_for_inline_type() {</span>
<span class="line-added">5547   if (class_name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">5548     return true;</span>
<span class="line-added">5549   }</span>
<span class="line-added">5550   if (is_interface() || class_name() == vmSymbols::java_lang_Object()) {</span>
<span class="line-added">5551     return false;</span>
<span class="line-added">5552   }</span>
<span class="line-added">5553   if (!access_flags().is_abstract() || _has_nonstatic_fields) {</span>
<span class="line-added">5554     return true;</span>
<span class="line-added">5555   } else {</span>
<span class="line-added">5556     // Look at each method</span>
<span class="line-added">5557     for (int x = 0; x &lt; _methods-&gt;length(); x++) {</span>
<span class="line-added">5558       const Method* const method = _methods-&gt;at(x);</span>
<span class="line-added">5559       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {</span>
<span class="line-added">5560         return true;</span>
<span class="line-added">5561 </span>
<span class="line-added">5562       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">5563         if (method-&gt;signature() != vmSymbols::void_method_signature() ||</span>
<span class="line-added">5564             !method-&gt;is_vanilla_constructor()) {</span>
<span class="line-added">5565           return true;</span>
<span class="line-added">5566         }</span>
<span class="line-added">5567       }</span>
<span class="line-added">5568     }</span>
<span class="line-added">5569   }</span>
<span class="line-added">5570   return false;</span>
<span class="line-added">5571 }</span>
<span class="line-added">5572 </span>
5573 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
5574                                           bool changed_by_loadhook,
5575                                           const ClassInstanceInfo&amp; cl_inst_info,
5576                                           TRAPS) {
5577   assert(ik != NULL, &quot;invariant&quot;);
5578 
5579   // Set name and CLD before adding to CLD
5580   ik-&gt;set_class_loader_data(_loader_data);
5581   ik-&gt;set_name(_class_name);
5582 
5583   // Add all classes to our internal class loader list here,
5584   // including classes in the bootstrap (NULL) class loader.
5585   const bool publicize = !is_internal();
5586 
5587   _loader_data-&gt;add_class(ik, publicize);
5588 
5589   set_klass_to_deallocate(ik);
5590 
5591   assert(_field_info != NULL, &quot;invariant&quot;);
5592   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
5593   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
5594          &quot;sanity&quot;);
5595 
5596   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
5597   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
5598 
5599   // Fill in information already parsed
5600   ik-&gt;set_should_verify_class(_need_verify);
5601 
5602   // Not yet: supers are done below to support the new subtype-checking fields
5603   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
5604   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
<span class="line-added">5605   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_inline_klass()) {</span>
<span class="line-added">5606     ik-&gt;set_is_naturally_atomic();</span>
<span class="line-added">5607   }</span>
<span class="line-added">5608   if (_is_empty_inline_type) {</span>
<span class="line-added">5609     ik-&gt;set_is_empty_inline_type();</span>
<span class="line-added">5610   }</span>
<span class="line-added">5611 </span>
<span class="line-added">5612   if (this-&gt;_invalid_inline_super) {</span>
<span class="line-added">5613     ik-&gt;set_invalid_inline_super();</span>
<span class="line-added">5614   }</span>
<span class="line-added">5615 </span>
<span class="line-added">5616   if (_has_injected_identityObject) {</span>
<span class="line-added">5617     ik-&gt;set_has_injected_identityObject();</span>
<span class="line-added">5618   }</span>
<span class="line-added">5619 </span>
5620   assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">5621   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_INLINE]);</span>
5622 
5623   // this transfers ownership of a lot of arrays from
5624   // the parser onto the InstanceKlass*
5625   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5626 
5627   // can only set dynamic nest-host after static nest information is set
5628   if (cl_inst_info.dynamic_nest_host() != NULL) {
5629     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
5630   }
5631 
5632   // note that is not safe to use the fields in the parser from this point on
5633   assert(NULL == _cp, &quot;invariant&quot;);
5634   assert(NULL == _fields, &quot;invariant&quot;);
5635   assert(NULL == _methods, &quot;invariant&quot;);
5636   assert(NULL == _inner_classes, &quot;invariant&quot;);
5637   assert(NULL == _nest_members, &quot;invariant&quot;);
5638   assert(NULL == _combined_annotations, &quot;invariant&quot;);
5639   assert(NULL == _record_components, &quot;invariant&quot;);
5640   assert(NULL == _permitted_subclasses, &quot;invariant&quot;);
5641 
</pre>
<hr />
<pre>
5651   // has to be changed accordingly.
5652   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5653 
5654   ik-&gt;set_this_class_index(_this_class_index);
5655 
5656   if (_is_hidden || is_unsafe_anonymous()) {
5657     // _this_class_index is a CONSTANT_Class entry that refers to this
5658     // hidden or anonymous class itself. If this class needs to refer to its own
5659     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
5660     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
5661     // not stored in SystemDictionary), _this_class_index cannot be resolved
5662     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
5663     // Therefore, we must eagerly resolve _this_class_index now.
5664     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
5665   }
5666 
5667   ik-&gt;set_minor_version(_minor_version);
5668   ik-&gt;set_major_version(_major_version);
5669   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
5670   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
<span class="line-added">5671   if (_is_declared_atomic) {</span>
<span class="line-added">5672     ik-&gt;set_is_declared_atomic();</span>
<span class="line-added">5673   }</span>
5674 
5675   if (_unsafe_anonymous_host != NULL) {
5676     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
5677     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
5678   }
5679   if (_is_hidden) {
5680     ik-&gt;set_is_hidden();
5681   }
5682 
5683   // Set PackageEntry for this_klass
5684   oop cl = ik-&gt;class_loader();
5685   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
5686   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
5687   ik-&gt;set_package(cld, NULL, CHECK);
5688 
5689   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
5690   assert(methods != NULL, &quot;invariant&quot;);
5691   const int methods_len = methods-&gt;length();
5692 
5693   check_methods_for_intrinsics(ik, methods);
</pre>
<hr />
<pre>
5765 
5766   assert(_all_mirandas != NULL, &quot;invariant&quot;);
5767 
5768   // Generate any default methods - default methods are public interface methods
5769   // that have a default implementation.  This is new with Java 8.
5770   if (_has_nonstatic_concrete_methods) {
5771     DefaultMethods::generate_default_methods(ik,
5772                                              _all_mirandas,
5773                                              CHECK);
5774   }
5775 
5776   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
5777   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
5778       !module_entry-&gt;has_default_read_edges()) {
5779     if (!module_entry-&gt;set_has_default_read_edges()) {
5780       // We won a potential race
5781       JvmtiExport::add_default_read_edges(module_handle, THREAD);
5782     }
5783   }
5784 
<span class="line-added">5785   int nfields = ik-&gt;java_fields_count();</span>
<span class="line-added">5786   if (ik-&gt;is_inline_klass()) nfields++;</span>
<span class="line-added">5787   for (int i = 0; i &lt; nfields; i++) {</span>
<span class="line-added">5788     if (ik-&gt;field_is_inline_type(i) &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) == 0)) {</span>
<span class="line-added">5789       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);</span>
<span class="line-added">5790       // Inline classes for instance fields must have been pre-loaded</span>
<span class="line-added">5791       // Inline classes for static fields might not have been loaded yet</span>
<span class="line-added">5792       Klass* klass = SystemDictionary::find(klass_name,</span>
<span class="line-added">5793           Handle(THREAD, ik-&gt;class_loader()),</span>
<span class="line-added">5794           Handle(THREAD, ik-&gt;protection_domain()), CHECK);</span>
<span class="line-added">5795       if (klass != NULL) {</span>
<span class="line-added">5796         assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
<span class="line-added">5797         ik-&gt;set_inline_type_field_klass(i, klass);</span>
<span class="line-added">5798       }</span>
<span class="line-added">5799       klass_name-&gt;decrement_refcount();</span>
<span class="line-added">5800     } else</span>
<span class="line-added">5801       if (is_inline_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)</span>
<span class="line-added">5802         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {</span>
<span class="line-added">5803       InlineKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));</span>
<span class="line-added">5804     }</span>
<span class="line-added">5805   }</span>
<span class="line-added">5806 </span>
<span class="line-added">5807   if (is_inline_type()) {</span>
<span class="line-added">5808     InlineKlass* vk = InlineKlass::cast(ik);</span>
<span class="line-added">5809     vk-&gt;set_alignment(_alignment);</span>
<span class="line-added">5810     vk-&gt;set_first_field_offset(_first_field_offset);</span>
<span class="line-added">5811     vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);</span>
<span class="line-added">5812     InlineKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);</span>
<span class="line-added">5813   }</span>
<span class="line-added">5814 </span>
5815   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
5816 
5817   if (!is_internal()) {
5818     if (log_is_enabled(Info, class, load)) {
5819       ResourceMark rm;
5820       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
5821       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
5822     }
5823 
5824     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
5825         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
5826         log_is_enabled(Info, class, preview)) {
5827       ResourceMark rm;
5828       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
5829                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
5830     }
5831 
5832     if (log_is_enabled(Debug, class, resolve))  {
5833       ResourceMark rm;
5834       // print out the superclass.
</pre>
<hr />
<pre>
5844         const int length = local_interfaces-&gt;length();
5845         for (int i = 0; i &lt; length; i++) {
5846           const InstanceKlass* const k = local_interfaces-&gt;at(i);
5847           const char * to = k-&gt;external_name();
5848           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
5849         }
5850       }
5851     }
5852   }
5853 
5854   JFR_ONLY(INIT_ID(ik);)
5855 
5856   // If we reach here, all is well.
5857   // Now remove the InstanceKlass* from the _klass_to_deallocate field
5858   // in order for it to not be destroyed in the ClassFileParser destructor.
5859   set_klass_to_deallocate(NULL);
5860 
5861   // it&#39;s official
5862   set_klass(ik);
5863 
<span class="line-added">5864   if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">5865     Universe::initialize_the_single_IdentityObject_klass_array(ik, CHECK);</span>
<span class="line-added">5866   }</span>
<span class="line-added">5867 </span>
5868   debug_only(ik-&gt;verify();)
5869 }
5870 
5871 void ClassFileParser::update_class_name(Symbol* new_class_name) {
5872   // Decrement the refcount in the old name, since we&#39;re clobbering it.
5873   _class_name-&gt;decrement_refcount();
5874 
5875   _class_name = new_class_name;
5876   // Increment the refcount of the new name.
5877   // Now the ClassFileParser owns this name and will decrement in
5878   // the destructor.
5879   _class_name-&gt;increment_refcount();
5880 }
5881 
5882 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
5883 // package by prepending its host class&#39;s package name to its class name and setting
5884 // its _class_name field.
5885 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
5886   ResourceMark rm(THREAD);
5887   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
</pre>
<hr />
<pre>
5950   _stream(stream),
5951   _class_name(NULL),
5952   _loader_data(loader_data),
5953   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
5954   _cp_patches(cl_info-&gt;cp_patches()),
5955   _is_hidden(cl_info-&gt;is_hidden()),
5956   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
5957   _num_patched_klasses(0),
5958   _max_num_patched_klasses(0),
5959   _orig_cp_size(0),
5960   _first_patched_klass_resolved_index(0),
5961   _super_klass(),
5962   _cp(NULL),
5963   _fields(NULL),
5964   _methods(NULL),
5965   _inner_classes(NULL),
5966   _nest_members(NULL),
5967   _nest_host(0),
5968   _permitted_subclasses(NULL),
5969   _record_components(NULL),
<span class="line-added">5970   _temp_local_interfaces(NULL),</span>
5971   _local_interfaces(NULL),
5972   _transitive_interfaces(NULL),
5973   _combined_annotations(NULL),
5974   _class_annotations(NULL),
5975   _class_type_annotations(NULL),
5976   _fields_annotations(NULL),
5977   _fields_type_annotations(NULL),
5978   _klass(NULL),
5979   _klass_to_deallocate(NULL),
5980   _parsed_annotations(NULL),
5981   _fac(NULL),
5982   _field_info(NULL),
5983   _method_ordering(NULL),
5984   _all_mirandas(NULL),
5985   _vtable_size(0),
5986   _itable_size(0),
5987   _num_miranda_methods(0),
5988   _rt(REF_NONE),
5989   _protection_domain(cl_info-&gt;protection_domain()),
5990   _access_flags(),
5991   _pub_level(pub_level),
5992   _bad_constant_seen(0),
5993   _synthetic_flag(false),
5994   _sde_length(false),
5995   _sde_buffer(NULL),
5996   _sourcefile_index(0),
5997   _generic_signature_index(0),
5998   _major_version(0),
5999   _minor_version(0),
6000   _this_class_index(0),
6001   _super_class_index(0),
6002   _itfs_len(0),
6003   _java_fields_count(0),
6004   _need_verify(false),
6005   _relax_verify(false),
6006   _has_nonstatic_concrete_methods(false),
6007   _declares_nonstatic_concrete_methods(false),
6008   _has_final_method(false),
6009   _has_contended_fields(false),
<span class="line-added">6010   _has_inline_type_fields(false),</span>
<span class="line-added">6011   _has_nonstatic_fields(false),</span>
<span class="line-added">6012   _is_empty_inline_type(false),</span>
<span class="line-added">6013   _is_naturally_atomic(false),</span>
<span class="line-added">6014   _is_declared_atomic(false),</span>
<span class="line-added">6015   _invalid_inline_super(false),</span>
<span class="line-added">6016   _invalid_identity_super(false),</span>
<span class="line-added">6017   _implements_identityObject(false),</span>
<span class="line-added">6018   _has_injected_identityObject(false),</span>
6019   _has_finalizer(false),
6020   _has_empty_finalizer(false),
6021   _has_vanilla_constructor(false),
6022   _max_bootstrap_specifier_index(-1) {
6023 
6024   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6025   _class_name-&gt;increment_refcount();
6026 
6027   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6028   assert(_loader_data != NULL, &quot;invariant&quot;);
6029   assert(stream != NULL, &quot;invariant&quot;);
6030   assert(_stream != NULL, &quot;invariant&quot;);
6031   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6032   assert(_class_name != NULL, &quot;invariant&quot;);
6033   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6034 
6035   // Figure out whether we can skip format checking (matching classic VM behavior)
6036   if (DumpSharedSpaces) {
6037     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6038     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6209   } else {
6210     if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6211       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6212     }
6213     cp_size += _max_num_patched_klasses;
6214   }
6215 
6216   _cp = ConstantPool::allocate(_loader_data,
6217                                cp_size,
6218                                CHECK);
6219 
6220   ConstantPool* const cp = _cp;
6221 
6222   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6223 
6224   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6225 
6226   // ACCESS FLAGS
6227   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6228 
<span class="line-modified">6229   jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;</span>

6230   // JVM_ACC_MODULE is defined in JDK-9 and later.
6231   if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">6232     recognized_modifiers |= JVM_ACC_MODULE;</span>
<span class="line-modified">6233   }</span>
<span class="line-modified">6234   // JVM_ACC_INLINE is defined for class file version 55 and later</span>
<span class="line-added">6235   if (supports_inline_types()) {</span>
<span class="line-added">6236     recognized_modifiers |= JVM_ACC_INLINE;</span>
6237   }
6238 
<span class="line-added">6239   // Access flags</span>
<span class="line-added">6240   jint flags = stream-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">6241 </span>
6242   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6243     // Set abstract bit for old class files for backward compatibility
6244     flags |= JVM_ACC_ABSTRACT;
6245   }
6246 
6247   verify_legal_class_modifiers(flags, CHECK);
6248 
6249   short bad_constant = class_bad_constant_seen();
6250   if (bad_constant != 0) {
6251     // Do not throw CFE until after the access_flags are checked because if
6252     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6253     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6254   }
6255 
6256   _access_flags.set_flags(flags);
6257 
6258   // This class and superclass
6259   _this_class_index = stream-&gt;get_u2_fast();
6260   check_property(
6261     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
</pre>
<hr />
<pre>
6379           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6380           classlist_file-&gt;flush();
6381         }
6382       }
6383     }
6384 #endif
6385   }
6386 
6387   // SUPERKLASS
6388   _super_class_index = stream-&gt;get_u2_fast();
6389   _super_klass = parse_super_class(cp,
6390                                    _super_class_index,
6391                                    _need_verify,
6392                                    CHECK);
6393 
6394   // Interfaces
6395   _itfs_len = stream-&gt;get_u2_fast();
6396   parse_interfaces(stream,
6397                    _itfs_len,
6398                    cp,
<span class="line-added">6399                    is_inline_type(),</span>
6400                    &amp;_has_nonstatic_concrete_methods,
<span class="line-added">6401                    &amp;_is_declared_atomic,</span>
6402                    CHECK);
6403 
<span class="line-modified">6404   assert(_temp_local_interfaces != NULL, &quot;invariant&quot;);</span>
6405 
6406   // Fields (offsets are filled in later)
6407   _fac = new FieldAllocationCount();
6408   parse_fields(stream,
<span class="line-modified">6409                is_interface(),</span>
<span class="line-added">6410                is_inline_type(),</span>
6411                _fac,
6412                cp,
6413                cp_size,
6414                &amp;_java_fields_count,
6415                CHECK);
6416 
6417   assert(_fields != NULL, &quot;invariant&quot;);
6418 
6419   // Methods
6420   AccessFlags promoted_flags;
6421   parse_methods(stream,
<span class="line-modified">6422                 is_interface(),</span>
<span class="line-added">6423                 is_inline_type(),</span>
6424                 &amp;promoted_flags,
6425                 &amp;_has_final_method,
6426                 &amp;_declares_nonstatic_concrete_methods,
6427                 CHECK);
6428 
6429   assert(_methods != NULL, &quot;invariant&quot;);
6430 
6431   // promote flags from parse_methods() to the klass&#39; flags
6432   _access_flags.add_promoted_flags(promoted_flags.as_int());
6433 
6434   if (_declares_nonstatic_concrete_methods) {
6435     _has_nonstatic_concrete_methods = true;
6436   }
6437 
6438   // Additional attributes/annotations
6439   _parsed_annotations = new ClassAnnotationCollector();
6440   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6441 
6442   assert(_inner_classes != NULL, &quot;invariant&quot;);
6443 
</pre>
<hr />
<pre>
6474 
6475   // Update this_class_index&#39;s slot in the constant pool with the new Utf8 entry.
6476   // We have to update the resolved_klass_index and the name_index together
6477   // so extract the existing resolved_klass_index first.
6478   CPKlassSlot cp_klass_slot = _cp-&gt;klass_slot_at(_this_class_index);
6479   int resolved_klass_index = cp_klass_slot.resolved_klass_index();
6480   _cp-&gt;unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);
6481   assert(_cp-&gt;klass_slot_at(_this_class_index).name_index() == _orig_cp_size,
6482          &quot;Bad name_index&quot;);
6483 }
6484 
6485 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6486                                                  ConstantPool* cp,
6487                                                  TRAPS) {
6488   assert(stream != NULL, &quot;invariant&quot;);
6489   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6490   assert(cp != NULL, &quot;invariant&quot;);
6491   assert(_loader_data != NULL, &quot;invariant&quot;);
6492 
6493   if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">6494     check_property(_temp_local_interfaces-&gt;length() == 0,</span>
<span class="line-modified">6495         &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">6496         CHECK);</span>
6497   }
6498   // We check super class after class file is parsed and format is checked
6499   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6500     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">6501     if (is_interface()) {</span>
6502       // Before attempting to resolve the superclass, check for class format
6503       // errors not checked yet.
6504       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6505         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6506         CHECK);
6507     }
6508     Handle loader(THREAD, _loader_data-&gt;class_loader());
6509     _super_klass = (const InstanceKlass*)
6510                        SystemDictionary::resolve_super_or_fail(_class_name,
6511                                                                super_class_name,
6512                                                                loader,
6513                                                                _protection_domain,
6514                                                                true,
6515                                                                CHECK);
6516   }
6517 
6518   if (_super_klass != NULL) {
6519     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6520       _has_nonstatic_concrete_methods = true;
6521     }
<span class="line-added">6522     if (_super_klass-&gt;is_declared_atomic()) {</span>
<span class="line-added">6523       _is_declared_atomic = true;</span>
<span class="line-added">6524     }</span>
6525 
6526     if (_super_klass-&gt;is_interface()) {
6527       ResourceMark rm(THREAD);
6528       Exceptions::fthrow(
6529         THREAD_AND_LOCATION,
6530         vmSymbols::java_lang_IncompatibleClassChangeError(),
6531         &quot;class %s has interface %s as super class&quot;,
6532         _class_name-&gt;as_klass_external_name(),
6533         _super_klass-&gt;external_name()
6534       );
6535       return;
6536     }
<span class="line-added">6537 </span>
<span class="line-added">6538     // For an inline class, only java/lang/Object or special abstract classes</span>
<span class="line-added">6539     // are acceptable super classes.</span>
<span class="line-added">6540     if (is_inline_type()) {</span>
<span class="line-added">6541       const InstanceKlass* super_ik = _super_klass;</span>
<span class="line-added">6542       if (super_ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">6543         ResourceMark rm(THREAD);</span>
<span class="line-added">6544         Exceptions::fthrow(</span>
<span class="line-added">6545           THREAD_AND_LOCATION,</span>
<span class="line-added">6546           vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">6547           &quot;inline class %s has an invalid super class %s&quot;,</span>
<span class="line-added">6548           _class_name-&gt;as_klass_external_name(),</span>
<span class="line-added">6549           _super_klass-&gt;external_name());</span>
<span class="line-added">6550         return;</span>
<span class="line-added">6551       }</span>
<span class="line-added">6552     }</span>
<span class="line-added">6553   }</span>
<span class="line-added">6554 </span>
<span class="line-added">6555   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {</span>
<span class="line-added">6556     // This is the original source of this condition.</span>
<span class="line-added">6557     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.</span>
<span class="line-added">6558     _is_declared_atomic = true;</span>
<span class="line-added">6559   } else if (*ForceNonTearable != &#39;\0&#39;) {</span>
<span class="line-added">6560     // Allow a command line switch to force the same atomicity property:</span>
<span class="line-added">6561     const char* class_name_str = _class_name-&gt;as_C_string();</span>
<span class="line-added">6562     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {</span>
<span class="line-added">6563       _is_declared_atomic = true;</span>
<span class="line-added">6564     }</span>
6565   }
6566 
<span class="line-added">6567   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,</span>
<span class="line-added">6568   // if super is marked invalid, or if is_invalid_super_for_inline_type()</span>
<span class="line-added">6569   // returns true</span>
<span class="line-added">6570   if (invalid_inline_super() ||</span>
<span class="line-added">6571       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||</span>
<span class="line-added">6572       is_invalid_super_for_inline_type()) {</span>
<span class="line-added">6573     set_invalid_inline_super();</span>
<span class="line-added">6574   }</span>
<span class="line-added">6575 </span>
<span class="line-added">6576   if (!is_inline_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())</span>
<span class="line-added">6577       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">6578     _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());</span>
<span class="line-added">6579     _has_injected_identityObject = true;</span>
<span class="line-added">6580   }</span>
<span class="line-added">6581   int itfs_len = _temp_local_interfaces-&gt;length();</span>
<span class="line-added">6582   if (itfs_len == 0) {</span>
<span class="line-added">6583     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
<span class="line-added">6584   } else if (itfs_len == 1 &amp;&amp; _temp_local_interfaces-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">6585     _local_interfaces = Universe::the_single_IdentityObject_klass_array();</span>
<span class="line-added">6586   } else {</span>
<span class="line-added">6587     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-added">6588     for (int i = 0; i &lt; itfs_len; i++) {</span>
<span class="line-added">6589       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));</span>
<span class="line-added">6590     }</span>
<span class="line-added">6591   }</span>
<span class="line-added">6592   _temp_local_interfaces = NULL;</span>
<span class="line-added">6593   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
<span class="line-added">6594 </span>
6595   // Compute the transitive list of all unique interfaces implemented by this class
6596   _transitive_interfaces =
6597     compute_transitive_interfaces(_super_klass,
6598                                   _local_interfaces,
6599                                   _loader_data,
6600                                   CHECK);
6601 
6602   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6603 
6604   // sort methods
6605   _method_ordering = sort_methods(_methods);
6606 
6607   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6608 
6609   Handle loader(THREAD, _loader_data-&gt;class_loader());
6610   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6611                                                     &amp;_num_miranda_methods,
6612                                                     _all_mirandas,
6613                                                     _super_klass,
6614                                                     _methods,
6615                                                     _access_flags,
6616                                                     _major_version,
6617                                                     loader,
6618                                                     _class_name,
6619                                                     _local_interfaces,
6620                                                     CHECK);
6621 
6622   // Size of Java itable (in words)
<span class="line-modified">6623   _itable_size = is_interface() ? 0 :</span>
6624     klassItable::compute_itable_size(_transitive_interfaces);
6625 
6626   assert(_fac != NULL, &quot;invariant&quot;);
6627   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6628 
<span class="line-added">6629 </span>
<span class="line-added">6630   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="line-added">6631     if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE  &amp;&amp; !fs.access_flags().is_static()) {</span>
<span class="line-added">6632       // Pre-load inline class</span>
<span class="line-added">6633       Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,</span>
<span class="line-added">6634           Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="line-added">6635           _protection_domain, true, CHECK);</span>
<span class="line-added">6636       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">6637       assert(klass-&gt;access_flags().is_inline_type(), &quot;Value type expected&quot;);</span>
<span class="line-added">6638     }</span>
<span class="line-added">6639   }</span>
<span class="line-added">6640 </span>
6641   _field_info = new FieldLayoutInfo();
6642   FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">6643       _parsed_annotations-&gt;is_contended(), is_inline_type(),</span>
<span class="line-modified">6644       loader_data(), _protection_domain, _field_info);</span>
<span class="line-added">6645   lb.build_layout(CHECK);</span>
<span class="line-added">6646   if (is_inline_type()) {</span>
<span class="line-added">6647     _alignment = lb.get_alignment();</span>
<span class="line-added">6648     _first_field_offset = lb.get_first_field_offset();</span>
<span class="line-added">6649     _exact_size_in_bytes = lb.get_exact_size_in_byte();</span>
<span class="line-added">6650   }</span>
<span class="line-added">6651   _has_inline_type_fields = _field_info-&gt;_has_inline_fields;</span>
6652 
<span class="line-modified">6653   // Compute reference type</span>
6654   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();

6655 }
6656 
6657 void ClassFileParser::set_klass(InstanceKlass* klass) {
6658 
6659 #ifdef ASSERT
6660   if (klass != NULL) {
6661     assert(NULL == _klass, &quot;leaking?&quot;);
6662   }
6663 #endif
6664 
6665   _klass = klass;
6666 }
6667 
6668 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6669 
6670 #ifdef ASSERT
6671   if (klass != NULL) {
6672     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
6673   }
6674 #endif
6675 
6676   _klass_to_deallocate = klass;
6677 }
6678 
6679 // Caller responsible for ResourceMark
6680 // clone stream with rewound position
6681 const ClassFileStream* ClassFileParser::clone_stream() const {
6682   assert(_stream != NULL, &quot;invariant&quot;);
6683 
6684   return _stream-&gt;clone();
6685 }
<span class="line-added">6686 </span>
6687 // ----------------------------------------------------------------------------
6688 // debugging
6689 
6690 #ifdef ASSERT
6691 
6692 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
6693 bool ClassFileParser::is_internal_format(Symbol* class_name) {
6694   if (class_name != NULL) {
6695     ResourceMark rm;
6696     char* name = class_name-&gt;as_C_string();
6697     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
6698   } else {
6699     return true;
6700   }
6701 }
6702 
6703 #endif
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/aarch64/templateTable_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>