<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.constant.ClassDesc;
  30 import java.lang.invoke.TypeDescriptor;
  31 import java.lang.invoke.MethodHandles;
  32 import java.lang.module.ModuleReader;
  33 import java.lang.ref.SoftReference;
  34 import java.io.IOException;
  35 import java.io.InputStream;
  36 import java.io.ObjectStreamField;
  37 import java.lang.reflect.AnnotatedElement;
  38 import java.lang.reflect.AnnotatedType;
  39 import java.lang.reflect.Array;
  40 import java.lang.reflect.Constructor;
  41 import java.lang.reflect.Executable;
  42 import java.lang.reflect.Field;
  43 import java.lang.reflect.GenericArrayType;
  44 import java.lang.reflect.GenericDeclaration;
  45 import java.lang.reflect.InvocationTargetException;
  46 import java.lang.reflect.Member;
  47 import java.lang.reflect.Method;
  48 import java.lang.reflect.Modifier;
  49 import java.lang.reflect.Proxy;
  50 import java.lang.reflect.RecordComponent;
  51 import java.lang.reflect.Type;
  52 import java.lang.reflect.TypeVariable;
  53 import java.lang.constant.Constable;
  54 import java.net.URL;
  55 import java.security.AccessController;
  56 import java.security.PrivilegedAction;
  57 import java.util.ArrayList;
  58 import java.util.Arrays;
  59 import java.util.Collection;
  60 import java.util.HashMap;
  61 import java.util.LinkedHashMap;
  62 import java.util.LinkedHashSet;
  63 import java.util.List;
  64 import java.util.Map;
  65 import java.util.Objects;
  66 import java.util.Optional;
  67 import java.util.stream.Collectors;
  68 
  69 import jdk.internal.HotSpotIntrinsicCandidate;
  70 import jdk.internal.loader.BootLoader;
  71 import jdk.internal.loader.BuiltinClassLoader;
  72 import jdk.internal.misc.Unsafe;
  73 import jdk.internal.module.Resources;
  74 import jdk.internal.reflect.CallerSensitive;
  75 import jdk.internal.reflect.ConstantPool;
  76 import jdk.internal.reflect.Reflection;
  77 import jdk.internal.reflect.ReflectionFactory;
  78 import jdk.internal.vm.annotation.ForceInline;
  79 import sun.invoke.util.Wrapper;
  80 import sun.reflect.generics.factory.CoreReflectionFactory;
  81 import sun.reflect.generics.factory.GenericsFactory;
  82 import sun.reflect.generics.repository.ClassRepository;
  83 import sun.reflect.generics.repository.MethodRepository;
  84 import sun.reflect.generics.repository.ConstructorRepository;
  85 import sun.reflect.generics.scope.ClassScope;
  86 import sun.security.util.SecurityConstants;
  87 import sun.reflect.annotation.*;
  88 import sun.reflect.misc.ReflectUtil;
  89 
  90 /**
  91  * Instances of the class {@code Class} represent classes and
  92  * interfaces in a running Java application. An enum type and a record
  93  * type are kinds of class; an annotation type is a kind of
  94  * interface. Every array also belongs to a class that is reflected as
  95  * a {@code Class} object that is shared by all arrays with the same
  96  * element type and number of dimensions.  The primitive Java types
  97  * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
  98  * int}, {@code long}, {@code float}, and {@code double}), and the
  99  * keyword {@code void} are also represented as {@code Class} objects.
 100  *
 101  * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
 102  * object is constructed automatically by the Java Virtual Machine when
 103  * a class is derived from the bytes of a {@code class} file through
 104  * the invocation of one of the following methods:
 105  * &lt;ul&gt;
 106  * &lt;li&gt; {@link ClassLoader#defineClass(String, byte[], int, int) ClassLoader::defineClass}
 107  * &lt;li&gt; {@link java.lang.invoke.MethodHandles.Lookup#defineClass(byte[])
 108  *      java.lang.invoke.MethodHandles.Lookup::defineClass}
 109  * &lt;li&gt; {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 110  *      java.lang.invoke.MethodHandles.Lookup::defineHiddenClass}
 111  * &lt;/ul&gt;
 112  *
 113  * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
 114  * class or interface. Most characteristics are derived from the {@code class}
 115  * file that the class loader passed to the Java Virtual Machine or
 116  * from the {@code class} file passed to {@code Lookup::defineClass}
 117  * or {@code Lookup::defineHiddenClass}.
 118  * A few characteristics are determined by the class loading environment
 119  * at run time, such as the module returned by {@link #getModule() getModule()}.
 120  *
 121  * &lt;p&gt; The following example uses a {@code Class} object to print the
 122  * class name of an object:
 123  *
 124  * &lt;blockquote&gt;&lt;pre&gt;
 125  *     void printClassName(Object obj) {
 126  *         System.out.println(&quot;The class of &quot; + obj +
 127  *                            &quot; is &quot; + obj.getClass().getName());
 128  *     }
 129  * &lt;/pre&gt;&lt;/blockquote&gt;
 130  *
 131  * It is also possible to get the {@code Class} object for a named
 132  * type (or for {@code void}) using a &lt;i&gt;class literal&lt;/i&gt;.
 133  * For example:
 134  *
 135  * &lt;blockquote&gt;
 136  *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}
 137  * &lt;/blockquote&gt;
 138  *
 139  * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
 140  * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
 141  * another declaration. Other methods describe how a class or interface
 142  * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
 143  * classes and interfaces, in the same run-time package, that
 144  * allow mutual access to their {@code private} members.
 145  * The classes and interfaces are known as &lt;em&gt;nestmates&lt;/em&gt;.
 146  * One nestmate acts as the
 147  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 148  * belong to the nest; each of them in turn records it as the nest host.
 149  * The classes and interfaces which belong to a nest, including its host, are
 150  * determined when
 151  * {@code class} files are generated, for example, a Java compiler
 152  * will typically record a top-level class as the host of a nest where the
 153  * other members are the classes and interfaces whose declarations are
 154  * enclosed within the top-level class declaration.
 155  *
 156  * &lt;p&gt; A class or interface created by the invocation of
 157  * {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 158  * Lookup::defineHiddenClass} is a {@linkplain Class#isHidden() &lt;em&gt;hidden&lt;/em&gt;}
 159  * class or interface.
 160  * All kinds of class, including enum types and record types, may be
 161  * hidden classes; all kinds of interface, including annotation types,
 162  * may be hidden interfaces.
 163  *
 164  * The {@linkplain #getName() name of a hidden class or interface} is
 165  * not a &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;,
 166  * which means the following:
 167  * &lt;ul&gt;
 168  * &lt;li&gt;A hidden class or interface cannot be referenced by the constant pools
 169  *     of other classes and interfaces.
 170  * &lt;li&gt;A hidden class or interface cannot be described in
 171  *     {@linkplain java.lang.constant.ConstantDesc &lt;em&gt;nominal form&lt;/em&gt;} by
 172  *     {@link #describeConstable() Class::describeConstable},
 173  *     {@link ClassDesc#of(String) ClassDesc::of}, or
 174  *     {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}.
 175  * &lt;li&gt;A hidden class or interface cannot be discovered by {@link #forName Class::forName}
 176  *     or {@link ClassLoader#loadClass(String, boolean) ClassLoader::loadClass}.
 177  * &lt;/ul&gt;
 178  *
 179  * A hidden class or interface is never an array class, but may be
 180  * the element type of an array. In all other respects, the fact that
 181  * a class or interface is hidden has no bearing on the characteristics
 182  * exposed by the methods of class {@code Class}.
 183  *
 184  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 185  * object.  For example, the type of {@code String.class} is {@code
 186  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 187  * unknown.
 188  *
 189  * @author  unascribed
 190  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 191  * @since   1.0
 192  * @jls 15.8.2 Class Literals
 193  */
 194 public final class Class&lt;T&gt; implements java.io.Serializable,
 195                               GenericDeclaration,
 196                               Type,
 197                               AnnotatedElement,
 198                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 199                               Constable {
 200     private static final int ANNOTATION = 0x00002000;
 201     private static final int ENUM       = 0x00004000;
 202     private static final int SYNTHETIC  = 0x00001000;
 203     private static final int INLINE     = 0x00000100;
 204 
 205     private static final ClassDesc[] EMPTY_CLASS_DESC_ARRAY = new ClassDesc[0];
 206 
 207     private static native void registerNatives();
 208     static {
 209         registerNatives();
 210     }
 211 
 212     /*
 213      * Private constructor. Only the Java Virtual Machine creates Class objects.
 214      * This constructor is not used and prevents the default constructor being
 215      * generated.
 216      */
 217     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 218         // Initialize final field for classLoader.  The initialization value of non-null
 219         // prevents future JIT optimizations from assuming this final field is null.
 220         classLoader = loader;
 221         componentType = arrayComponentType;
 222     }
 223 
 224     /**
 225      * Converts the object to a string. The string representation is the
 226      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 227      * name of the class in the format returned by {@code getName}.
 228      * If this {@code Class} object represents a primitive type,
 229      * this method returns the name of the primitive type.  If
 230      * this {@code Class} object represents void this method returns
 231      * &quot;void&quot;. If this {@code Class} object represents an array type,
 232      * this method returns &quot;class &quot; followed by {@code getName}.
 233      *
 234      * @return a string representation of this {@code Class} object.
 235      */
 236     public String toString() {
 237         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 238                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
 239                + getName();
 240     }
 241 
 242     /**
 243      * Returns a string describing this {@code Class}, including
 244      * information about modifiers and type parameters.
 245      *
 246      * The string is formatted as a list of type modifiers, if any,
 247      * followed by the kind of type (empty string for primitive types
 248      * and {@code class}, {@code enum}, {@code interface},
 249      * {@code @interface}, or {@code record} as appropriate), followed
 250      * by the type&#39;s name, followed by an angle-bracketed
 251      * comma-separated list of the type&#39;s type parameters, if any,
 252      * including informative bounds on the type parameters, if any.
 253      *
 254      * A space is used to separate modifiers from one another and to
 255      * separate any modifiers from the kind of type. The modifiers
 256      * occur in canonical order. If there are no type parameters, the
 257      * type parameter list is elided.
 258      *
 259      * For an array type, the string starts with the type name,
 260      * followed by an angle-bracketed comma-separated list of the
 261      * type&#39;s type parameters, if any, followed by a sequence of
 262      * {@code []} characters, one set of brackets per dimension of
 263      * the array.
 264      *
 265      * &lt;p&gt;Note that since information about the runtime representation
 266      * of a type is being generated, modifiers not present on the
 267      * originating source code or illegal on the originating source
 268      * code may be present.
 269      *
 270      * @return a string describing this {@code Class}, including
 271      * information about modifiers and type parameters
 272      *
 273      * @since 1.8
 274      */
 275     @SuppressWarnings(&quot;preview&quot;)
 276     public String toGenericString() {
 277         if (isPrimitive()) {
 278             return toString();
 279         } else {
 280             StringBuilder sb = new StringBuilder();
 281             Class&lt;?&gt; component = this;
 282             int arrayDepth = 0;
 283 
 284             if (isArray()) {
 285                 do {
 286                     arrayDepth++;
 287                     component = component.getComponentType();
 288                 } while (component.isArray());
 289                 sb.append(component.getName());
 290             } else {
 291                 // Class modifiers are a superset of interface modifiers
 292                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 293                 if (modifiers != 0) {
 294                     sb.append(Modifier.toString(modifiers));
 295                     sb.append(&#39; &#39;);
 296                 }
 297 
 298                 if (isAnnotation()) {
 299                     sb.append(&#39;@&#39;);
 300                 }
 301                 if (isInlineClass()) {
 302                     sb.append(&quot;inline&quot;);
 303                     sb.append(&#39; &#39;);
 304                 }
 305                 if (isInterface()) { // Note: all annotation types are interfaces
 306                     sb.append(&quot;interface&quot;);
 307                 } else {
 308                     if (isEnum())
 309                         sb.append(&quot;enum&quot;);
 310                     else if (isRecord())
 311                         sb.append(&quot;record&quot;);
 312                     else
 313                         sb.append(&quot;class&quot;);
 314                 }
 315                 sb.append(&#39; &#39;);
 316                 sb.append(getName());
 317             }
 318 
 319             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 320             if (typeparms.length &gt; 0) {
 321                 sb.append(Arrays.stream(typeparms)
 322                           .map(Class::typeVarBounds)
 323                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 324             }
 325 
 326             if (arrayDepth &gt; 0) sb.append(&quot;[]&quot;.repeat(arrayDepth));
 327 
 328             return sb.toString();
 329         }
 330     }
 331 
 332     static String typeVarBounds(TypeVariable&lt;?&gt; typeVar) {
 333         Type[] bounds = typeVar.getBounds();
 334         if (bounds.length == 1 &amp;&amp; bounds[0].equals(Object.class)) {
 335             return typeVar.getName();
 336         } else {
 337             return typeVar.getName() + &quot; extends &quot; +
 338                 Arrays.stream(bounds)
 339                 .map(Type::getTypeName)
 340                 .collect(Collectors.joining(&quot; &amp; &quot;));
 341         }
 342     }
 343 
 344     /**
 345      * Returns the {@code Class} object associated with the class or
 346      * interface with the given string name.  Invoking this method is
 347      * equivalent to:
 348      *
 349      * &lt;blockquote&gt;
 350      *  {@code Class.forName(className, true, currentLoader)}
 351      * &lt;/blockquote&gt;
 352      *
 353      * where {@code currentLoader} denotes the defining class loader of
 354      * the current class.
 355      *
 356      * &lt;p&gt; For example, the following code fragment returns the
 357      * runtime {@code Class} descriptor for the class named
 358      * {@code java.lang.Thread}:
 359      *
 360      * &lt;blockquote&gt;
 361      *   {@code Class t = Class.forName(&quot;java.lang.Thread&quot;)}
 362      * &lt;/blockquote&gt;
 363      * &lt;p&gt;
 364      * A call to {@code forName(&quot;X&quot;)} causes the class named
 365      * {@code X} to be initialized.
 366      *
 367      * @param      className   the fully qualified name of the desired class.
 368      * @return     the {@code Class} object for the class with the
 369      *             specified name.
 370      * @throws    LinkageError if the linkage fails
 371      * @throws    ExceptionInInitializerError if the initialization provoked
 372      *            by this method fails
 373      * @throws    ClassNotFoundException if the class cannot be located
 374      *
 375      * @jls 12.2 Loading of Classes and Interfaces
 376      * @jls 12.3 Linking of Classes and Interfaces
 377      * @jls 12.4 Initialization of Classes and Interfaces
 378      */
 379     @CallerSensitive
 380     public static Class&lt;?&gt; forName(String className)
 381                 throws ClassNotFoundException {
 382         Class&lt;?&gt; caller = Reflection.getCallerClass();
 383         return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
 384     }
 385 
 386 
 387     /**
 388      * Returns the {@code Class} object associated with the class or
 389      * interface with the given string name, using the given class loader.
 390      * Given the fully qualified name for a class or interface (in the same
 391      * format returned by {@code getName}) this method attempts to
 392      * locate and load the class or interface.  The specified class
 393      * loader is used to load the class or interface.  If the parameter
 394      * {@code loader} is null, the class is loaded through the bootstrap
 395      * class loader.  The class is initialized only if the
 396      * {@code initialize} parameter is {@code true} and if it has
 397      * not been initialized earlier.
 398      *
 399      * &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
 400      * will be made to locate a user-defined class in the unnamed package whose
 401      * name is {@code name}. Therefore, this method cannot be used to
 402      * obtain any of the {@code Class} objects representing primitive
 403      * types or void.
 404      *
 405      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 406      * the array class is loaded but not initialized.
 407      *
 408      * &lt;p&gt; For example, in an instance method the expression:
 409      *
 410      * &lt;blockquote&gt;
 411      *  {@code Class.forName(&quot;Foo&quot;)}
 412      * &lt;/blockquote&gt;
 413      *
 414      * is equivalent to:
 415      *
 416      * &lt;blockquote&gt;
 417      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 418      * &lt;/blockquote&gt;
 419      *
 420      * Note that this method throws errors related to loading, linking
 421      * or initializing as specified in Sections {@jls 12.2}, {@jls
 422      * 12.3}, and {@jls 12.4} of &lt;cite&gt;The Java&amp;trade; Language
 423      * Specification&lt;/cite&gt;.
 424      * Note that this method does not check whether the requested class
 425      * is accessible to its caller.
 426      *
 427      * @param name       fully qualified name of the desired class
 428 
 429      * @param initialize if {@code true} the class will be initialized
 430      *                   (which implies linking). See Section {@jls
 431      *                   12.4} of &lt;cite&gt;The Java&amp;trade; Language
 432      *                   Specification&lt;/cite&gt;.
 433      * @param loader     class loader from which the class must be loaded
 434      * @return           class object representing the desired class
 435      *
 436      * @throws    LinkageError if the linkage fails
 437      * @throws    ExceptionInInitializerError if the initialization provoked
 438      *            by this method fails
 439      * @throws    ClassNotFoundException if the class cannot be located by
 440      *            the specified class loader
 441      * @throws    SecurityException
 442      *            if a security manager is present, and the {@code loader} is
 443      *            {@code null}, and the caller&#39;s class loader is not
 444      *            {@code null}, and the caller does not have the
 445      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 446      *
 447      * @see       java.lang.Class#forName(String)
 448      * @see       java.lang.ClassLoader
 449      *
 450      * @jls 12.2 Loading of Classes and Interfaces
 451      * @jls 12.3 Linking of Classes and Interfaces
 452      * @jls 12.4 Initialization of Classes and Interfaces
 453      * @since     1.2
 454      */
 455     @CallerSensitive
 456     public static Class&lt;?&gt; forName(String name, boolean initialize,
 457                                    ClassLoader loader)
 458         throws ClassNotFoundException
 459     {
 460         Class&lt;?&gt; caller = null;
 461         SecurityManager sm = System.getSecurityManager();
 462         if (sm != null) {
 463             // Reflective call to get caller class is only needed if a security manager
 464             // is present.  Avoid the overhead of making this call otherwise.
 465             caller = Reflection.getCallerClass();
 466             if (loader == null) {
 467                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 468                 if (ccl != null) {
 469                     sm.checkPermission(
 470                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 471                 }
 472             }
 473         }
 474         return forName0(name, initialize, loader, caller);
 475     }
 476 
 477     /** Called after security check for system loader access checks have been made. */
 478     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
 479                                     ClassLoader loader,
 480                                     Class&lt;?&gt; caller)
 481         throws ClassNotFoundException;
 482 
 483 
 484     /**
 485      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 486      * binary name&lt;/a&gt; in the given module.
 487      *
 488      * &lt;p&gt; This method attempts to locate and load the class or interface.
 489      * It does not link the class, and does not run the class initializer.
 490      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 491      *
 492      * &lt;p&gt; If the class loader of the given module defines other modules and
 493      * the given name is a class defined in a different module, this method
 494      * returns {@code null} after the class is loaded. &lt;/p&gt;
 495      *
 496      * &lt;p&gt; This method does not check whether the requested class is
 497      * accessible to its caller. &lt;/p&gt;
 498      *
 499      * @apiNote
 500      * This method returns {@code null} on failure rather than
 501      * throwing a {@link ClassNotFoundException}, as is done by
 502      * the {@link #forName(String, boolean, ClassLoader)} method.
 503      * The security check is a stack-based permission check if the caller
 504      * loads a class in another module.
 505      *
 506      * @param  module   A module
 507      * @param  name     The &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 508      *                  of the class
 509      * @return {@code Class} object of the given name defined in the given module;
 510      *         {@code null} if not found.
 511      *
 512      * @throws NullPointerException if the given module or name is {@code null}
 513      *
 514      * @throws LinkageError if the linkage fails
 515      *
 516      * @throws SecurityException
 517      *         &lt;ul&gt;
 518      *         &lt;li&gt; if the caller is not the specified module and
 519      *         {@code RuntimePermission(&quot;getClassLoader&quot;)} permission is denied; or&lt;/li&gt;
 520      *         &lt;li&gt; access to the module content is denied. For example,
 521      *         permission check will be performed when a class loader calls
 522      *         {@link ModuleReader#open(String)} to read the bytes of a class file
 523      *         in a module.&lt;/li&gt;
 524      *         &lt;/ul&gt;
 525      *
 526      * @jls 12.2 Loading of Classes and Interfaces
 527      * @jls 12.3 Linking of Classes and Interfaces
 528      * @since 9
 529      * @spec JPMS
 530      */
 531     @CallerSensitive
 532     public static Class&lt;?&gt; forName(Module module, String name) {
 533         Objects.requireNonNull(module);
 534         Objects.requireNonNull(name);
 535 
 536         ClassLoader cl;
 537         SecurityManager sm = System.getSecurityManager();
 538         if (sm != null) {
 539             Class&lt;?&gt; caller = Reflection.getCallerClass();
 540             if (caller != null &amp;&amp; caller.getModule() != module) {
 541                 // if caller is null, Class.forName is the last java frame on the stack.
 542                 // java.base has all permissions
 543                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 544             }
 545             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 546             cl = AccessController.doPrivileged(pa);
 547         } else {
 548             cl = module.getClassLoader();
 549         }
 550 
 551         if (cl != null) {
 552             return cl.loadClass(module, name);
 553         } else {
 554             return BootLoader.loadClass(module, name);
 555         }
 556     }
 557 
 558     /**
 559      * Returns {@code true} if this class is an inline class.
 560      *
 561      * @return {@code true} if this class is an inline class
 562      * @since Valhalla
 563      */
 564     public boolean isInlineClass() {
 565         return (this.getModifiers() &amp; INLINE) != 0;
 566     }
 567 
 568     /**
 569      * Returns a {@code Class} object representing the &lt;em&gt;value projection&lt;/em&gt;
 570      * type of this class if this {@code Class} represents the reference projection
 571      * type of an {@linkplain #isInlineClass() inline class}.
 572      * If this {@code Class} represents the value projection type
 573      * of an inline class, then this method returns this class.
 574      * Otherwise an empty {@link Optional} is returned.
 575      *
 576      * @return the {@code Class} object representing the value projection type of
 577      *         this class if this class is the value projection type
 578      *         or the reference projection type of an inline class;
 579      *         an empty {@link Optional} otherwise
 580      * @since Valhalla
 581      */
 582     public Optional&lt;Class&lt;?&gt;&gt; valueType() {
 583         if (isPrimitive() || isInterface() || isArray())
 584             return Optional.empty();
 585 
 586         ensureProjectionTypesInited();
<a name="1" id="anc1"></a><span class="line-removed"> 587         System.out.println(getName() + &quot; &quot; + Arrays.toString(projectionTypes));</span>
 588         return projectionTypes.length &gt; 0 ? Optional.of(projectionTypes[0]) : Optional.empty();
 589     }
 590 
 591     /**
 592      * Returns a {@code Class} object representing the reference type
 593      * of this class.
 594      * &lt;p&gt;
 595      * If this {@code Class} represents an {@linkplain #isInlineClass()
 596      * inline class} with a reference projection type, then this method
 597      * returns the &lt;em&gt;reference projection&lt;/em&gt; type of this inline class.
 598      * &lt;p&gt;
 599      * If this {@code Class} represents the reference projection type
 600      * of an inline class, then this method returns this class.
 601      * &lt;p&gt;
 602      * If this class is an {@linkplain #isInlineClass() inline class}
 603      * without a reference projection, then this method returns an empty
 604      * {@code Optional}.
 605      * &lt;p&gt;
 606      * If this class is an identity class, then this method returns this
 607      * class.
 608      * &lt;p&gt;
 609      * Otherwise this method returns an empty {@code Optional}.
 610      *
 611      * @return the {@code Class} object representing a reference type for
 612      *         this class if present; an empty {@link Optional} otherwise.
 613      * @since Valhalla
 614      */
 615     public Optional&lt;Class&lt;?&gt;&gt; referenceType() {
 616         if (isPrimitive()) return Optional.empty();
 617         if (isInterface() || isArray()) return Optional.of(this);
 618 
 619         ensureProjectionTypesInited();
 620         return projectionTypes.length == 2 ? Optional.of(projectionTypes[1]) : Optional.empty();
 621     }
 622 
 623     private transient Class&lt;?&gt;[] projectionTypes;
 624 
 625     private synchronized void ensureProjectionTypesInited() {
 626         if (isPrimitive() || isArray() || isInterface())
 627             return;
 628 
 629         if (projectionTypes != null)
 630             return;
 631 
 632         if (isInlineClass()) {
 633             Class&lt;?&gt; superClass = getSuperclass();
 634             if (superClass != Object.class &amp;&amp; superClass.isReferenceProjectionType()) {
 635                 projectionTypes = new Class&lt;?&gt;[] { this, superClass };
 636             } else {
 637                 projectionTypes = new Class&lt;?&gt;[] { this };
 638             }
 639         } else if (isReferenceProjectionType()) {
 640             projectionTypes = new Class&lt;?&gt;[] { valueProjectionType(), this };
 641         } else {
 642             projectionTypes = EMPTY_CLASS_ARRAY;
 643         }
 644     }
 645 
 646     private boolean isReferenceProjectionType() {
 647         if (isPrimitive() || isInterface() || isArray() || isInlineClass())
 648             return false;
 649 
 650         if (projectionTypes != null) {
 651             return projectionTypes.length == 2 &amp;&amp; projectionTypes[1] == this;
 652         }
 653 
 654         int mods = getModifiers();
 655         if (!Modifier.isAbstract(mods)) {
 656             return false;
 657         }
 658 
 659         return valueProjectionType() != null;
 660     }
 661 
 662     private Class&lt;?&gt; valueProjectionType() {
 663         // A reference projection type must be a sealed abstract class
 664         // that permits the inline projection type to extend.
 665         // The inline projection type and reference projection type for
 666         // an inline type must be of the same package.
 667         String[] subclassNames = getPermittedSubclasses0();
 668         if (subclassNames.length == 1) {
 669             String cn = subclassNames[0].replace(&#39;/&#39;, &#39;.&#39;);
 670             int index = cn.lastIndexOf(&#39;.&#39;);
 671             String pn = index &gt; 0 ? cn.substring(0, index) : &quot;&quot;;
 672             if (pn.equals(getPackageName())) {
 673                 try {
 674                     Class&lt;?&gt; valType = Class.forName(cn, false, getClassLoader());
 675                     if (valType.isInlineClass()) {
 676                         return valType;
 677                     }
 678                 } catch (ClassNotFoundException e) {}
 679             }
 680         }
 681         return null;
 682     }
 683 
 684     /**
 685      * Creates a new instance of the class represented by this {@code Class}
 686      * object.  The class is instantiated as if by a {@code new}
 687      * expression with an empty argument list.  The class is initialized if it
 688      * has not already been initialized.
 689      *
 690      * @deprecated This method propagates any exception thrown by the
 691      * nullary constructor, including a checked exception.  Use of
 692      * this method effectively bypasses the compile-time exception
 693      * checking that would otherwise be performed by the compiler.
 694      * The {@link
 695      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 696      * Constructor.newInstance} method avoids this problem by wrapping
 697      * any exception thrown by the constructor in a (checked) {@link
 698      * java.lang.reflect.InvocationTargetException}.
 699      *
 700      * &lt;p&gt;The call
 701      *
 702      * &lt;pre&gt;{@code
 703      * clazz.newInstance()
 704      * }&lt;/pre&gt;
 705      *
 706      * can be replaced by
 707      *
 708      * &lt;pre&gt;{@code
 709      * clazz.getDeclaredConstructor().newInstance()
 710      * }&lt;/pre&gt;
 711      *
 712      * The latter sequence of calls is inferred to be able to throw
 713      * the additional exception types {@link
 714      * InvocationTargetException} and {@link
 715      * NoSuchMethodException}. Both of these exception types are
 716      * subclasses of {@link ReflectiveOperationException}.
 717      *
 718      * @return  a newly allocated instance of the class represented by this
 719      *          object.
 720      * @throws  IllegalAccessException  if the class or its nullary
 721      *          constructor is not accessible.
 722      * @throws  InstantiationException
 723      *          if this {@code Class} represents an abstract class,
 724      *          an interface, an array class, a primitive type, or void;
 725      *          or if the class has no nullary constructor;
 726      *          or if the instantiation fails for some other reason.
 727      * @throws  ExceptionInInitializerError if the initialization
 728      *          provoked by this method fails.
 729      * @throws  SecurityException
 730      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
 731      *          the caller&#39;s class loader is not the same as or an
 732      *          ancestor of the class loader for the current class and
 733      *          invocation of {@link SecurityManager#checkPackageAccess
 734      *          s.checkPackageAccess()} denies access to the package
 735      *          of this class.
 736      */
 737     @CallerSensitive
 738     @Deprecated(since=&quot;9&quot;)
 739     public T newInstance()
 740         throws InstantiationException, IllegalAccessException
 741     {
 742         SecurityManager sm = System.getSecurityManager();
 743         if (sm != null) {
 744             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
 745         }
 746 
 747         // Constructor lookup
 748         Constructor&lt;T&gt; tmpConstructor = cachedConstructor;
 749         if (tmpConstructor == null) {
 750             if (this == Class.class) {
 751                 throw new IllegalAccessException(
 752                     &quot;Can not call newInstance() on the Class for java.lang.Class&quot;
 753                 );
 754             }
 755             try {
 756                 Class&lt;?&gt;[] empty = {};
 757                 final Constructor&lt;T&gt; c = getReflectionFactory().copyConstructor(
 758                     getConstructor0(empty, Member.DECLARED));
 759                 // Disable accessibility checks on the constructor
 760                 // access check is done with the true caller
 761                 java.security.AccessController.doPrivileged(
 762                     new java.security.PrivilegedAction&lt;&gt;() {
 763                         public Void run() {
 764                                 c.setAccessible(true);
 765                                 return null;
 766                             }
 767                         });
 768                 cachedConstructor = tmpConstructor = c;
 769             } catch (NoSuchMethodException e) {
 770                 throw (InstantiationException)
 771                     new InstantiationException(getName()).initCause(e);
 772             }
 773         }
 774 
 775         try {
 776             Class&lt;?&gt; caller = Reflection.getCallerClass();
 777             return getReflectionFactory().newInstance(tmpConstructor, null, caller);
 778         } catch (InvocationTargetException e) {
 779             Unsafe.getUnsafe().throwException(e.getTargetException());
 780             // Not reached
 781             return null;
 782         }
 783     }
 784 
 785     private transient volatile Constructor&lt;T&gt; cachedConstructor;
 786 
 787     /**
 788      * Determines if the specified {@code Object} is assignment-compatible
 789      * with the object represented by this {@code Class}.  This method is
 790      * the dynamic equivalent of the Java language {@code instanceof}
 791      * operator. The method returns {@code true} if the specified
 792      * {@code Object} argument is non-null and can be cast to the
 793      * reference type represented by this {@code Class} object without
 794      * raising a {@code ClassCastException.} It returns {@code false}
 795      * otherwise.
 796      *
 797      * &lt;p&gt; Specifically, if this {@code Class} object represents a
 798      * declared class, this method returns {@code true} if the specified
 799      * {@code Object} argument is an instance of the represented class (or
 800      * of any of its subclasses); it returns {@code false} otherwise. If
 801      * this {@code Class} object represents an array class, this method
 802      * returns {@code true} if the specified {@code Object} argument
 803      * can be converted to an object of the array class by an identity
 804      * conversion or by a widening reference conversion; it returns
 805      * {@code false} otherwise. If this {@code Class} object
 806      * represents an interface, this method returns {@code true} if the
 807      * class or any superclass of the specified {@code Object} argument
 808      * implements this interface; it returns {@code false} otherwise. If
 809      * this {@code Class} object represents a primitive type, this method
 810      * returns {@code false}.
 811      *
 812      * @param   obj the object to check
 813      * @return  true if {@code obj} is an instance of this class
 814      *
 815      * @since 1.1
 816      */
 817     @HotSpotIntrinsicCandidate
 818     public native boolean isInstance(Object obj);
 819 
 820 
 821     /**
 822      * Determines if the class or interface represented by this
 823      * {@code Class} object is either the same as, or is a superclass or
 824      * superinterface of, the class or interface represented by the specified
 825      * {@code Class} parameter. It returns {@code true} if so;
 826      * otherwise it returns {@code false}. If this {@code Class}
 827      * object represents a primitive type, this method returns
 828      * {@code true} if the specified {@code Class} parameter is
 829      * exactly this {@code Class} object; otherwise it returns
 830      * {@code false}.
 831      *
 832      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 833      * specified {@code Class} parameter can be converted to the type
 834      * represented by this {@code Class} object via an identity conversion
 835      * or via a widening reference conversion. See &lt;cite&gt;The Java&amp;trade; Language
 836      * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},
 837      * for details.
 838      *
 839      * @param     cls the {@code Class} object to be checked
 840      * @return    the {@code boolean} value indicating whether objects of the
 841      *            type {@code cls} can be assigned to objects of this class
 842      * @throws    NullPointerException if the specified Class parameter is
 843      *            null.
 844      * @since     1.1
 845      */
 846     @HotSpotIntrinsicCandidate
 847     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 848 
 849 
 850     /**
 851      * Determines if this {@code Class} object represents an
 852      * interface type.
 853      *
 854      * @return  {@code true} if this {@code Class} object represents an interface;
 855      *          {@code false} otherwise.
 856      */
 857     @HotSpotIntrinsicCandidate
 858     public native boolean isInterface();
 859 
 860 
 861     /**
 862      * Determines if this {@code Class} object represents an array class.
 863      *
 864      * @return  {@code true} if this {@code Class} object represents an array class;
 865      *          {@code false} otherwise.
 866      * @since   1.1
 867      */
 868     @HotSpotIntrinsicCandidate
 869     public native boolean isArray();
 870 
 871 
 872     /**
 873      * Determines if the specified {@code Class} object represents a
 874      * primitive type.
 875      *
 876      * &lt;p&gt; There are nine predefined {@code Class} objects to represent
 877      * the eight primitive types and void.  These are created by the Java
 878      * Virtual Machine, and have the same names as the primitive types that
 879      * they represent, namely {@code boolean}, {@code byte},
 880      * {@code char}, {@code short}, {@code int},
 881      * {@code long}, {@code float}, and {@code double}.
 882      *
 883      * &lt;p&gt; These objects may only be accessed via the following public static
 884      * final variables, and are the only {@code Class} objects for which
 885      * this method returns {@code true}.
 886      *
 887      * @return true if and only if this class represents a primitive type
 888      *
 889      * @see     java.lang.Boolean#TYPE
 890      * @see     java.lang.Character#TYPE
 891      * @see     java.lang.Byte#TYPE
 892      * @see     java.lang.Short#TYPE
 893      * @see     java.lang.Integer#TYPE
 894      * @see     java.lang.Long#TYPE
 895      * @see     java.lang.Float#TYPE
 896      * @see     java.lang.Double#TYPE
 897      * @see     java.lang.Void#TYPE
 898      * @since 1.1
 899      */
 900     @HotSpotIntrinsicCandidate
 901     public native boolean isPrimitive();
 902 
 903     /**
 904      * Returns true if this {@code Class} object represents an annotation
 905      * type.  Note that if this method returns true, {@link #isInterface()}
 906      * would also return true, as all annotation types are also interfaces.
 907      *
 908      * @return {@code true} if this {@code Class} object represents an annotation
 909      *      type; {@code false} otherwise
 910      * @since 1.5
 911      */
 912     public boolean isAnnotation() {
 913         return (getModifiers() &amp; ANNOTATION) != 0;
 914     }
 915 
 916     /**
 917      * Returns {@code true} if and only if this class has the synthetic modifier
 918      * bit set.
 919      *
 920      * @return {@code true} if and only if this class has the synthetic modifier bit set
 921      * @jls 13.1 The Form of a Binary
 922      * @jvms 4.1 The {@code ClassFile} Structure
 923      * @since 1.5
 924      */
 925     public boolean isSynthetic() {
 926         return (getModifiers() &amp; SYNTHETIC) != 0;
 927     }
 928 
 929     /**
 930      * Returns the  name of the entity (class, interface, array class,
 931      * primitive type, or void) represented by this {@code Class} object.
 932      *
 933      * &lt;p&gt; If this {@code Class} object represents a class or interface,
 934      * not an array class, then:
 935      * &lt;ul&gt;
 936      * &lt;li&gt; If the class or interface is not {@linkplain #isHidden() hidden},
 937      *      then the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 938      *      of the class or interface is returned.
 939      * &lt;li&gt; If the class or interface is hidden, then the result is a string
 940      *      of the form: {@code N + &#39;/&#39; + &lt;suffix&gt;}
 941      *      where {@code N} is the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 942      *      indicated by the {@code class} file passed to
 943      *      {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 944      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.
 945      * &lt;/ul&gt;
 946      *
 947      * &lt;p&gt; If this {@code Class} object represents an array class, then
 948      * the result is a string consisting of one or more &#39;{@code [}&#39; characters
 949      * representing the depth of the array nesting, followed by the element
 950      * type as encoded using the following table:
 951      *
 952      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 953      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 954      * &lt;thead&gt;
 955      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 956      * &lt;/thead&gt;
 957      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 958      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code boolean} &lt;td style=&quot;text-align:center&quot;&gt; {@code Z}
 959      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code byte}    &lt;td style=&quot;text-align:center&quot;&gt; {@code B}
 960      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code char}    &lt;td style=&quot;text-align:center&quot;&gt; {@code C}
 961      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;
 962      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code L}&lt;em&gt;N&lt;/em&gt;{@code ;}
 963      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@linkplain #isInlineClass() inline class} with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;
 964      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code Q}&lt;em&gt;N&lt;/em&gt;{@code ;}
 965      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code double}  &lt;td style=&quot;text-align:center&quot;&gt; {@code D}
 966      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code float}   &lt;td style=&quot;text-align:center&quot;&gt; {@code F}
 967      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code int}     &lt;td style=&quot;text-align:center&quot;&gt; {@code I}
 968      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code long}    &lt;td style=&quot;text-align:center&quot;&gt; {@code J}
 969      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code short}   &lt;td style=&quot;text-align:center&quot;&gt; {@code S}
 970      * &lt;/tbody&gt;
 971      * &lt;/table&gt;&lt;/blockquote&gt;
 972      *
 973      * &lt;p&gt; If this {@code Class} object represents a primitive type or {@code void},
 974      * then the result is a string with the same spelling as the Java language
 975      * keyword which corresponds to the primitive type or {@code void}.
 976      *
 977      * &lt;p&gt; Examples:
 978      * &lt;blockquote&gt;&lt;pre&gt;
 979      * String.class.getName()
 980      *     returns &quot;java.lang.String&quot;
 981      * byte.class.getName()
 982      *     returns &quot;byte&quot;
 983      * Point.class.getName()
 984      *     returns &quot;Point&quot;
 985      * (new Object[3]).getClass().getName()
 986      *     returns &quot;[Ljava.lang.Object;&quot;
 987      * (new Point[3]).getClass().getName()
 988      *     returns &quot;[QPoint;&quot;
 989      * (new Point.ref[3][4]).getClass().getName()
 990      *     returns &quot;[[LPoint$ref;&quot;
 991      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 992      *     returns &quot;[[[[[[[I&quot;
 993      * &lt;/pre&gt;&lt;/blockquote&gt;
 994      *
 995      * @return  the name of the class, interface, or other entity
 996      *          represented by this {@code Class} object.
 997      * @jls 13.1 The Form of a Binary
 998      */
 999     public String getName() {
1000         String name = this.name;
1001         return name != null ? name : initClassName();
1002     }
1003 
1004     // Cache the name to reduce the number of calls into the VM.
1005     // This field would be set by VM itself during initClassName call.
1006     private transient String name;
1007     private native String initClassName();
1008 
1009     /**
1010      * Returns the class loader for the class.  Some implementations may use
1011      * null to represent the bootstrap class loader. This method will return
1012      * null in such implementations if this class was loaded by the bootstrap
1013      * class loader.
1014      *
1015      * &lt;p&gt;If this {@code Class} object
1016      * represents a primitive type or void, null is returned.
1017      *
1018      * @return  the class loader that loaded the class or interface
1019      *          represented by this {@code Class} object.
1020      * @throws  SecurityException
1021      *          if a security manager is present, and the caller&#39;s class loader
1022      *          is not {@code null} and is not the same as or an ancestor of the
1023      *          class loader for the class whose class loader is requested,
1024      *          and the caller does not have the
1025      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
1026      * @see java.lang.ClassLoader
1027      * @see SecurityManager#checkPermission
1028      * @see java.lang.RuntimePermission
1029      */
1030     @CallerSensitive
1031     @ForceInline // to ensure Reflection.getCallerClass optimization
1032     public ClassLoader getClassLoader() {
1033         ClassLoader cl = getClassLoader0();
1034         if (cl == null)
1035             return null;
1036         SecurityManager sm = System.getSecurityManager();
1037         if (sm != null) {
1038             ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
1039         }
1040         return cl;
1041     }
1042 
1043     // Package-private to allow ClassLoader access
1044     ClassLoader getClassLoader0() { return classLoader; }
1045 
1046     /**
1047      * Returns the module that this class or interface is a member of.
1048      *
1049      * If this class represents an array type then this method returns the
1050      * {@code Module} for the element type. If this class represents a
1051      * primitive type or void, then the {@code Module} object for the
1052      * {@code java.base} module is returned.
1053      *
1054      * If this class is in an unnamed module then the {@linkplain
1055      * ClassLoader#getUnnamedModule() unnamed} {@code Module} of the class
1056      * loader for this class is returned.
1057      *
1058      * @return the module that this class or interface is a member of
1059      *
1060      * @since 9
1061      * @spec JPMS
1062      */
1063     public Module getModule() {
1064         return module;
1065     }
1066 
1067     // set by VM
1068     private transient Module module;
1069 
1070     // Initialized in JVM not by private constructor
1071     // This field is filtered from reflection access, i.e. getDeclaredField
1072     // will throw NoSuchFieldException
1073     private final ClassLoader classLoader;
1074 
1075     // Set by VM
1076     private transient Object classData;
1077 
1078     // package-private
1079     Object getClassData() {
1080         return classData;
1081     }
1082 
1083     /**
1084      * Returns an array of {@code TypeVariable} objects that represent the
1085      * type variables declared by the generic declaration represented by this
1086      * {@code GenericDeclaration} object, in declaration order.  Returns an
1087      * array of length 0 if the underlying generic declaration declares no type
1088      * variables.
1089      *
1090      * @return an array of {@code TypeVariable} objects that represent
1091      *     the type variables declared by this generic declaration
1092      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1093      *     signature of this generic declaration does not conform to
1094      *     the format specified in section {@jvms 4.7.9} of
1095      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
1096      * @since 1.5
1097      */
1098     @SuppressWarnings(&quot;unchecked&quot;)
1099     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
1100         ClassRepository info = getGenericInfo();
1101         if (info != null)
1102             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
1103         else
1104             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
1105     }
1106 
1107 
1108     /**
1109      * Returns the {@code Class} representing the direct superclass of the
1110      * entity (class, interface, primitive type or void) represented by
1111      * this {@code Class}.  If this {@code Class} represents either the
1112      * {@code Object} class, an interface, a primitive type, or void, then
1113      * null is returned.  If this {@code Class} object represents an array class
1114      * then the {@code Class} object representing the {@code Object} class is
1115      * returned.
1116      *
1117      * @return the direct superclass of the class represented by this {@code Class} object
1118      */
1119     @HotSpotIntrinsicCandidate
1120     public native Class&lt;? super T&gt; getSuperclass();
1121 
1122 
1123     /**
1124      * Returns the {@code Type} representing the direct superclass of
1125      * the entity (class, interface, primitive type or void) represented by
1126      * this {@code Class} object.
1127      *
1128      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
1129      * object returned must accurately reflect the actual type
1130      * arguments used in the source code. The parameterized type
1131      * representing the superclass is created if it had not been
1132      * created before. See the declaration of {@link
1133      * java.lang.reflect.ParameterizedType ParameterizedType} for the
1134      * semantics of the creation process for parameterized types.  If
1135      * this {@code Class} object represents either the {@code Object}
1136      * class, an interface, a primitive type, or void, then null is
1137      * returned.  If this {@code Class} object represents an array class
1138      * then the {@code Class} object representing the {@code Object} class is
1139      * returned.
1140      *
1141      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1142      *     class signature does not conform to the format specified in
1143      *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual
1144      *     Machine Specification&lt;/cite&gt;
1145      * @throws TypeNotPresentException if the generic superclass
1146      *     refers to a non-existent type declaration
1147      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
1148      *     generic superclass refers to a parameterized type that cannot be
1149      *     instantiated  for any reason
1150      * @return the direct superclass of the class represented by this {@code Class} object
1151      * @since 1.5
1152      */
1153     public Type getGenericSuperclass() {
1154         ClassRepository info = getGenericInfo();
1155         if (info == null) {
1156             return getSuperclass();
1157         }
1158 
1159         // Historical irregularity:
1160         // Generic signature marks interfaces with superclass = Object
1161         // but this API returns null for interfaces
1162         if (isInterface()) {
1163             return null;
1164         }
1165 
1166         return info.getSuperclass();
1167     }
1168 
1169     /**
1170      * Gets the package of this class.
1171      *
1172      * &lt;p&gt;If this class represents an array type, a primitive type or void,
1173      * this method returns {@code null}.
1174      *
1175      * @return the package of this class.
1176      * @revised 9
1177      * @spec JPMS
1178      */
1179     public Package getPackage() {
1180         if (isPrimitive() || isArray()) {
1181             return null;
1182         }
1183         ClassLoader cl = getClassLoader0();
1184         return cl != null ? cl.definePackage(this)
1185                           : BootLoader.definePackage(this);
1186     }
1187 
1188     /**
1189      * Returns the fully qualified package name.
1190      *
1191      * &lt;p&gt; If this class is a top level class, then this method returns the fully
1192      * qualified name of the package that the class is a member of, or the
1193      * empty string if the class is in an unnamed package.
1194      *
1195      * &lt;p&gt; If this class is a member class, then this method is equivalent to
1196      * invoking {@code getPackageName()} on the {@linkplain #getEnclosingClass
1197      * enclosing class}.
1198      *
1199      * &lt;p&gt; If this class is a {@linkplain #isLocalClass local class} or an {@linkplain
1200      * #isAnonymousClass() anonymous class}, then this method is equivalent to
1201      * invoking {@code getPackageName()} on the {@linkplain #getDeclaringClass
1202      * declaring class} of the {@linkplain #getEnclosingMethod enclosing method} or
1203      * {@linkplain #getEnclosingConstructor enclosing constructor}.
1204      *
1205      * &lt;p&gt; If this class represents an array type then this method returns the
1206      * package name of the element type. If this class represents a primitive
1207      * type or void then the package name &quot;{@code java.lang}&quot; is returned.
1208      *
1209      * @return the fully qualified package name
1210      *
1211      * @since 9
1212      * @spec JPMS
1213      * @jls 6.7 Fully Qualified Names
1214      */
1215     public String getPackageName() {
1216         String pn = this.packageName;
1217         if (pn == null) {
1218             Class&lt;?&gt; c = isArray() ? elementType() : this;
1219             if (c.isPrimitive()) {
1220                 pn = &quot;java.lang&quot;;
1221             } else {
1222                 String cn = c.getName();
1223                 int dot = cn.lastIndexOf(&#39;.&#39;);
1224                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1225             }
1226             this.packageName = pn;
1227         }
1228         return pn;
1229     }
1230 
1231     // cached package name
1232     private transient String packageName;
1233 
1234     /**
1235      * Returns the interfaces directly implemented by the class or interface
1236      * represented by this {@code Class} object.
1237      *
1238      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1239      * containing objects representing all interfaces directly implemented by
1240      * the class.  The order of the interface objects in the array corresponds
1241      * to the order of the interface names in the {@code implements} clause of
1242      * the declaration of the class represented by this {@code Class} object.  For example,
1243      * given the declaration:
1244      * &lt;blockquote&gt;
1245      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
1246      * &lt;/blockquote&gt;
1247      * suppose the value of {@code s} is an instance of
1248      * {@code Shimmer}; the value of the expression:
1249      * &lt;blockquote&gt;
1250      * {@code s.getClass().getInterfaces()[0]}
1251      * &lt;/blockquote&gt;
1252      * is the {@code Class} object that represents interface
1253      * {@code FloorWax}; and the value of:
1254      * &lt;blockquote&gt;
1255      * {@code s.getClass().getInterfaces()[1]}
1256      * &lt;/blockquote&gt;
1257      * is the {@code Class} object that represents interface
1258      * {@code DessertTopping}.
1259      *
1260      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1261      * representing all interfaces directly extended by the interface.  The
1262      * order of the interface objects in the array corresponds to the order of
1263      * the interface names in the {@code extends} clause of the declaration of
1264      * the interface represented by this {@code Class} object.
1265      *
1266      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1267      * interfaces, the method returns an array of length 0.
1268      *
1269      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1270      * returns an array of length 0.
1271      *
1272      * &lt;p&gt;If this {@code Class} object represents an array type, the
1273      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1274      * returned in that order.
1275      *
1276      * @return an array of interfaces directly implemented by this class
1277      */
1278     public Class&lt;?&gt;[] getInterfaces() {
1279         // defensively copy before handing over to user code
1280         return getInterfaces(true);
1281     }
1282 
1283     private Class&lt;?&gt;[] getInterfaces(boolean cloneArray) {
1284         ReflectionData&lt;T&gt; rd = reflectionData();
1285         if (rd == null) {
1286             // no cloning required
1287             return getInterfaces0();
1288         } else {
1289             Class&lt;?&gt;[] interfaces = rd.interfaces;
1290             if (interfaces == null) {
1291                 interfaces = getInterfaces0();
1292                 rd.interfaces = interfaces;
1293             }
1294             // defensively copy if requested
1295             return cloneArray ? interfaces.clone() : interfaces;
1296         }
1297     }
1298 
1299     private native Class&lt;?&gt;[] getInterfaces0();
1300 
1301     /**
1302      * Returns the {@code Type}s representing the interfaces
1303      * directly implemented by the class or interface represented by
1304      * this {@code Class} object.
1305      *
1306      * &lt;p&gt;If a superinterface is a parameterized type, the
1307      * {@code Type} object returned for it must accurately reflect
1308      * the actual type arguments used in the source code. The
1309      * parameterized type representing each superinterface is created
1310      * if it had not been created before. See the declaration of
1311      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1312      * for the semantics of the creation process for parameterized
1313      * types.
1314      *
1315      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1316      * containing objects representing all interfaces directly implemented by
1317      * the class.  The order of the interface objects in the array corresponds
1318      * to the order of the interface names in the {@code implements} clause of
1319      * the declaration of the class represented by this {@code Class} object.
1320      *
1321      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1322      * representing all interfaces directly extended by the interface.  The
1323      * order of the interface objects in the array corresponds to the order of
1324      * the interface names in the {@code extends} clause of the declaration of
1325      * the interface represented by this {@code Class} object.
1326      *
1327      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1328      * interfaces, the method returns an array of length 0.
1329      *
1330      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1331      * returns an array of length 0.
1332      *
1333      * &lt;p&gt;If this {@code Class} object represents an array type, the
1334      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1335      * returned in that order.
1336      *
1337      * @throws java.lang.reflect.GenericSignatureFormatError
1338      *     if the generic class signature does not conform to the
1339      *     format specified in section {@jvms 4.7.9} of &lt;cite&gt;The
1340      *     Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
1341      * @throws TypeNotPresentException if any of the generic
1342      *     superinterfaces refers to a non-existent type declaration
1343      * @throws java.lang.reflect.MalformedParameterizedTypeException
1344      *     if any of the generic superinterfaces refer to a parameterized
1345      *     type that cannot be instantiated for any reason
1346      * @return an array of interfaces directly implemented by this class
1347      * @since 1.5
1348      */
1349     public Type[] getGenericInterfaces() {
1350         ClassRepository info = getGenericInfo();
1351         return (info == null) ?  getInterfaces() : info.getSuperInterfaces();
1352     }
1353 
1354 
1355     /**
1356      * Returns the {@code Class} representing the component type of an
1357      * array.  If this class does not represent an array class this method
1358      * returns null.
1359      *
1360      * @return the {@code Class} representing the component type of this
1361      * class if this class is an array
1362      * @see     java.lang.reflect.Array
1363      * @since 1.1
1364      */
1365     public Class&lt;?&gt; getComponentType() {
1366         // Only return for array types. Storage may be reused for Class for instance types.
1367         if (isArray()) {
1368             return componentType;
1369         } else {
1370             return null;
1371         }
1372     }
1373 
1374     private final Class&lt;?&gt; componentType;
1375 
1376     /*
1377      * Returns the {@code Class} representing the element type of an array class.
1378      * If this class does not represent an array class, then this method returns
1379      * {@code null}.
1380      */
1381     private Class&lt;?&gt; elementType() {
1382         if (!isArray()) return null;
1383 
1384         Class&lt;?&gt; c = this;
1385         while (c.isArray()) {
1386             c = c.getComponentType();
1387         }
1388         return c;
1389     }
1390 
1391     /**
1392      * Returns the Java language modifiers for this class or interface, encoded
1393      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1394      * constants for {@code public}, {@code protected},
1395      * {@code private}, {@code final}, {@code static},
1396      * {@code abstract} and {@code interface}; they should be decoded
1397      * using the methods of class {@code Modifier}.
1398      *
1399      * &lt;p&gt; If the underlying class is an array class, then its
1400      * {@code public}, {@code private} and {@code protected}
1401      * modifiers are the same as those of its component type.  If this
1402      * {@code Class} object represents a primitive type or void, its
1403      * {@code public} modifier is always {@code true}, and its
1404      * {@code protected} and {@code private} modifiers are always
1405      * {@code false}. If this {@code Class} object represents an array class, a
1406      * primitive type or void, then its {@code final} modifier is always
1407      * {@code true} and its interface modifier is always
1408      * {@code false}. The values of its other modifiers are not determined
1409      * by this specification.
1410      *
1411      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1412      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1413      *
1414      * @return the {@code int} representing the modifiers for this class
1415      * @see     java.lang.reflect.Modifier
1416      * @since 1.1
1417      */
1418     @HotSpotIntrinsicCandidate
1419     public native int getModifiers();
1420 
1421     /**
1422      * Gets the signers of this class.
1423      *
1424      * @return  the signers of this class, or null if there are no signers.  In
1425      *          particular, this method returns null if this {@code Class} object represents
1426      *          a primitive type or void.
1427      * @since   1.1
1428      */
1429     public native Object[] getSigners();
1430 
1431     /**
1432      * Set the signers of this class.
1433      */
1434     native void setSigners(Object[] signers);
1435 
1436 
1437     /**
1438      * If this {@code Class} object represents a local or anonymous
1439      * class within a method, returns a {@link
1440      * java.lang.reflect.Method Method} object representing the
1441      * immediately enclosing method of the underlying class. Returns
1442      * {@code null} otherwise.
1443      *
1444      * In particular, this method returns {@code null} if the underlying
1445      * class is a local or anonymous class immediately enclosed by a type
1446      * declaration, instance initializer or static initializer.
1447      *
1448      * @return the immediately enclosing method of the underlying class, if
1449      *     that class is a local or anonymous class; otherwise {@code null}.
1450      *
1451      * @throws SecurityException
1452      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1453      *         following conditions is met:
1454      *
1455      *         &lt;ul&gt;
1456      *
1457      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1458      *         class loader of the enclosing class and invocation of
1459      *         {@link SecurityManager#checkPermission
1460      *         s.checkPermission} method with
1461      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1462      *         denies access to the methods within the enclosing class
1463      *
1464      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1465      *         ancestor of the class loader for the enclosing class and
1466      *         invocation of {@link SecurityManager#checkPackageAccess
1467      *         s.checkPackageAccess()} denies access to the package
1468      *         of the enclosing class
1469      *
1470      *         &lt;/ul&gt;
1471      * @since 1.5
1472      */
1473     @CallerSensitive
1474     public Method getEnclosingMethod() throws SecurityException {
1475         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1476 
1477         if (enclosingInfo == null)
1478             return null;
1479         else {
1480             if (!enclosingInfo.isMethod())
1481                 return null;
1482 
1483             MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),
1484                                                               getFactory());
1485             Class&lt;?&gt;   returnType       = toClass(typeInfo.getReturnType());
1486             Type []    parameterTypes   = typeInfo.getParameterTypes();
1487             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1488 
1489             // Convert Types to Classes; returned types *should*
1490             // be class objects since the methodDescriptor&#39;s used
1491             // don&#39;t have generics information
1492             for(int i = 0; i &lt; parameterClasses.length; i++)
1493                 parameterClasses[i] = toClass(parameterTypes[i]);
1494 
1495             // Perform access check
1496             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1497             SecurityManager sm = System.getSecurityManager();
1498             if (sm != null) {
1499                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1500                                                      Reflection.getCallerClass(), true);
1501             }
1502             Method[] candidates = enclosingCandidate.privateGetDeclaredMethods(false);
1503 
1504             /*
1505              * Loop over all declared methods; match method name,
1506              * number of and type of parameters, *and* return
1507              * type.  Matching return type is also necessary
1508              * because of covariant returns, etc.
1509              */
1510             ReflectionFactory fact = getReflectionFactory();
1511             for (Method m : candidates) {
1512                 if (m.getName().equals(enclosingInfo.getName()) &amp;&amp;
1513                     arrayContentsEq(parameterClasses,
1514                                     fact.getExecutableSharedParameterTypes(m))) {
1515                     // finally, check return type
1516                     if (m.getReturnType().equals(returnType)) {
1517                         return fact.copyMethod(m);
1518                     }
1519                 }
1520             }
1521 
1522             throw new InternalError(&quot;Enclosing method not found&quot;);
1523         }
1524     }
1525 
1526     private native Object[] getEnclosingMethod0();
1527 
1528     private EnclosingMethodInfo getEnclosingMethodInfo() {
1529         Object[] enclosingInfo = getEnclosingMethod0();
1530         if (enclosingInfo == null)
1531             return null;
1532         else {
1533             return new EnclosingMethodInfo(enclosingInfo);
1534         }
1535     }
1536 
1537     private static final class EnclosingMethodInfo {
1538         private final Class&lt;?&gt; enclosingClass;
1539         private final String name;
1540         private final String descriptor;
1541 
1542         static void validate(Object[] enclosingInfo) {
1543             if (enclosingInfo.length != 3)
1544                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1545             try {
1546                 // The array is expected to have three elements:
1547 
1548                 // the immediately enclosing class
1549                 Class&lt;?&gt; enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1550                 assert(enclosingClass != null);
1551 
1552                 // the immediately enclosing method or constructor&#39;s
1553                 // name (can be null).
1554                 String name = (String)enclosingInfo[1];
1555 
1556                 // the immediately enclosing method or constructor&#39;s
1557                 // descriptor (null iff name is).
1558                 String descriptor = (String)enclosingInfo[2];
1559                 assert((name != null &amp;&amp; descriptor != null) || name == descriptor);
1560             } catch (ClassCastException cce) {
1561                 throw new InternalError(&quot;Invalid type in enclosing method information&quot;, cce);
1562             }
1563         }
1564 
1565         EnclosingMethodInfo(Object[] enclosingInfo) {
1566             validate(enclosingInfo);
1567             this.enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1568             this.name = (String)enclosingInfo[1];
1569             this.descriptor = (String)enclosingInfo[2];
1570         }
1571 
1572         boolean isPartial() {
1573             return enclosingClass == null || name == null || descriptor == null;
1574         }
1575 
1576         boolean isConstructor() { return !isPartial() &amp;&amp; &quot;&lt;init&gt;&quot;.equals(name); }
1577 
1578         boolean isMethod() { return !isPartial() &amp;&amp; !isConstructor() &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name); }
1579 
1580         Class&lt;?&gt; getEnclosingClass() { return enclosingClass; }
1581 
1582         String getName() { return name; }
1583 
1584         String getDescriptor() { return descriptor; }
1585 
1586     }
1587 
1588     private static Class&lt;?&gt; toClass(Type o) {
1589         if (o instanceof GenericArrayType)
1590             return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),
1591                                      0)
1592                 .getClass();
1593         return (Class&lt;?&gt;)o;
1594      }
1595 
1596     /**
1597      * If this {@code Class} object represents a local or anonymous
1598      * class within a constructor, returns a {@link
1599      * java.lang.reflect.Constructor Constructor} object representing
1600      * the immediately enclosing constructor of the underlying
1601      * class. Returns {@code null} otherwise.  In particular, this
1602      * method returns {@code null} if the underlying class is a local
1603      * or anonymous class immediately enclosed by a type declaration,
1604      * instance initializer or static initializer.
1605      *
1606      * @return the immediately enclosing constructor of the underlying class, if
1607      *     that class is a local or anonymous class; otherwise {@code null}.
1608      * @throws SecurityException
1609      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1610      *         following conditions is met:
1611      *
1612      *         &lt;ul&gt;
1613      *
1614      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1615      *         class loader of the enclosing class and invocation of
1616      *         {@link SecurityManager#checkPermission
1617      *         s.checkPermission} method with
1618      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1619      *         denies access to the constructors within the enclosing class
1620      *
1621      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1622      *         ancestor of the class loader for the enclosing class and
1623      *         invocation of {@link SecurityManager#checkPackageAccess
1624      *         s.checkPackageAccess()} denies access to the package
1625      *         of the enclosing class
1626      *
1627      *         &lt;/ul&gt;
1628      * @since 1.5
1629      */
1630     @CallerSensitive
1631     public Constructor&lt;?&gt; getEnclosingConstructor() throws SecurityException {
1632         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1633 
1634         if (enclosingInfo == null)
1635             return null;
1636         else {
1637             if (!enclosingInfo.isConstructor())
1638                 return null;
1639 
1640             ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),
1641                                                                         getFactory());
1642             Type []    parameterTypes   = typeInfo.getParameterTypes();
1643             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1644 
1645             // Convert Types to Classes; returned types *should*
1646             // be class objects since the methodDescriptor&#39;s used
1647             // don&#39;t have generics information
1648             for(int i = 0; i &lt; parameterClasses.length; i++)
1649                 parameterClasses[i] = toClass(parameterTypes[i]);
1650 
1651             // Perform access check
1652             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1653             SecurityManager sm = System.getSecurityManager();
1654             if (sm != null) {
1655                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1656                                                      Reflection.getCallerClass(), true);
1657             }
1658 
1659             Constructor&lt;?&gt;[] candidates = enclosingCandidate
1660                     .privateGetDeclaredConstructors(false);
1661             /*
1662              * Loop over all declared constructors; match number
1663              * of and type of parameters.
1664              */
1665             ReflectionFactory fact = getReflectionFactory();
1666             for (Constructor&lt;?&gt; c : candidates) {
1667                 if (arrayContentsEq(parameterClasses,
1668                                     fact.getExecutableSharedParameterTypes(c))) {
1669                     return fact.copyConstructor(c);
1670                 }
1671             }
1672 
1673             throw new InternalError(&quot;Enclosing constructor not found&quot;);
1674         }
1675     }
1676 
1677 
1678     /**
1679      * If the class or interface represented by this {@code Class} object
1680      * is a member of another class, returns the {@code Class} object
1681      * representing the class in which it was declared.  This method returns
1682      * null if this class or interface is not a member of any other class.  If
1683      * this {@code Class} object represents an array class, a primitive
1684      * type, or void,then this method returns null.
1685      *
1686      * @return the declaring class for this class
1687      * @throws SecurityException
1688      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1689      *         class loader is not the same as or an ancestor of the class
1690      *         loader for the declaring class and invocation of {@link
1691      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
1692      *         denies access to the package of the declaring class
1693      * @since 1.1
1694      */
1695     @CallerSensitive
1696     public Class&lt;?&gt; getDeclaringClass() throws SecurityException {
1697         final Class&lt;?&gt; candidate = getDeclaringClass0();
1698 
1699         if (candidate != null) {
1700             SecurityManager sm = System.getSecurityManager();
1701             if (sm != null) {
1702                 candidate.checkPackageAccess(sm,
1703                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1704             }
1705         }
1706         return candidate;
1707     }
1708 
1709     private native Class&lt;?&gt; getDeclaringClass0();
1710 
1711 
1712     /**
1713      * Returns the immediately enclosing class of the underlying
1714      * class.  If the underlying class is a top level class this
1715      * method returns {@code null}.
1716      * @return the immediately enclosing class of the underlying class
1717      * @throws     SecurityException
1718      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1719      *             class loader is not the same as or an ancestor of the class
1720      *             loader for the enclosing class and invocation of {@link
1721      *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
1722      *             denies access to the package of the enclosing class
1723      * @since 1.5
1724      */
1725     @CallerSensitive
1726     public Class&lt;?&gt; getEnclosingClass() throws SecurityException {
1727         // There are five kinds of classes (or interfaces):
1728         // a) Top level classes
1729         // b) Nested classes (static member classes)
1730         // c) Inner classes (non-static member classes)
1731         // d) Local classes (named classes declared within a method)
1732         // e) Anonymous classes
1733 
1734 
1735         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1736         // attribute if and only if it is a local class or an
1737         // anonymous class.
1738         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1739         Class&lt;?&gt; enclosingCandidate;
1740 
1741         if (enclosingInfo == null) {
1742             // This is a top level or a nested class or an inner class (a, b, or c)
1743             enclosingCandidate = getDeclaringClass0();
1744         } else {
1745             Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass();
1746             // This is a local class or an anonymous class (d or e)
1747             if (enclosingClass == this || enclosingClass == null)
1748                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1749             else
1750                 enclosingCandidate = enclosingClass;
1751         }
1752 
1753         if (enclosingCandidate != null) {
1754             SecurityManager sm = System.getSecurityManager();
1755             if (sm != null) {
1756                 enclosingCandidate.checkPackageAccess(sm,
1757                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1758             }
1759         }
1760         return enclosingCandidate;
1761     }
1762 
1763     /**
1764      * Returns the simple name of the underlying class as given in the
1765      * source code. Returns an empty string if the underlying class is
1766      * anonymous.
1767      *
1768      * &lt;p&gt;The simple name of an array is the simple name of the
1769      * component type with &quot;[]&quot; appended.  In particular the simple
1770      * name of an array whose component type is anonymous is &quot;[]&quot;.
1771      *
1772      * @return the simple name of the underlying class
1773      * @since 1.5
1774      */
1775     public String getSimpleName() {
1776         ReflectionData&lt;T&gt; rd = reflectionData();
1777         String simpleName = rd.simpleName;
1778         if (simpleName == null) {
1779             rd.simpleName = simpleName = getSimpleName0();
1780         }
1781         return simpleName;
1782     }
1783 
1784     private String getSimpleName0() {
1785         if (isArray()) {
1786             return getComponentType().getSimpleName() + &quot;[]&quot;;
1787         }
1788         String simpleName = getSimpleBinaryName();
1789         if (simpleName == null) { // top level class
1790             simpleName = getName();
1791             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1792         }
1793         return simpleName;
1794     }
1795 
1796     /**
1797      * Return an informative string for the name of this type.
1798      *
1799      * @return an informative string for the name of this type
1800      * @since 1.8
1801      */
1802     public String getTypeName() {
1803         if (isArray()) {
1804             try {
1805                 Class&lt;?&gt; cl = this;
1806                 int dimensions = 0;
1807                 do {
1808                     dimensions++;
1809                     cl = cl.getComponentType();
1810                 } while (cl.isArray());
1811                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1812             } catch (Throwable e) { /*FALLTHRU*/ }
1813         }
1814         return getName();
1815     }
1816 
1817     /**
1818      * Returns the canonical name of the underlying class as
1819      * defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
1820      * Returns {@code null} if the underlying class does not have a canonical
1821      * name. Classes without canonical names include:
1822      * &lt;ul&gt;
1823      * &lt;li&gt;a {@linkplain #isLocalClass() local class}
1824      * &lt;li&gt;a {@linkplain #isAnonymousClass() anonymous class}
1825      * &lt;li&gt;a {@linkplain #isHidden() hidden class}
1826      * &lt;li&gt;an array whose component type does not have a canonical name&lt;/li&gt;
1827      * &lt;/ul&gt;
1828      *
1829      * @return the canonical name of the underlying class if it exists, and
1830      * {@code null} otherwise.
1831      * @since 1.5
1832      */
1833     public String getCanonicalName() {
1834         ReflectionData&lt;T&gt; rd = reflectionData();
1835         String canonicalName = rd.canonicalName;
1836         if (canonicalName == null) {
1837             rd.canonicalName = canonicalName = getCanonicalName0();
1838         }
1839         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1840     }
1841 
1842     private String getCanonicalName0() {
1843         if (isArray()) {
1844             String canonicalName = getComponentType().getCanonicalName();
1845             if (canonicalName != null)
1846                 return canonicalName + &quot;[]&quot;;
1847             else
1848                 return ReflectionData.NULL_SENTINEL;
1849         }
1850         if (isHidden() || isLocalOrAnonymousClass())
1851             return ReflectionData.NULL_SENTINEL;
1852         Class&lt;?&gt; enclosingClass = getEnclosingClass();
1853         if (enclosingClass == null) { // top level class
1854             return getName();
1855         } else {
1856             String enclosingName = enclosingClass.getCanonicalName();
1857             if (enclosingName == null)
1858                 return ReflectionData.NULL_SENTINEL;
1859             return enclosingName + &quot;.&quot; + getSimpleName();
1860         }
1861     }
1862 
1863     /**
1864      * Returns {@code true} if and only if the underlying class
1865      * is an anonymous class.
1866      *
1867      * @apiNote
1868      * An anonymous class is not a {@linkplain #isHidden() hidden class}.
1869      *
1870      * @return {@code true} if and only if this class is an anonymous class.
1871      * @since 1.5
1872      */
1873     public boolean isAnonymousClass() {
1874         return !isArray() &amp;&amp; isLocalOrAnonymousClass() &amp;&amp;
1875                 getSimpleBinaryName0() == null;
1876     }
1877 
1878     /**
1879      * Returns {@code true} if and only if the underlying class
1880      * is a local class.
1881      *
1882      * @return {@code true} if and only if this class is a local class.
1883      * @since 1.5
1884      */
1885     public boolean isLocalClass() {
1886         return isLocalOrAnonymousClass() &amp;&amp;
1887                 (isArray() || getSimpleBinaryName0() != null);
1888     }
1889 
1890     /**
1891      * Returns {@code true} if and only if the underlying class
1892      * is a member class.
1893      *
1894      * @return {@code true} if and only if this class is a member class.
1895      * @since 1.5
1896      */
1897     public boolean isMemberClass() {
1898         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() != null;
1899     }
1900 
1901     /**
1902      * Returns the &quot;simple binary name&quot; of the underlying class, i.e.,
1903      * the binary name without the leading enclosing class name.
1904      * Returns {@code null} if the underlying class is a top level
1905      * class.
1906      */
1907     private String getSimpleBinaryName() {
1908         if (isTopLevelClass())
1909             return null;
1910         String name = getSimpleBinaryName0();
1911         if (name == null) // anonymous class
1912             return &quot;&quot;;
1913         return name;
1914     }
1915 
1916     private native String getSimpleBinaryName0();
1917 
1918     /**
1919      * Returns {@code true} if this is a top level class.  Returns {@code false}
1920      * otherwise.
1921      */
1922     private boolean isTopLevelClass() {
1923         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() == null;
1924     }
1925 
1926     /**
1927      * Returns {@code true} if this is a local class or an anonymous
1928      * class.  Returns {@code false} otherwise.
1929      */
1930     private boolean isLocalOrAnonymousClass() {
1931         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1932         // attribute if and only if it is a local class or an
1933         // anonymous class.
1934         return hasEnclosingMethodInfo();
1935     }
1936 
1937     private boolean hasEnclosingMethodInfo() {
1938         Object[] enclosingInfo = getEnclosingMethod0();
1939         if (enclosingInfo != null) {
1940             EnclosingMethodInfo.validate(enclosingInfo);
1941             return true;
1942         }
1943         return false;
1944     }
1945 
1946     /**
1947      * Returns an array containing {@code Class} objects representing all
1948      * the public classes and interfaces that are members of the class
1949      * represented by this {@code Class} object.  This includes public
1950      * class and interface members inherited from superclasses and public class
1951      * and interface members declared by the class.  This method returns an
1952      * array of length 0 if this {@code Class} object has no public member
1953      * classes or interfaces.  This method also returns an array of length 0 if
1954      * this {@code Class} object represents a primitive type, an array
1955      * class, or void.
1956      *
1957      * @return the array of {@code Class} objects representing the public
1958      *         members of this class
1959      * @throws SecurityException
1960      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1961      *         the caller&#39;s class loader is not the same as or an
1962      *         ancestor of the class loader for the current class and
1963      *         invocation of {@link SecurityManager#checkPackageAccess
1964      *         s.checkPackageAccess()} denies access to the package
1965      *         of this class.
1966      *
1967      * @since 1.1
1968      */
1969     @CallerSensitive
1970     public Class&lt;?&gt;[] getClasses() {
1971         SecurityManager sm = System.getSecurityManager();
1972         if (sm != null) {
1973             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
1974         }
1975 
1976         // Privileged so this implementation can look at DECLARED classes,
1977         // something the caller might not have privilege to do.  The code here
1978         // is allowed to look at DECLARED classes because (1) it does not hand
1979         // out anything other than public members and (2) public member access
1980         // has already been ok&#39;d by the SecurityManager.
1981 
1982         return java.security.AccessController.doPrivileged(
1983             new java.security.PrivilegedAction&lt;&gt;() {
1984                 public Class&lt;?&gt;[] run() {
1985                     List&lt;Class&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();
1986                     Class&lt;?&gt; currentClass = Class.this;
1987                     while (currentClass != null) {
1988                         for (Class&lt;?&gt; m : currentClass.getDeclaredClasses()) {
1989                             if (Modifier.isPublic(m.getModifiers())) {
1990                                 list.add(m);
1991                             }
1992                         }
1993                         currentClass = currentClass.getSuperclass();
1994                     }
1995                     return list.toArray(new Class&lt;?&gt;[0]);
1996                 }
1997             });
1998     }
1999 
2000 
2001     /**
2002      * Returns an array containing {@code Field} objects reflecting all
2003      * the accessible public fields of the class or interface represented by
2004      * this {@code Class} object.
2005      *
2006      * &lt;p&gt; If this {@code Class} object represents a class or interface with
2007      * no accessible public fields, then this method returns an array of length
2008      * 0.
2009      *
2010      * &lt;p&gt; If this {@code Class} object represents a class, then this method
2011      * returns the public fields of the class and of all its superclasses and
2012      * superinterfaces.
2013      *
2014      * &lt;p&gt; If this {@code Class} object represents an interface, then this
2015      * method returns the fields of the interface and of all its
2016      * superinterfaces.
2017      *
2018      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2019      * type, or void, then this method returns an array of length 0.
2020      *
2021      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2022      * particular order.
2023      *
2024      * @return the array of {@code Field} objects representing the
2025      *         public fields
2026      * @throws SecurityException
2027      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2028      *         the caller&#39;s class loader is not the same as or an
2029      *         ancestor of the class loader for the current class and
2030      *         invocation of {@link SecurityManager#checkPackageAccess
2031      *         s.checkPackageAccess()} denies access to the package
2032      *         of this class.
2033      *
2034      * @since 1.1
2035      * @jls 8.2 Class Members
2036      * @jls 8.3 Field Declarations
2037      */
2038     @CallerSensitive
2039     public Field[] getFields() throws SecurityException {
2040         SecurityManager sm = System.getSecurityManager();
2041         if (sm != null) {
2042             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2043         }
2044         return copyFields(privateGetPublicFields());
2045     }
2046 
2047 
2048     /**
2049      * Returns an array containing {@code Method} objects reflecting all the
2050      * public methods of the class or interface represented by this {@code
2051      * Class} object, including those declared by the class or interface and
2052      * those inherited from superclasses and superinterfaces.
2053      *
2054      * &lt;p&gt; If this {@code Class} object represents an array type, then the
2055      * returned array has a {@code Method} object for each of the public
2056      * methods inherited by the array type from {@code Object}. It does not
2057      * contain a {@code Method} object for {@code clone()}.
2058      *
2059      * &lt;p&gt; If this {@code Class} object represents an interface then the
2060      * returned array does not contain any implicitly declared methods from
2061      * {@code Object}. Therefore, if no methods are explicitly declared in
2062      * this interface or any of its superinterfaces then the returned array
2063      * has length 0. (Note that a {@code Class} object which represents a class
2064      * always has public methods, inherited from {@code Object}.)
2065      *
2066      * &lt;p&gt; The returned array never contains methods with names &quot;{@code &lt;init&gt;}&quot;
2067      * or &quot;{@code &lt;clinit&gt;}&quot;.
2068      *
2069      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2070      * particular order.
2071      *
2072      * &lt;p&gt; Generally, the result is computed as with the following 4 step algorithm.
2073      * Let C be the class or interface represented by this {@code Class} object:
2074      * &lt;ol&gt;
2075      * &lt;li&gt; A union of methods is composed of:
2076      *   &lt;ol type=&quot;a&quot;&gt;
2077      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
2078      *        {@link #getDeclaredMethods()} and filtered to include only public
2079      *        methods.&lt;/li&gt;
2080      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
2081      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
2082      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
2083      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
2084      *   &lt;/ol&gt;&lt;/li&gt;
2085      * &lt;li&gt; Union from step 1 is partitioned into subsets of methods with same
2086      *      signature (name, parameter types) and return type.&lt;/li&gt;
2087      * &lt;li&gt; Within each such subset only the most specific methods are selected.
2088      *      Let method M be a method from a set of methods with same signature
2089      *      and return type. M is most specific if there is no such method
2090      *      N != M from the same set, such that N is more specific than M.
2091      *      N is more specific than M if:
2092      *   &lt;ol type=&quot;a&quot;&gt;
2093      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
2094      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
2095      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
2096      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
2097      *        M and N are the same method).&lt;/li&gt;
2098      *   &lt;/ol&gt;&lt;/li&gt;
2099      * &lt;li&gt; The result of this algorithm is the union of all selected methods from
2100      *      step 3.&lt;/li&gt;
2101      * &lt;/ol&gt;
2102      *
2103      * @apiNote There may be more than one method with a particular name
2104      * and parameter types in a class because while the Java language forbids a
2105      * class to declare multiple methods with the same signature but different
2106      * return types, the Java virtual machine does not.  This
2107      * increased flexibility in the virtual machine can be used to
2108      * implement various language features.  For example, covariant
2109      * returns can be implemented with {@linkplain
2110      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2111      * method and the overriding method would have the same
2112      * signature but different return types.
2113      *
2114      * @return the array of {@code Method} objects representing the
2115      *         public methods of this class
2116      * @throws SecurityException
2117      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2118      *         the caller&#39;s class loader is not the same as or an
2119      *         ancestor of the class loader for the current class and
2120      *         invocation of {@link SecurityManager#checkPackageAccess
2121      *         s.checkPackageAccess()} denies access to the package
2122      *         of this class.
2123      *
2124      * @jls 8.2 Class Members
2125      * @jls 8.4 Method Declarations
2126      * @since 1.1
2127      */
2128     @CallerSensitive
2129     public Method[] getMethods() throws SecurityException {
2130         SecurityManager sm = System.getSecurityManager();
2131         if (sm != null) {
2132             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2133         }
2134         return copyMethods(privateGetPublicMethods());
2135     }
2136 
2137 
2138     /**
2139      * Returns an array containing {@code Constructor} objects reflecting
2140      * all the public constructors of the class represented by this
2141      * {@code Class} object.  An array of length 0 is returned if the
2142      * class has no public constructors, or if the class is an array class, or
2143      * if the class reflects a primitive type or void.
2144      *
2145      * @apiNote
2146      * While this method returns an array of {@code
2147      * Constructor&lt;T&gt;} objects (that is an array of constructors from
2148      * this class), the return type of this method is {@code
2149      * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
2150      * might be expected.  This less informative return type is
2151      * necessary since after being returned from this method, the
2152      * array could be modified to hold {@code Constructor} objects for
2153      * different classes, which would violate the type guarantees of
2154      * {@code Constructor&lt;T&gt;[]}.
2155      *
2156      * @return the array of {@code Constructor} objects representing the
2157      *         public constructors of this class
2158      * @throws SecurityException
2159      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2160      *         the caller&#39;s class loader is not the same as or an
2161      *         ancestor of the class loader for the current class and
2162      *         invocation of {@link SecurityManager#checkPackageAccess
2163      *         s.checkPackageAccess()} denies access to the package
2164      *         of this class.
2165      *
2166      * @since 1.1
2167      */
2168     @CallerSensitive
2169     public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
2170         SecurityManager sm = System.getSecurityManager();
2171         if (sm != null) {
2172             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2173         }
2174         return copyConstructors(privateGetDeclaredConstructors(true));
2175     }
2176 
2177 
2178     /**
2179      * Returns a {@code Field} object that reflects the specified public member
2180      * field of the class or interface represented by this {@code Class}
2181      * object. The {@code name} parameter is a {@code String} specifying the
2182      * simple name of the desired field.
2183      *
2184      * &lt;p&gt; The field to be reflected is determined by the algorithm that
2185      * follows.  Let C be the class or interface represented by this {@code Class} object:
2186      *
2187      * &lt;OL&gt;
2188      * &lt;LI&gt; If C declares a public field with the name specified, that is the
2189      *      field to be reflected.&lt;/LI&gt;
2190      * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
2191      *      recursively to each direct superinterface of C. The direct
2192      *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
2193      * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
2194      *      superclass S, then this algorithm is invoked recursively upon S.
2195      *      If C has no superclass, then a {@code NoSuchFieldException}
2196      *      is thrown.&lt;/LI&gt;
2197      * &lt;/OL&gt;
2198      *
2199      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2200      * method does not find the {@code length} field of the array type.
2201      *
2202      * @param name the field name
2203      * @return the {@code Field} object of this class specified by
2204      *         {@code name}
2205      * @throws NoSuchFieldException if a field with the specified name is
2206      *         not found.
2207      * @throws NullPointerException if {@code name} is {@code null}
2208      * @throws SecurityException
2209      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2210      *         the caller&#39;s class loader is not the same as or an
2211      *         ancestor of the class loader for the current class and
2212      *         invocation of {@link SecurityManager#checkPackageAccess
2213      *         s.checkPackageAccess()} denies access to the package
2214      *         of this class.
2215      *
2216      * @since 1.1
2217      * @jls 8.2 Class Members
2218      * @jls 8.3 Field Declarations
2219      */
2220     @CallerSensitive
2221     public Field getField(String name)
2222         throws NoSuchFieldException, SecurityException {
2223         Objects.requireNonNull(name);
2224         SecurityManager sm = System.getSecurityManager();
2225         if (sm != null) {
2226             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2227         }
2228         Field field = getField0(name);
2229         if (field == null) {
2230             throw new NoSuchFieldException(name);
2231         }
2232         return getReflectionFactory().copyField(field);
2233     }
2234 
2235 
2236     /**
2237      * Returns a {@code Method} object that reflects the specified public
2238      * member method of the class or interface represented by this
2239      * {@code Class} object. The {@code name} parameter is a
2240      * {@code String} specifying the simple name of the desired method. The
2241      * {@code parameterTypes} parameter is an array of {@code Class}
2242      * objects that identify the method&#39;s formal parameter types, in declared
2243      * order. If {@code parameterTypes} is {@code null}, it is
2244      * treated as if it were an empty array.
2245      *
2246      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2247      * method finds any public method inherited by the array type from
2248      * {@code Object} except method {@code clone()}.
2249      *
2250      * &lt;p&gt; If this {@code Class} object represents an interface then this
2251      * method does not find any implicitly declared method from
2252      * {@code Object}. Therefore, if no methods are explicitly declared in
2253      * this interface or any of its superinterfaces, then this method does not
2254      * find any method.
2255      *
2256      * &lt;p&gt; This method does not find any method with name &quot;{@code &lt;init&gt;}&quot; or
2257      * &quot;{@code &lt;clinit&gt;}&quot;.
2258      *
2259      * &lt;p&gt; Generally, the method to be reflected is determined by the 4 step
2260      * algorithm that follows.
2261      * Let C be the class or interface represented by this {@code Class} object:
2262      * &lt;ol&gt;
2263      * &lt;li&gt; A union of methods is composed of:
2264      *   &lt;ol type=&quot;a&quot;&gt;
2265      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
2266      *        {@link #getDeclaredMethods()} and filtered to include only public
2267      *        methods that match given {@code name} and {@code parameterTypes}&lt;/li&gt;
2268      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
2269      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
2270      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
2271      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
2272      *   &lt;/ol&gt;&lt;/li&gt;
2273      * &lt;li&gt; This union is partitioned into subsets of methods with same
2274      *      return type (the selection of methods from step 1 also guarantees that
2275      *      they have the same method name and parameter types).&lt;/li&gt;
2276      * &lt;li&gt; Within each such subset only the most specific methods are selected.
2277      *      Let method M be a method from a set of methods with same VM
2278      *      signature (return type, name, parameter types).
2279      *      M is most specific if there is no such method N != M from the same
2280      *      set, such that N is more specific than M. N is more specific than M
2281      *      if:
2282      *   &lt;ol type=&quot;a&quot;&gt;
2283      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
2284      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
2285      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
2286      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
2287      *        M and N are the same method).&lt;/li&gt;
2288      *   &lt;/ol&gt;&lt;/li&gt;
2289      * &lt;li&gt; The result of this algorithm is chosen arbitrarily from the methods
2290      *      with most specific return type among all selected methods from step 3.
2291      *      Let R be a return type of a method M from the set of all selected methods
2292      *      from step 3. M is a method with most specific return type if there is
2293      *      no such method N != M from the same set, having return type S != R,
2294      *      such that S is a subtype of R as determined by
2295      *      R.class.{@link #isAssignableFrom}(S.class).
2296      * &lt;/ol&gt;
2297      *
2298      * @apiNote There may be more than one method with matching name and
2299      * parameter types in a class because while the Java language forbids a
2300      * class to declare multiple methods with the same signature but different
2301      * return types, the Java virtual machine does not.  This
2302      * increased flexibility in the virtual machine can be used to
2303      * implement various language features.  For example, covariant
2304      * returns can be implemented with {@linkplain
2305      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2306      * method and the overriding method would have the same
2307      * signature but different return types. This method would return the
2308      * overriding method as it would have a more specific return type.
2309      *
2310      * @param name the name of the method
2311      * @param parameterTypes the list of parameters
2312      * @return the {@code Method} object that matches the specified
2313      *         {@code name} and {@code parameterTypes}
2314      * @throws NoSuchMethodException if a matching method is not found
2315      *         or if the name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot;.
2316      * @throws NullPointerException if {@code name} is {@code null}
2317      * @throws SecurityException
2318      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2319      *         the caller&#39;s class loader is not the same as or an
2320      *         ancestor of the class loader for the current class and
2321      *         invocation of {@link SecurityManager#checkPackageAccess
2322      *         s.checkPackageAccess()} denies access to the package
2323      *         of this class.
2324      *
2325      * @jls 8.2 Class Members
2326      * @jls 8.4 Method Declarations
2327      * @since 1.1
2328      */
2329     @CallerSensitive
2330     public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)
2331         throws NoSuchMethodException, SecurityException {
2332         Objects.requireNonNull(name);
2333         SecurityManager sm = System.getSecurityManager();
2334         if (sm != null) {
2335             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2336         }
2337         Method method = getMethod0(name, parameterTypes);
2338         if (method == null) {
2339             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2340         }
2341         return getReflectionFactory().copyMethod(method);
2342     }
2343 
2344     /**
2345      * Returns a {@code Constructor} object that reflects the specified
2346      * public constructor of the class represented by this {@code Class}
2347      * object. The {@code parameterTypes} parameter is an array of
2348      * {@code Class} objects that identify the constructor&#39;s formal
2349      * parameter types, in declared order.
2350      *
2351      * If this {@code Class} object represents an inner class
2352      * declared in a non-static context, the formal parameter types
2353      * include the explicit enclosing instance as the first parameter.
2354      *
2355      * &lt;p&gt; The constructor to reflect is the public constructor of the class
2356      * represented by this {@code Class} object whose formal parameter
2357      * types match those specified by {@code parameterTypes}.
2358      *
2359      * @param parameterTypes the parameter array
2360      * @return the {@code Constructor} object of the public constructor that
2361      *         matches the specified {@code parameterTypes}
2362      * @throws NoSuchMethodException if a matching method is not found.
2363      * @throws SecurityException
2364      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2365      *         the caller&#39;s class loader is not the same as or an
2366      *         ancestor of the class loader for the current class and
2367      *         invocation of {@link SecurityManager#checkPackageAccess
2368      *         s.checkPackageAccess()} denies access to the package
2369      *         of this class.
2370      *
2371      * @since 1.1
2372      */
2373     @CallerSensitive
2374     public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)
2375         throws NoSuchMethodException, SecurityException
2376     {
2377         SecurityManager sm = System.getSecurityManager();
2378         if (sm != null) {
2379             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2380         }
2381         return getReflectionFactory().copyConstructor(
2382             getConstructor0(parameterTypes, Member.PUBLIC));
2383     }
2384 
2385 
2386     /**
2387      * Returns an array of {@code Class} objects reflecting all the
2388      * classes and interfaces declared as members of the class represented by
2389      * this {@code Class} object. This includes public, protected, default
2390      * (package) access, and private classes and interfaces declared by the
2391      * class, but excludes inherited classes and interfaces.  This method
2392      * returns an array of length 0 if the class declares no classes or
2393      * interfaces as members, or if this {@code Class} object represents a
2394      * primitive type, an array class, or void.
2395      *
2396      * @return the array of {@code Class} objects representing all the
2397      *         declared members of this class
2398      * @throws SecurityException
2399      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2400      *         following conditions is met:
2401      *
2402      *         &lt;ul&gt;
2403      *
2404      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
2405      *         class loader of this class and invocation of
2406      *         {@link SecurityManager#checkPermission
2407      *         s.checkPermission} method with
2408      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2409      *         denies access to the declared classes within this class
2410      *
2411      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
2412      *         ancestor of the class loader for the current class and
2413      *         invocation of {@link SecurityManager#checkPackageAccess
2414      *         s.checkPackageAccess()} denies access to the package
2415      *         of this class
2416      *
2417      *         &lt;/ul&gt;
2418      *
2419      * @since 1.1
2420      */
2421     @CallerSensitive
2422     public Class&lt;?&gt;[] getDeclaredClasses() throws SecurityException {
2423         SecurityManager sm = System.getSecurityManager();
2424         if (sm != null) {
2425             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), false);
2426         }
2427         return getDeclaredClasses0();
2428     }
2429 
2430 
2431     /**
2432      * Returns an array of {@code Field} objects reflecting all the fields
2433      * declared by the class or interface represented by this
2434      * {@code Class} object. This includes public, protected, default
2435      * (package) access, and private fields, but excludes inherited fields.
2436      *
2437      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2438      * declared fields, then this method returns an array of length 0.
2439      *
2440      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2441      * type, or void, then this method returns an array of length 0.
2442      *
2443      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2444      * particular order.
2445      *
2446      * @return  the array of {@code Field} objects representing all the
2447      *          declared fields of this class
2448      * @throws  SecurityException
2449      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2450      *          following conditions is met:
2451      *
2452      *          &lt;ul&gt;
2453      *
2454      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2455      *          class loader of this class and invocation of
2456      *          {@link SecurityManager#checkPermission
2457      *          s.checkPermission} method with
2458      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2459      *          denies access to the declared fields within this class
2460      *
2461      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2462      *          ancestor of the class loader for the current class and
2463      *          invocation of {@link SecurityManager#checkPackageAccess
2464      *          s.checkPackageAccess()} denies access to the package
2465      *          of this class
2466      *
2467      *          &lt;/ul&gt;
2468      *
2469      * @since 1.1
2470      * @jls 8.2 Class Members
2471      * @jls 8.3 Field Declarations
2472      */
2473     @CallerSensitive
2474     public Field[] getDeclaredFields() throws SecurityException {
2475         SecurityManager sm = System.getSecurityManager();
2476         if (sm != null) {
2477             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2478         }
2479         return copyFields(privateGetDeclaredFields(false));
2480     }
2481 
2482     /**
2483      * {@preview Associated with records, a preview feature of the Java language.
2484      *
2485      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
2486      *           feature of the Java language. Preview features
2487      *           may be removed in a future release, or upgraded to permanent
2488      *           features of the Java language.}
2489      *
2490      * Returns an array of {@code RecordComponent} objects representing all the
2491      * record components of this record class, or {@code null} if this class is
2492      * not a record class.
2493      *
2494      * &lt;p&gt; The components are returned in the same order that they are declared
2495      * in the record header. The array is empty if this record class has no
2496      * components. If the class is not a record class, that is {@link
2497      * #isRecord()} returns {@code false}, then this method returns {@code null}.
2498      * Conversely, if {@link #isRecord()} returns {@code true}, then this method
2499      * returns a non-null value.
2500      *
2501      * @return  An array of {@code RecordComponent} objects representing all the
2502      *          record components of this record class, or {@code null} if this
2503      *          class is not a record class
2504      * @throws  SecurityException
2505      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2506      *          following conditions is met:
2507      *
2508      *          &lt;ul&gt;
2509      *
2510      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2511      *          class loader of this class and invocation of
2512      *          {@link SecurityManager#checkPermission
2513      *          s.checkPermission} method with
2514      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2515      *          denies access to the declared methods within this class
2516      *
2517      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2518      *          ancestor of the class loader for the current class and
2519      *          invocation of {@link SecurityManager#checkPackageAccess
2520      *          s.checkPackageAccess()} denies access to the package
2521      *          of this class
2522      *
2523      *          &lt;/ul&gt;
2524      *
2525      * @jls 8.10 Record Types
2526      * @since 14
2527      */
2528     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
2529                                  essentialAPI=false)
2530     @SuppressWarnings(&quot;preview&quot;)
2531     @CallerSensitive
2532     public RecordComponent[] getRecordComponents() {
2533         SecurityManager sm = System.getSecurityManager();
2534         if (sm != null) {
2535             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2536         }
2537         if (!isRecord()) {
2538             return null;
2539         }
2540         RecordComponent[] recordComponents = getRecordComponents0();
2541         if (recordComponents == null) {
2542             return new RecordComponent[0];
2543         }
2544         return recordComponents;
2545     }
2546 
2547     /**
2548      * Returns an array containing {@code Method} objects reflecting all the
2549      * declared methods of the class or interface represented by this {@code
2550      * Class} object, including public, protected, default (package)
2551      * access, and private methods, but excluding inherited methods.
2552      *
2553      * &lt;p&gt; If this {@code Class} object represents a type that has multiple
2554      * declared methods with the same name and parameter types, but different
2555      * return types, then the returned array has a {@code Method} object for
2556      * each such method.
2557      *
2558      * &lt;p&gt; If this {@code Class} object represents a type that has a class
2559      * initialization method {@code &lt;clinit&gt;}, then the returned array does
2560      * &lt;em&gt;not&lt;/em&gt; have a corresponding {@code Method} object.
2561      *
2562      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2563      * declared methods, then the returned array has length 0.
2564      *
2565      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2566      * type, or void, then the returned array has length 0.
2567      *
2568      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2569      * particular order.
2570      *
2571      * @return  the array of {@code Method} objects representing all the
2572      *          declared methods of this class
2573      * @throws  SecurityException
2574      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2575      *          following conditions is met:
2576      *
2577      *          &lt;ul&gt;
2578      *
2579      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2580      *          class loader of this class and invocation of
2581      *          {@link SecurityManager#checkPermission
2582      *          s.checkPermission} method with
2583      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2584      *          denies access to the declared methods within this class
2585      *
2586      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2587      *          ancestor of the class loader for the current class and
2588      *          invocation of {@link SecurityManager#checkPackageAccess
2589      *          s.checkPackageAccess()} denies access to the package
2590      *          of this class
2591      *
2592      *          &lt;/ul&gt;
2593      *
2594      * @jls 8.2 Class Members
2595      * @jls 8.4 Method Declarations
2596      * @since 1.1
2597      */
2598     @CallerSensitive
2599     public Method[] getDeclaredMethods() throws SecurityException {
2600         SecurityManager sm = System.getSecurityManager();
2601         if (sm != null) {
2602             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2603         }
2604         return copyMethods(privateGetDeclaredMethods(false));
2605     }
2606 
2607 
2608     /**
2609      * Returns an array of {@code Constructor} objects reflecting all the
2610      * constructors declared by the class represented by this
2611      * {@code Class} object. These are public, protected, default
2612      * (package) access, and private constructors.  The elements in the array
2613      * returned are not sorted and are not in any particular order.  If the
2614      * class has a default constructor, it is included in the returned array.
2615      * This method returns an array of length 0 if this {@code Class}
2616      * object represents an interface, a primitive type, an array class, or
2617      * void.
2618      *
2619      * &lt;p&gt; See &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
2620      * section {@jls 8.2}.
2621      *
2622      * @return  the array of {@code Constructor} objects representing all the
2623      *          declared constructors of this class
2624      * @throws  SecurityException
2625      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2626      *          following conditions is met:
2627      *
2628      *          &lt;ul&gt;
2629      *
2630      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2631      *          class loader of this class and invocation of
2632      *          {@link SecurityManager#checkPermission
2633      *          s.checkPermission} method with
2634      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2635      *          denies access to the declared constructors within this class
2636      *
2637      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2638      *          ancestor of the class loader for the current class and
2639      *          invocation of {@link SecurityManager#checkPackageAccess
2640      *          s.checkPackageAccess()} denies access to the package
2641      *          of this class
2642      *
2643      *          &lt;/ul&gt;
2644      *
2645      * @since 1.1
2646      */
2647     @CallerSensitive
2648     public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException {
2649         SecurityManager sm = System.getSecurityManager();
2650         if (sm != null) {
2651             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2652         }
2653         return copyConstructors(privateGetDeclaredConstructors(false));
2654     }
2655 
2656 
2657     /**
2658      * Returns a {@code Field} object that reflects the specified declared
2659      * field of the class or interface represented by this {@code Class}
2660      * object. The {@code name} parameter is a {@code String} that specifies
2661      * the simple name of the desired field.
2662      *
2663      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2664      * method does not find the {@code length} field of the array type.
2665      *
2666      * @param name the name of the field
2667      * @return  the {@code Field} object for the specified field in this
2668      *          class
2669      * @throws  NoSuchFieldException if a field with the specified name is
2670      *          not found.
2671      * @throws  NullPointerException if {@code name} is {@code null}
2672      * @throws  SecurityException
2673      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2674      *          following conditions is met:
2675      *
2676      *          &lt;ul&gt;
2677      *
2678      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2679      *          class loader of this class and invocation of
2680      *          {@link SecurityManager#checkPermission
2681      *          s.checkPermission} method with
2682      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2683      *          denies access to the declared field
2684      *
2685      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2686      *          ancestor of the class loader for the current class and
2687      *          invocation of {@link SecurityManager#checkPackageAccess
2688      *          s.checkPackageAccess()} denies access to the package
2689      *          of this class
2690      *
2691      *          &lt;/ul&gt;
2692      *
2693      * @since 1.1
2694      * @jls 8.2 Class Members
2695      * @jls 8.3 Field Declarations
2696      */
2697     @CallerSensitive
2698     public Field getDeclaredField(String name)
2699         throws NoSuchFieldException, SecurityException {
2700         Objects.requireNonNull(name);
2701         SecurityManager sm = System.getSecurityManager();
2702         if (sm != null) {
2703             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2704         }
2705         Field field = searchFields(privateGetDeclaredFields(false), name);
2706         if (field == null) {
2707             throw new NoSuchFieldException(name);
2708         }
2709         return getReflectionFactory().copyField(field);
2710     }
2711 
2712 
2713     /**
2714      * Returns a {@code Method} object that reflects the specified
2715      * declared method of the class or interface represented by this
2716      * {@code Class} object. The {@code name} parameter is a
2717      * {@code String} that specifies the simple name of the desired
2718      * method, and the {@code parameterTypes} parameter is an array of
2719      * {@code Class} objects that identify the method&#39;s formal parameter
2720      * types, in declared order.  If more than one method with the same
2721      * parameter types is declared in a class, and one of these methods has a
2722      * return type that is more specific than any of the others, that method is
2723      * returned; otherwise one of the methods is chosen arbitrarily.  If the
2724      * name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot; a {@code NoSuchMethodException}
2725      * is raised.
2726      *
2727      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2728      * method does not find the {@code clone()} method.
2729      *
2730      * @param name the name of the method
2731      * @param parameterTypes the parameter array
2732      * @return  the {@code Method} object for the method of this class
2733      *          matching the specified name and parameters
2734      * @throws  NoSuchMethodException if a matching method is not found.
2735      * @throws  NullPointerException if {@code name} is {@code null}
2736      * @throws  SecurityException
2737      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2738      *          following conditions is met:
2739      *
2740      *          &lt;ul&gt;
2741      *
2742      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2743      *          class loader of this class and invocation of
2744      *          {@link SecurityManager#checkPermission
2745      *          s.checkPermission} method with
2746      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2747      *          denies access to the declared method
2748      *
2749      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2750      *          ancestor of the class loader for the current class and
2751      *          invocation of {@link SecurityManager#checkPackageAccess
2752      *          s.checkPackageAccess()} denies access to the package
2753      *          of this class
2754      *
2755      *          &lt;/ul&gt;
2756      *
2757      * @jls 8.2 Class Members
2758      * @jls 8.4 Method Declarations
2759      * @since 1.1
2760      */
2761     @CallerSensitive
2762     public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)
2763         throws NoSuchMethodException, SecurityException {
2764         Objects.requireNonNull(name);
2765         SecurityManager sm = System.getSecurityManager();
2766         if (sm != null) {
2767             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2768         }
2769         Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);
2770         if (method == null) {
2771             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2772         }
2773         return getReflectionFactory().copyMethod(method);
2774     }
2775 
2776     /**
2777      * Returns the list of {@code Method} objects for the declared public
2778      * methods of this class or interface that have the specified method name
2779      * and parameter types.
2780      *
2781      * @param name the name of the method
2782      * @param parameterTypes the parameter array
2783      * @return the list of {@code Method} objects for the public methods of
2784      *         this class matching the specified name and parameters
2785      */
2786     List&lt;Method&gt; getDeclaredPublicMethods(String name, Class&lt;?&gt;... parameterTypes) {
2787         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
2788         ReflectionFactory factory = getReflectionFactory();
2789         List&lt;Method&gt; result = new ArrayList&lt;&gt;();
2790         for (Method method : methods) {
2791             if (method.getName().equals(name)
2792                 &amp;&amp; Arrays.equals(
2793                     factory.getExecutableSharedParameterTypes(method),
2794                     parameterTypes)) {
2795                 result.add(factory.copyMethod(method));
2796             }
2797         }
2798         return result;
2799     }
2800 
2801     /**
2802      * Returns a {@code Constructor} object that reflects the specified
2803      * constructor of the class or interface represented by this
2804      * {@code Class} object.  The {@code parameterTypes} parameter is
2805      * an array of {@code Class} objects that identify the constructor&#39;s
2806      * formal parameter types, in declared order.
2807      *
2808      * If this {@code Class} object represents an inner class
2809      * declared in a non-static context, the formal parameter types
2810      * include the explicit enclosing instance as the first parameter.
2811      *
2812      * @param parameterTypes the parameter array
2813      * @return  The {@code Constructor} object for the constructor with the
2814      *          specified parameter list
2815      * @throws  NoSuchMethodException if a matching method is not found.
2816      * @throws  SecurityException
2817      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2818      *          following conditions is met:
2819      *
2820      *          &lt;ul&gt;
2821      *
2822      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2823      *          class loader of this class and invocation of
2824      *          {@link SecurityManager#checkPermission
2825      *          s.checkPermission} method with
2826      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2827      *          denies access to the declared constructor
2828      *
2829      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2830      *          ancestor of the class loader for the current class and
2831      *          invocation of {@link SecurityManager#checkPackageAccess
2832      *          s.checkPackageAccess()} denies access to the package
2833      *          of this class
2834      *
2835      *          &lt;/ul&gt;
2836      *
2837      * @since 1.1
2838      */
2839     @CallerSensitive
2840     public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)
2841         throws NoSuchMethodException, SecurityException
2842     {
2843         SecurityManager sm = System.getSecurityManager();
2844         if (sm != null) {
2845             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2846         }
2847 
2848         return getReflectionFactory().copyConstructor(
2849             getConstructor0(parameterTypes, Member.DECLARED));
2850     }
2851 
2852     /**
2853      * Finds a resource with a given name.
2854      *
2855      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2856      * will attempt to find the resource in the module. This is done by
2857      * delegating to the module&#39;s class loader {@link
2858      * ClassLoader#findResource(String,String) findResource(String,String)}
2859      * method, invoking it with the module name and the absolute name of the
2860      * resource. Resources in named modules are subject to the rules for
2861      * encapsulation specified in the {@code Module} {@link
2862      * Module#getResourceAsStream getResourceAsStream} method and so this
2863      * method returns {@code null} when the resource is a
2864      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2865      * caller&#39;s module.
2866      *
2867      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2868      * searching resources associated with a given class are implemented by the
2869      * defining {@linkplain ClassLoader class loader} of the class.  This method
2870      * delegates to this {@code Class} object&#39;s class loader.
2871      * If this {@code Class} object was loaded by the bootstrap class loader,
2872      * the method delegates to {@link ClassLoader#getSystemResourceAsStream}.
2873      *
2874      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2875      * given resource name using this algorithm:
2876      *
2877      * &lt;ul&gt;
2878      *
2879      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2880      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2881      * portion of the {@code name} following the {@code &#39;/&#39;}.
2882      *
2883      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2884      *
2885      * &lt;blockquote&gt;
2886      *   {@code modified_package_name/name}
2887      * &lt;/blockquote&gt;
2888      *
2889      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2890      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2891      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2892      *
2893      * &lt;/ul&gt;
2894      *
2895      * @param  name name of the desired resource
2896      * @return  A {@link java.io.InputStream} object; {@code null} if no
2897      *          resource with this name is found, the resource is in a package
2898      *          that is not {@linkplain Module#isOpen(String, Module) open} to at
2899      *          least the caller module, or access to the resource is denied
2900      *          by the security manager.
2901      * @throws  NullPointerException If {@code name} is {@code null}
2902      *
2903      * @see Module#getResourceAsStream(String)
2904      * @since  1.1
2905      * @revised 9
2906      * @spec JPMS
2907      */
2908     @CallerSensitive
2909     public InputStream getResourceAsStream(String name) {
2910         name = resolveName(name);
2911 
2912         Module thisModule = getModule();
2913         if (thisModule.isNamed()) {
2914             // check if resource can be located by caller
2915             if (Resources.canEncapsulate(name)
2916                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2917                 return null;
2918             }
2919 
2920             // resource not encapsulated or in package open to caller
2921             String mn = thisModule.getName();
2922             ClassLoader cl = getClassLoader0();
2923             try {
2924 
2925                 // special-case built-in class loaders to avoid the
2926                 // need for a URL connection
2927                 if (cl == null) {
2928                     return BootLoader.findResourceAsStream(mn, name);
2929                 } else if (cl instanceof BuiltinClassLoader) {
2930                     return ((BuiltinClassLoader) cl).findResourceAsStream(mn, name);
2931                 } else {
2932                     URL url = cl.findResource(mn, name);
2933                     return (url != null) ? url.openStream() : null;
2934                 }
2935 
2936             } catch (IOException | SecurityException e) {
2937                 return null;
2938             }
2939         }
2940 
2941         // unnamed module
2942         ClassLoader cl = getClassLoader0();
2943         if (cl == null) {
2944             return ClassLoader.getSystemResourceAsStream(name);
2945         } else {
2946             return cl.getResourceAsStream(name);
2947         }
2948     }
2949 
2950     /**
2951      * Finds a resource with a given name.
2952      *
2953      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2954      * will attempt to find the resource in the module. This is done by
2955      * delegating to the module&#39;s class loader {@link
2956      * ClassLoader#findResource(String,String) findResource(String,String)}
2957      * method, invoking it with the module name and the absolute name of the
2958      * resource. Resources in named modules are subject to the rules for
2959      * encapsulation specified in the {@code Module} {@link
2960      * Module#getResourceAsStream getResourceAsStream} method and so this
2961      * method returns {@code null} when the resource is a
2962      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2963      * caller&#39;s module.
2964      *
2965      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2966      * searching resources associated with a given class are implemented by the
2967      * defining {@linkplain ClassLoader class loader} of the class.  This method
2968      * delegates to this {@code Class} object&#39;s class loader.
2969      * If this {@code Class} object was loaded by the bootstrap class loader,
2970      * the method delegates to {@link ClassLoader#getSystemResource}.
2971      *
2972      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2973      * given resource name using this algorithm:
2974      *
2975      * &lt;ul&gt;
2976      *
2977      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2978      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2979      * portion of the {@code name} following the {@code &#39;/&#39;}.
2980      *
2981      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2982      *
2983      * &lt;blockquote&gt;
2984      *   {@code modified_package_name/name}
2985      * &lt;/blockquote&gt;
2986      *
2987      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2988      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2989      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2990      *
2991      * &lt;/ul&gt;
2992      *
2993      * @param  name name of the desired resource
2994      * @return A {@link java.net.URL} object; {@code null} if no resource with
2995      *         this name is found, the resource cannot be located by a URL, the
2996      *         resource is in a package that is not
2997      *         {@linkplain Module#isOpen(String, Module) open} to at least the caller
2998      *         module, or access to the resource is denied by the security
2999      *         manager.
3000      * @throws NullPointerException If {@code name} is {@code null}
3001      * @since  1.1
3002      * @revised 9
3003      * @spec JPMS
3004      */
3005     @CallerSensitive
3006     public URL getResource(String name) {
3007         name = resolveName(name);
3008 
3009         Module thisModule = getModule();
3010         if (thisModule.isNamed()) {
3011             // check if resource can be located by caller
3012             if (Resources.canEncapsulate(name)
3013                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
3014                 return null;
3015             }
3016 
3017             // resource not encapsulated or in package open to caller
3018             String mn = thisModule.getName();
3019             ClassLoader cl = getClassLoader0();
3020             try {
3021                 if (cl == null) {
3022                     return BootLoader.findResource(mn, name);
3023                 } else {
3024                     return cl.findResource(mn, name);
3025                 }
3026             } catch (IOException ioe) {
3027                 return null;
3028             }
3029         }
3030 
3031         // unnamed module
3032         ClassLoader cl = getClassLoader0();
3033         if (cl == null) {
3034             return ClassLoader.getSystemResource(name);
3035         } else {
3036             return cl.getResource(name);
3037         }
3038     }
3039 
3040     /**
3041      * Returns true if a resource with the given name can be located by the
3042      * given caller. All resources in a module can be located by code in
3043      * the module. For other callers, then the package needs to be open to
3044      * the caller.
3045      */
3046     private boolean isOpenToCaller(String name, Class&lt;?&gt; caller) {
3047         // assert getModule().isNamed();
3048         Module thisModule = getModule();
3049         Module callerModule = (caller != null) ? caller.getModule() : null;
3050         if (callerModule != thisModule) {
3051             String pn = Resources.toPackageName(name);
3052             if (thisModule.getDescriptor().packages().contains(pn)) {
3053                 if (callerModule == null &amp;&amp; !thisModule.isOpen(pn)) {
3054                     // no caller, package not open
3055                     return false;
3056                 }
3057                 if (!thisModule.isOpen(pn, callerModule)) {
3058                     // package not open to caller
3059                     return false;
3060                 }
3061             }
3062         }
3063         return true;
3064     }
3065 
3066 
3067     /** protection domain returned when the internal domain is null */
3068     private static java.security.ProtectionDomain allPermDomain;
3069 
3070     /**
3071      * Returns the {@code ProtectionDomain} of this class.  If there is a
3072      * security manager installed, this method first calls the security
3073      * manager&#39;s {@code checkPermission} method with a
3074      * {@code RuntimePermission(&quot;getProtectionDomain&quot;)} permission to
3075      * ensure it&#39;s ok to get the
3076      * {@code ProtectionDomain}.
3077      *
3078      * @return the ProtectionDomain of this class
3079      *
3080      * @throws SecurityException
3081      *        if a security manager exists and its
3082      *        {@code checkPermission} method doesn&#39;t allow
3083      *        getting the ProtectionDomain.
3084      *
3085      * @see java.security.ProtectionDomain
3086      * @see SecurityManager#checkPermission
3087      * @see java.lang.RuntimePermission
3088      * @since 1.2
3089      */
3090     public java.security.ProtectionDomain getProtectionDomain() {
3091         SecurityManager sm = System.getSecurityManager();
3092         if (sm != null) {
3093             sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
3094         }
3095         return protectionDomain();
3096     }
3097 
3098     // package-private
3099     java.security.ProtectionDomain protectionDomain() {
3100         java.security.ProtectionDomain pd = getProtectionDomain0();
3101         if (pd == null) {
3102             if (allPermDomain == null) {
3103                 java.security.Permissions perms =
3104                     new java.security.Permissions();
3105                 perms.add(SecurityConstants.ALL_PERMISSION);
3106                 allPermDomain =
3107                     new java.security.ProtectionDomain(null, perms);
3108             }
3109             pd = allPermDomain;
3110         }
3111         return pd;
3112     }
3113 
3114     /**
3115      * Returns the ProtectionDomain of this class.
3116      */
3117     private native java.security.ProtectionDomain getProtectionDomain0();
3118 
3119     /*
3120      * Return the Virtual Machine&#39;s Class object for the named
3121      * primitive type.
3122      */
3123     static native Class&lt;?&gt; getPrimitiveClass(String name);
3124 
3125     /*
3126      * Check if client is allowed to access members.  If access is denied,
3127      * throw a SecurityException.
3128      *
3129      * This method also enforces package access.
3130      *
3131      * &lt;p&gt; Default policy: allow all clients access with normal Java access
3132      * control.
3133      *
3134      * &lt;p&gt; NOTE: should only be called if a SecurityManager is installed
3135      */
3136     private void checkMemberAccess(SecurityManager sm, int which,
3137                                    Class&lt;?&gt; caller, boolean checkProxyInterfaces) {
3138         /* Default policy allows access to all {@link Member#PUBLIC} members,
3139          * as well as access to classes that have the same class loader as the caller.
3140          * In all other cases, it requires RuntimePermission(&quot;accessDeclaredMembers&quot;)
3141          * permission.
3142          */
3143         final ClassLoader ccl = ClassLoader.getClassLoader(caller);
3144         if (which != Member.PUBLIC) {
3145             final ClassLoader cl = getClassLoader0();
3146             if (ccl != cl) {
3147                 sm.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3148             }
3149         }
3150         this.checkPackageAccess(sm, ccl, checkProxyInterfaces);
3151     }
3152 
3153     /*
3154      * Checks if a client loaded in ClassLoader ccl is allowed to access this
3155      * class under the current package access policy. If access is denied,
3156      * throw a SecurityException.
3157      *
3158      * NOTE: this method should only be called if a SecurityManager is active
3159      */
3160     private void checkPackageAccess(SecurityManager sm, final ClassLoader ccl,
3161                                     boolean checkProxyInterfaces) {
3162         final ClassLoader cl = getClassLoader0();
3163 
3164         if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {
3165             String pkg = this.getPackageName();
3166             if (pkg != null &amp;&amp; !pkg.isEmpty()) {
3167                 // skip the package access check on a proxy class in default proxy package
3168                 if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {
3169                     sm.checkPackageAccess(pkg);
3170                 }
3171             }
3172         }
3173         // check package access on the proxy interfaces
3174         if (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(this)) {
3175             ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());
3176         }
3177     }
3178 
3179     /**
3180      * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
3181      * if name is absolute
3182      */
3183     private String resolveName(String name) {
3184         if (!name.startsWith(&quot;/&quot;)) {
3185             Class&lt;?&gt; c = isArray() ? elementType() : this;
3186             String baseName = c.getPackageName();
3187             if (baseName != null &amp;&amp; !baseName.isEmpty()) {
3188                 name = baseName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; + name;
3189             }
3190         } else {
3191             name = name.substring(1);
3192         }
3193         return name;
3194     }
3195 
3196     /**
3197      * Atomic operations support.
3198      */
3199     private static class Atomic {
3200         // initialize Unsafe machinery here, since we need to call Class.class instance method
3201         // and have to avoid calling it in the static initializer of the Class class...
3202         private static final Unsafe unsafe = Unsafe.getUnsafe();
3203         // offset of Class.reflectionData instance field
3204         private static final long reflectionDataOffset
3205                 = unsafe.objectFieldOffset(Class.class, &quot;reflectionData&quot;);
3206         // offset of Class.annotationType instance field
3207         private static final long annotationTypeOffset
3208                 = unsafe.objectFieldOffset(Class.class, &quot;annotationType&quot;);
3209         // offset of Class.annotationData instance field
3210         private static final long annotationDataOffset
3211                 = unsafe.objectFieldOffset(Class.class, &quot;annotationData&quot;);
3212 
3213         static &lt;T&gt; boolean casReflectionData(Class&lt;?&gt; clazz,
3214                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldData,
3215                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; newData) {
3216             return unsafe.compareAndSetReference(clazz, reflectionDataOffset, oldData, newData);
3217         }
3218 
3219         static &lt;T&gt; boolean casAnnotationType(Class&lt;?&gt; clazz,
3220                                              AnnotationType oldType,
3221                                              AnnotationType newType) {
3222             return unsafe.compareAndSetReference(clazz, annotationTypeOffset, oldType, newType);
3223         }
3224 
3225         static &lt;T&gt; boolean casAnnotationData(Class&lt;?&gt; clazz,
3226                                              AnnotationData oldData,
3227                                              AnnotationData newData) {
3228             return unsafe.compareAndSetReference(clazz, annotationDataOffset, oldData, newData);
3229         }
3230     }
3231 
3232     /**
3233      * Reflection support.
3234      */
3235 
3236     // Reflection data caches various derived names and reflective members. Cached
3237     // values may be invalidated when JVM TI RedefineClasses() is called
3238     private static class ReflectionData&lt;T&gt; {
3239         volatile Field[] declaredFields;
3240         volatile Field[] publicFields;
3241         volatile Method[] declaredMethods;
3242         volatile Method[] publicMethods;
3243         volatile Constructor&lt;T&gt;[] declaredConstructors;
3244         volatile Constructor&lt;T&gt;[] publicConstructors;
3245         // Intermediate results for getFields and getMethods
3246         volatile Field[] declaredPublicFields;
3247         volatile Method[] declaredPublicMethods;
3248         volatile Class&lt;?&gt;[] interfaces;
3249 
3250         // Cached names
3251         String simpleName;
3252         String canonicalName;
3253         static final String NULL_SENTINEL = new String();
3254 
3255         // Value of classRedefinedCount when we created this ReflectionData instance
3256         final int redefinedCount;
3257 
3258         ReflectionData(int redefinedCount) {
3259             this.redefinedCount = redefinedCount;
3260         }
3261     }
3262 
3263     private transient volatile SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;
3264 
3265     // Incremented by the VM on each call to JVM TI RedefineClasses()
3266     // that redefines this class or a superclass.
3267     private transient volatile int classRedefinedCount;
3268 
3269     // Lazily create and cache ReflectionData
3270     private ReflectionData&lt;T&gt; reflectionData() {
3271         SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData;
3272         int classRedefinedCount = this.classRedefinedCount;
3273         ReflectionData&lt;T&gt; rd;
3274         if (reflectionData != null &amp;&amp;
3275             (rd = reflectionData.get()) != null &amp;&amp;
3276             rd.redefinedCount == classRedefinedCount) {
3277             return rd;
3278         }
3279         // else no SoftReference or cleared SoftReference or stale ReflectionData
3280         // -&gt; create and replace new instance
3281         return newReflectionData(reflectionData, classRedefinedCount);
3282     }
3283 
3284     private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,
3285                                                 int classRedefinedCount) {
3286         while (true) {
3287             ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount);
3288             // try to CAS it...
3289             if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {
3290                 return rd;
3291             }
3292             // else retry
3293             oldReflectionData = this.reflectionData;
3294             classRedefinedCount = this.classRedefinedCount;
3295             if (oldReflectionData != null &amp;&amp;
3296                 (rd = oldReflectionData.get()) != null &amp;&amp;
3297                 rd.redefinedCount == classRedefinedCount) {
3298                 return rd;
3299             }
3300         }
3301     }
3302 
3303     // Generic signature handling
3304     private native String getGenericSignature0();
3305 
3306     // Generic info repository; lazily initialized
3307     private transient volatile ClassRepository genericInfo;
3308 
3309     // accessor for factory
3310     private GenericsFactory getFactory() {
3311         // create scope and factory
3312         return CoreReflectionFactory.make(this, ClassScope.make(this));
3313     }
3314 
3315     // accessor for generic info repository;
3316     // generic info is lazily initialized
3317     private ClassRepository getGenericInfo() {
3318         ClassRepository genericInfo = this.genericInfo;
3319         if (genericInfo == null) {
3320             String signature = getGenericSignature0();
3321             if (signature == null) {
3322                 genericInfo = ClassRepository.NONE;
3323             } else {
3324                 genericInfo = ClassRepository.make(signature, getFactory());
3325             }
3326             this.genericInfo = genericInfo;
3327         }
3328         return (genericInfo != ClassRepository.NONE) ? genericInfo : null;
3329     }
3330 
3331     // Annotations handling
3332     native byte[] getRawAnnotations();
3333     // Since 1.8
3334     native byte[] getRawTypeAnnotations();
3335     static byte[] getExecutableTypeAnnotationBytes(Executable ex) {
3336         return getReflectionFactory().getExecutableTypeAnnotationBytes(ex);
3337     }
3338 
3339     native ConstantPool getConstantPool();
3340 
3341     //
3342     //
3343     // java.lang.reflect.Field handling
3344     //
3345     //
3346 
3347     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3348     // be propagated to the outside world, but must instead be copied
3349     // via ReflectionFactory.copyField.
3350     private Field[] privateGetDeclaredFields(boolean publicOnly) {
3351         Field[] res;
3352         ReflectionData&lt;T&gt; rd = reflectionData();
3353         if (rd != null) {
3354             res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;
3355             if (res != null) return res;
3356         }
3357         // No cached value available; request value from VM
3358         res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
3359         if (rd != null) {
3360             if (publicOnly) {
3361                 rd.declaredPublicFields = res;
3362             } else {
3363                 rd.declaredFields = res;
3364             }
3365         }
3366         return res;
3367     }
3368 
3369     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3370     // be propagated to the outside world, but must instead be copied
3371     // via ReflectionFactory.copyField.
3372     private Field[] privateGetPublicFields() {
3373         Field[] res;
3374         ReflectionData&lt;T&gt; rd = reflectionData();
3375         if (rd != null) {
3376             res = rd.publicFields;
3377             if (res != null) return res;
3378         }
3379 
3380         // Use a linked hash set to ensure order is preserved and
3381         // fields from common super interfaces are not duplicated
3382         LinkedHashSet&lt;Field&gt; fields = new LinkedHashSet&lt;&gt;();
3383 
3384         // Local fields
3385         addAll(fields, privateGetDeclaredFields(true));
3386 
3387         // Direct superinterfaces, recursively
3388         for (Class&lt;?&gt; si : getInterfaces()) {
3389             addAll(fields, si.privateGetPublicFields());
3390         }
3391 
3392         // Direct superclass, recursively
3393         Class&lt;?&gt; sc = getSuperclass();
3394         if (sc != null) {
3395             addAll(fields, sc.privateGetPublicFields());
3396         }
3397 
3398         res = fields.toArray(new Field[0]);
3399         if (rd != null) {
3400             rd.publicFields = res;
3401         }
3402         return res;
3403     }
3404 
3405     private static void addAll(Collection&lt;Field&gt; c, Field[] o) {
3406         for (Field f : o) {
3407             c.add(f);
3408         }
3409     }
3410 
3411 
3412     //
3413     //
3414     // java.lang.reflect.Constructor handling
3415     //
3416     //
3417 
3418     // Returns an array of &quot;root&quot; constructors. These Constructor
3419     // objects must NOT be propagated to the outside world, but must
3420     // instead be copied via ReflectionFactory.copyConstructor.
3421     private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
3422         Constructor&lt;T&gt;[] res;
3423         ReflectionData&lt;T&gt; rd = reflectionData();
3424         if (rd != null) {
3425             res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;
3426             if (res != null) return res;
3427         }
3428         // No cached value available; request value from VM
3429         if (isInterface()) {
3430             @SuppressWarnings(&quot;unchecked&quot;)
3431             Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];
3432             res = temporaryRes;
3433         } else {
3434             res = getDeclaredConstructors0(publicOnly);
3435         }
3436         if (rd != null) {
3437             if (publicOnly) {
3438                 rd.publicConstructors = res;
3439             } else {
3440                 rd.declaredConstructors = res;
3441             }
3442         }
3443         return res;
3444     }
3445 
3446     //
3447     //
3448     // java.lang.reflect.Method handling
3449     //
3450     //
3451 
3452     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3453     // be propagated to the outside world, but must instead be copied
3454     // via ReflectionFactory.copyMethod.
3455     private Method[] privateGetDeclaredMethods(boolean publicOnly) {
3456         Method[] res;
3457         ReflectionData&lt;T&gt; rd = reflectionData();
3458         if (rd != null) {
3459             res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;
3460             if (res != null) return res;
3461         }
3462         // No cached value available; request value from VM
3463         res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
3464         if (rd != null) {
3465             if (publicOnly) {
3466                 rd.declaredPublicMethods = res;
3467             } else {
3468                 rd.declaredMethods = res;
3469             }
3470         }
3471         return res;
3472     }
3473 
3474     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3475     // be propagated to the outside world, but must instead be copied
3476     // via ReflectionFactory.copyMethod.
3477     private Method[] privateGetPublicMethods() {
3478         Method[] res;
3479         ReflectionData&lt;T&gt; rd = reflectionData();
3480         if (rd != null) {
3481             res = rd.publicMethods;
3482             if (res != null) return res;
3483         }
3484 
3485         // No cached value available; compute value recursively.
3486         // Start by fetching public declared methods...
3487         PublicMethods pms = new PublicMethods();
3488         for (Method m : privateGetDeclaredMethods(/* publicOnly */ true)) {
3489             pms.merge(m);
3490         }
3491         // ...then recur over superclass methods...
3492         Class&lt;?&gt; sc = getSuperclass();
3493         if (sc != null) {
3494             for (Method m : sc.privateGetPublicMethods()) {
3495                 pms.merge(m);
3496             }
3497         }
3498         // ...and finally over direct superinterfaces.
3499         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3500             for (Method m : intf.privateGetPublicMethods()) {
3501                 // static interface methods are not inherited
3502                 if (!Modifier.isStatic(m.getModifiers())) {
3503                     pms.merge(m);
3504                 }
3505             }
3506         }
3507 
3508         res = pms.toArray();
3509         if (rd != null) {
3510             rd.publicMethods = res;
3511         }
3512         return res;
3513     }
3514 
3515 
3516     //
3517     // Helpers for fetchers of one field, method, or constructor
3518     //
3519 
3520     // This method does not copy the returned Field object!
3521     private static Field searchFields(Field[] fields, String name) {
3522         for (Field field : fields) {
3523             if (field.getName().equals(name)) {
3524                 return field;
3525             }
3526         }
3527         return null;
3528     }
3529 
3530     // Returns a &quot;root&quot; Field object. This Field object must NOT
3531     // be propagated to the outside world, but must instead be copied
3532     // via ReflectionFactory.copyField.
3533     private Field getField0(String name) {
3534         // Note: the intent is that the search algorithm this routine
3535         // uses be equivalent to the ordering imposed by
3536         // privateGetPublicFields(). It fetches only the declared
3537         // public fields for each class, however, to reduce the number
3538         // of Field objects which have to be created for the common
3539         // case where the field being requested is declared in the
3540         // class which is being queried.
3541         Field res;
3542         // Search declared public fields
3543         if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {
3544             return res;
3545         }
3546         // Direct superinterfaces, recursively
3547         Class&lt;?&gt;[] interfaces = getInterfaces(/* cloneArray */ false);
3548         for (Class&lt;?&gt; c : interfaces) {
3549             if ((res = c.getField0(name)) != null) {
3550                 return res;
3551             }
3552         }
3553         // Direct superclass, recursively
3554         if (!isInterface()) {
3555             Class&lt;?&gt; c = getSuperclass();
3556             if (c != null) {
3557                 if ((res = c.getField0(name)) != null) {
3558                     return res;
3559                 }
3560             }
3561         }
3562         return null;
3563     }
3564 
3565     // This method does not copy the returned Method object!
3566     private static Method searchMethods(Method[] methods,
3567                                         String name,
3568                                         Class&lt;?&gt;[] parameterTypes)
3569     {
3570         ReflectionFactory fact = getReflectionFactory();
3571         Method res = null;
3572         for (Method m : methods) {
3573             if (m.getName().equals(name)
3574                 &amp;&amp; arrayContentsEq(parameterTypes,
3575                                    fact.getExecutableSharedParameterTypes(m))
3576                 &amp;&amp; (res == null
3577                     || (res.getReturnType() != m.getReturnType()
3578                         &amp;&amp; res.getReturnType().isAssignableFrom(m.getReturnType()))))
3579                 res = m;
3580         }
3581         return res;
3582     }
3583 
3584     private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];
3585 
3586     // Returns a &quot;root&quot; Method object. This Method object must NOT
3587     // be propagated to the outside world, but must instead be copied
3588     // via ReflectionFactory.copyMethod.
3589     private Method getMethod0(String name, Class&lt;?&gt;[] parameterTypes) {
3590         PublicMethods.MethodList res = getMethodsRecursive(
3591             name,
3592             parameterTypes == null ? EMPTY_CLASS_ARRAY : parameterTypes,
3593             /* includeStatic */ true);
3594         return res == null ? null : res.getMostSpecific();
3595     }
3596 
3597     // Returns a list of &quot;root&quot; Method objects. These Method objects must NOT
3598     // be propagated to the outside world, but must instead be copied
3599     // via ReflectionFactory.copyMethod.
3600     private PublicMethods.MethodList getMethodsRecursive(String name,
3601                                                          Class&lt;?&gt;[] parameterTypes,
3602                                                          boolean includeStatic) {
3603         // 1st check declared public methods
3604         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
3605         PublicMethods.MethodList res = PublicMethods.MethodList
3606             .filter(methods, name, parameterTypes, includeStatic);
3607         // if there is at least one match among declared methods, we need not
3608         // search any further as such match surely overrides matching methods
3609         // declared in superclass(es) or interface(s).
3610         if (res != null) {
3611             return res;
3612         }
3613 
3614         // if there was no match among declared methods,
3615         // we must consult the superclass (if any) recursively...
3616         Class&lt;?&gt; sc = getSuperclass();
3617         if (sc != null) {
3618             res = sc.getMethodsRecursive(name, parameterTypes, includeStatic);
3619         }
3620 
3621         // ...and coalesce the superclass methods with methods obtained
3622         // from directly implemented interfaces excluding static methods...
3623         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3624             res = PublicMethods.MethodList.merge(
3625                 res, intf.getMethodsRecursive(name, parameterTypes,
3626                                               /* includeStatic */ false));
3627         }
3628 
3629         return res;
3630     }
3631 
3632     // Returns a &quot;root&quot; Constructor object. This Constructor object must NOT
3633     // be propagated to the outside world, but must instead be copied
3634     // via ReflectionFactory.copyConstructor.
3635     private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,
3636                                         int which) throws NoSuchMethodException
3637     {
3638         ReflectionFactory fact = getReflectionFactory();
3639         Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
3640         for (Constructor&lt;T&gt; constructor : constructors) {
3641             if (arrayContentsEq(parameterTypes,
3642                                 fact.getExecutableSharedParameterTypes(constructor))) {
3643                 return constructor;
3644             }
3645         }
3646         throw new NoSuchMethodException(methodToString(&quot;&lt;init&gt;&quot;, parameterTypes));
3647     }
3648 
3649     //
3650     // Other helpers and base implementation
3651     //
3652 
3653     private static boolean arrayContentsEq(Object[] a1, Object[] a2) {
3654         if (a1 == null) {
3655             return a2 == null || a2.length == 0;
3656         }
3657 
3658         if (a2 == null) {
3659             return a1.length == 0;
3660         }
3661 
3662         if (a1.length != a2.length) {
3663             return false;
3664         }
3665 
3666         for (int i = 0; i &lt; a1.length; i++) {
3667             if (a1[i] != a2[i]) {
3668                 return false;
3669             }
3670         }
3671 
3672         return true;
3673     }
3674 
3675     private static Field[] copyFields(Field[] arg) {
3676         Field[] out = new Field[arg.length];
3677         ReflectionFactory fact = getReflectionFactory();
3678         for (int i = 0; i &lt; arg.length; i++) {
3679             out[i] = fact.copyField(arg[i]);
3680         }
3681         return out;
3682     }
3683 
3684     private static Method[] copyMethods(Method[] arg) {
3685         Method[] out = new Method[arg.length];
3686         ReflectionFactory fact = getReflectionFactory();
3687         for (int i = 0; i &lt; arg.length; i++) {
3688             out[i] = fact.copyMethod(arg[i]);
3689         }
3690         return out;
3691     }
3692 
3693     private static &lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) {
3694         Constructor&lt;U&gt;[] out = arg.clone();
3695         ReflectionFactory fact = getReflectionFactory();
3696         for (int i = 0; i &lt; out.length; i++) {
3697             out[i] = fact.copyConstructor(out[i]);
3698         }
3699         return out;
3700     }
3701 
3702     private native Field[]       getDeclaredFields0(boolean publicOnly);
3703     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3704     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3705     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3706     @SuppressWarnings(&quot;preview&quot;)
3707     private native RecordComponent[] getRecordComponents0();
3708     private native boolean      isRecord0();
3709 
3710     /**
3711      * Helper method to get the method name from arguments.
3712      */
3713     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3714         return getName() + &#39;.&#39; + name +
3715                 ((argTypes == null || argTypes.length == 0) ?
3716                 &quot;()&quot; :
3717                 Arrays.stream(argTypes)
3718                         .map(c -&gt; c == null ? &quot;null&quot; : c.getName())
3719                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3720     }
3721 
3722     /** use serialVersionUID from JDK 1.1 for interoperability */
3723     @java.io.Serial
3724     private static final long serialVersionUID = 3206093459760846163L;
3725 
3726 
3727     /**
3728      * Class Class is special cased within the Serialization Stream Protocol.
3729      *
3730      * A Class instance is written initially into an ObjectOutputStream in the
3731      * following format:
3732      * &lt;pre&gt;
3733      *      {@code TC_CLASS} ClassDescriptor
3734      *      A ClassDescriptor is a special cased serialization of
3735      *      a {@code java.io.ObjectStreamClass} instance.
3736      * &lt;/pre&gt;
3737      * A new handle is generated for the initial time the class descriptor
3738      * is written into the stream. Future references to the class descriptor
3739      * are written as references to the initial class descriptor instance.
3740      *
3741      * @see java.io.ObjectStreamClass
3742      */
3743     @java.io.Serial
3744     private static final ObjectStreamField[] serialPersistentFields =
3745         new ObjectStreamField[0];
3746 
3747 
3748     /**
3749      * Returns the assertion status that would be assigned to this
3750      * class if it were to be initialized at the time this method is invoked.
3751      * If this class has had its assertion status set, the most recent
3752      * setting will be returned; otherwise, if any package default assertion
3753      * status pertains to this class, the most recent setting for the most
3754      * specific pertinent package default assertion status is returned;
3755      * otherwise, if this class is not a system class (i.e., it has a
3756      * class loader) its class loader&#39;s default assertion status is returned;
3757      * otherwise, the system class default assertion status is returned.
3758      *
3759      * @apiNote
3760      * Few programmers will have any need for this method; it is provided
3761      * for the benefit of the JDK itself.  (It allows a class to determine at
3762      * the time that it is initialized whether assertions should be enabled.)
3763      * Note that this method is not guaranteed to return the actual
3764      * assertion status that was (or will be) associated with the specified
3765      * class when it was (or will be) initialized.
3766      *
3767      * @return the desired assertion status of the specified class.
3768      * @see    java.lang.ClassLoader#setClassAssertionStatus
3769      * @see    java.lang.ClassLoader#setPackageAssertionStatus
3770      * @see    java.lang.ClassLoader#setDefaultAssertionStatus
3771      * @since  1.4
3772      */
3773     public boolean desiredAssertionStatus() {
3774         ClassLoader loader = getClassLoader0();
3775         // If the loader is null this is a system class, so ask the VM
3776         if (loader == null)
3777             return desiredAssertionStatus0(this);
3778 
3779         // If the classloader has been initialized with the assertion
3780         // directives, ask it. Otherwise, ask the VM.
3781         synchronized(loader.assertionLock) {
3782             if (loader.classAssertionStatus != null) {
3783                 return loader.desiredAssertionStatus(getName());
3784             }
3785         }
3786         return desiredAssertionStatus0(this);
3787     }
3788 
3789     // Retrieves the desired assertion status of this class from the VM
3790     private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);
3791 
3792     /**
3793      * Returns true if and only if this class was declared as an enum in the
3794      * source code.
3795      *
3796      * Note that {@link java.lang.Enum} is not itself an enum type.
3797      *
3798      * Also note that if an enum constant is declared with a class body,
3799      * the class of that enum constant object is an anonymous class
3800      * and &lt;em&gt;not&lt;/em&gt; the class of the declaring enum type. The
3801      * {@link Enum#getDeclaringClass} method of an enum constant can
3802      * be used to get the class of the enum type declaring the
3803      * constant.
3804      *
3805      * @return true if and only if this class was declared as an enum in the
3806      *     source code
3807      * @since 1.5
3808      * @jls 8.9.1 Enum Constants
3809      */
3810     public boolean isEnum() {
3811         // An enum must both directly extend java.lang.Enum and have
3812         // the ENUM bit set; classes for specialized enum constants
3813         // don&#39;t do the former.
3814         return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;
3815         this.getSuperclass() == java.lang.Enum.class;
3816     }
3817 
3818     /** java.lang.Record.class */
3819     private static final Class&lt;?&gt; JAVA_LANG_RECORD_CLASS = javaLangRecordClass();
3820     private static Class&lt;?&gt; javaLangRecordClass() {
3821         try {
3822             return Class.forName0(&quot;java.lang.Record&quot;, false, null, null);
3823         } catch (ClassNotFoundException e) {
3824             throw new InternalError(&quot;should not reach here&quot;, e);
3825         }
3826     }
3827 
3828     /**
3829      * {@preview Associated with records, a preview feature of the Java language.
3830      *
3831      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
3832      *           feature of the Java language. Preview features
3833      *           may be removed in a future release, or upgraded to permanent
3834      *           features of the Java language.}
3835      *
3836      * Returns {@code true} if and only if this class is a record class.
3837      *
3838      * &lt;p&gt; The {@linkplain #getSuperclass() direct superclass} of a record
3839      * class is {@code java.lang.Record}. A record class has (possibly zero)
3840      * record components, that is, {@link #getRecordComponents()} returns a
3841      * non-null value.
3842      *
3843      * &lt;p&gt; Note that class {@link Record} is not a record type and thus invoking
3844      * this method on class {@code Record} returns {@code false}.
3845      *
3846      * @return true if and only if this class is a record class, otherwise false
3847      * @jls 8.10 Record Types
3848      * @since 14
3849      */
3850     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
3851                                  essentialAPI=false)
3852     public boolean isRecord() {
3853         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();
3854     }
3855 
3856     // Fetches the factory for reflective objects
3857     private static ReflectionFactory getReflectionFactory() {
3858         if (reflectionFactory == null) {
3859             reflectionFactory =
3860                 java.security.AccessController.doPrivileged
3861                     (new ReflectionFactory.GetReflectionFactoryAction());
3862         }
3863         return reflectionFactory;
3864     }
3865     private static ReflectionFactory reflectionFactory;
3866 
3867     /**
3868      * Returns the elements of this enum class or null if this
3869      * Class object does not represent an enum type.
3870      *
3871      * @return an array containing the values comprising the enum class
3872      *     represented by this {@code Class} object in the order they&#39;re
3873      *     declared, or null if this {@code Class} object does not
3874      *     represent an enum type
3875      * @since 1.5
3876      */
3877     public T[] getEnumConstants() {
3878         T[] values = getEnumConstantsShared();
3879         return (values != null) ? values.clone() : null;
3880     }
3881 
3882     /**
3883      * Returns the elements of this enum class or null if this
3884      * Class object does not represent an enum type;
3885      * identical to getEnumConstants except that the result is
3886      * uncloned, cached, and shared by all callers.
3887      */
3888     T[] getEnumConstantsShared() {
3889         T[] constants = enumConstants;
3890         if (constants == null) {
3891             if (!isEnum()) return null;
3892             try {
3893                 final Method values = getMethod(&quot;values&quot;);
3894                 java.security.AccessController.doPrivileged(
3895                     new java.security.PrivilegedAction&lt;&gt;() {
3896                         public Void run() {
3897                                 values.setAccessible(true);
3898                                 return null;
3899                             }
3900                         });
3901                 @SuppressWarnings(&quot;unchecked&quot;)
3902                 T[] temporaryConstants = (T[])values.invoke(null);
3903                 enumConstants = constants = temporaryConstants;
3904             }
3905             // These can happen when users concoct enum-like classes
3906             // that don&#39;t comply with the enum spec.
3907             catch (InvocationTargetException | NoSuchMethodException |
3908                    IllegalAccessException ex) { return null; }
3909         }
3910         return constants;
3911     }
3912     private transient volatile T[] enumConstants;
3913 
3914     /**
3915      * Returns a map from simple name to enum constant.  This package-private
3916      * method is used internally by Enum to implement
3917      * {@code public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)}
3918      * efficiently.  Note that the map is returned by this method is
3919      * created lazily on first use.  Typically it won&#39;t ever get created.
3920      */
3921     Map&lt;String, T&gt; enumConstantDirectory() {
3922         Map&lt;String, T&gt; directory = enumConstantDirectory;
3923         if (directory == null) {
3924             T[] universe = getEnumConstantsShared();
3925             if (universe == null)
3926                 throw new IllegalArgumentException(
3927                     getName() + &quot; is not an enum type&quot;);
3928             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3929             for (T constant : universe) {
3930                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3931             }
3932             enumConstantDirectory = directory;
3933         }
3934         return directory;
3935     }
3936     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3937 
3938     /**
3939      * Casts an object to the class or interface represented
3940      * by this {@code Class} object.
3941      *
3942      * @param obj the object to be cast
3943      * @return the object after casting, or null if obj is null
3944      *
3945      * @throws ClassCastException if the object is not
3946      * {@code null} and is not assignable to the type T.
3947      * @throws NullPointerException if this is an {@linkplain #isInlineClass()
3948      * inline type} and the object is {@code null}
3949      *
3950      * @since 1.5
3951      */
3952     @SuppressWarnings(&quot;unchecked&quot;)
3953     @HotSpotIntrinsicCandidate
3954     public T cast(Object obj) {
3955         if (isInlineClass() &amp;&amp; obj == null)
3956             throw new NullPointerException(getName() + &quot; is an inline class&quot;);
3957 
3958         if (obj != null &amp;&amp; !isInstance(obj))
3959             throw new ClassCastException(cannotCastMsg(obj));
3960         return (T) obj;
3961     }
3962 
3963     private String cannotCastMsg(Object obj) {
3964         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3965     }
3966 
3967     /**
3968      * Casts this {@code Class} object to represent a subclass of the class
3969      * represented by the specified class object.  Checks that the cast
3970      * is valid, and throws a {@code ClassCastException} if it is not.  If
3971      * this method succeeds, it always returns a reference to this {@code Class} object.
3972      *
3973      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3974      * a {@code Class} object to pass it to an API that restricts the
3975      * {@code Class} objects that it is willing to accept.  A cast would
3976      * generate a compile-time warning, as the correctness of the cast
3977      * could not be checked at runtime (because generic types are implemented
3978      * by erasure).
3979      *
3980      * @param &lt;U&gt; the type to cast this {@code Class} object to
3981      * @param clazz the class of the type to cast this {@code Class} object to
3982      * @return this {@code Class} object, cast to represent a subclass of
3983      *    the specified class object.
3984      * @throws ClassCastException if this {@code Class} object does not
3985      *    represent a subclass of the specified class (here &quot;subclass&quot; includes
3986      *    the class itself).
3987      * @since 1.5
3988      */
3989     @SuppressWarnings(&quot;unchecked&quot;)
3990     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3991         if (clazz.isAssignableFrom(this))
3992             return (Class&lt;? extends U&gt;) this;
3993         else
3994             throw new ClassCastException(this.toString());
3995     }
3996 
3997     /**
3998      * {@inheritDoc}
3999      * &lt;p&gt;Note that any annotation returned by this method is a
4000      * declaration annotation.
4001      *
4002      * @throws NullPointerException {@inheritDoc}
4003      * @since 1.5
4004      */
4005     @Override
4006     @SuppressWarnings(&quot;unchecked&quot;)
4007     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
4008         Objects.requireNonNull(annotationClass);
4009 
4010         return (A) annotationData().annotations.get(annotationClass);
4011     }
4012 
4013     /**
4014      * {@inheritDoc}
4015      * @throws NullPointerException {@inheritDoc}
4016      * @since 1.5
4017      */
4018     @Override
4019     public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
4020         return GenericDeclaration.super.isAnnotationPresent(annotationClass);
4021     }
4022 
4023     /**
4024      * {@inheritDoc}
4025      * &lt;p&gt;Note that any annotations returned by this method are
4026      * declaration annotations.
4027      *
4028      * @throws NullPointerException {@inheritDoc}
4029      * @since 1.8
4030      */
4031     @Override
4032     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
4033         Objects.requireNonNull(annotationClass);
4034 
4035         AnnotationData annotationData = annotationData();
4036         return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,
4037                                                           this,
4038                                                           annotationClass);
4039     }
4040 
4041     /**
4042      * {@inheritDoc}
4043      * &lt;p&gt;Note that any annotations returned by this method are
4044      * declaration annotations.
4045      *
4046      * @since 1.5
4047      */
4048     @Override
4049     public Annotation[] getAnnotations() {
4050         return AnnotationParser.toArray(annotationData().annotations);
4051     }
4052 
4053     /**
4054      * {@inheritDoc}
4055      * &lt;p&gt;Note that any annotation returned by this method is a
4056      * declaration annotation.
4057      *
4058      * @throws NullPointerException {@inheritDoc}
4059      * @since 1.8
4060      */
4061     @Override
4062     @SuppressWarnings(&quot;unchecked&quot;)
4063     public &lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) {
4064         Objects.requireNonNull(annotationClass);
4065 
4066         return (A) annotationData().declaredAnnotations.get(annotationClass);
4067     }
4068 
4069     /**
4070      * {@inheritDoc}
4071      * &lt;p&gt;Note that any annotations returned by this method are
4072      * declaration annotations.
4073      *
4074      * @throws NullPointerException {@inheritDoc}
4075      * @since 1.8
4076      */
4077     @Override
4078     public &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
4079         Objects.requireNonNull(annotationClass);
4080 
4081         return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,
4082                                                                  annotationClass);
4083     }
4084 
4085     /**
4086      * {@inheritDoc}
4087      * &lt;p&gt;Note that any annotations returned by this method are
4088      * declaration annotations.
4089      *
4090      * @since 1.5
4091      */
4092     @Override
4093     public Annotation[] getDeclaredAnnotations()  {
4094         return AnnotationParser.toArray(annotationData().declaredAnnotations);
4095     }
4096 
4097     // annotation data that might get invalidated when JVM TI RedefineClasses() is called
4098     private static class AnnotationData {
4099         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;
4100         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
4101 
4102         // Value of classRedefinedCount when we created this AnnotationData instance
4103         final int redefinedCount;
4104 
4105         AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,
4106                        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,
4107                        int redefinedCount) {
4108             this.annotations = annotations;
4109             this.declaredAnnotations = declaredAnnotations;
4110             this.redefinedCount = redefinedCount;
4111         }
4112     }
4113 
4114     // Annotations cache
4115     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
4116     private transient volatile AnnotationData annotationData;
4117 
4118     private AnnotationData annotationData() {
4119         while (true) { // retry loop
4120             AnnotationData annotationData = this.annotationData;
4121             int classRedefinedCount = this.classRedefinedCount;
4122             if (annotationData != null &amp;&amp;
4123                 annotationData.redefinedCount == classRedefinedCount) {
4124                 return annotationData;
4125             }
4126             // null or stale annotationData -&gt; optimistically create new instance
4127             AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);
4128             // try to install it
4129             if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) {
4130                 // successfully installed new AnnotationData
4131                 return newAnnotationData;
4132             }
4133         }
4134     }
4135 
4136     private AnnotationData createAnnotationData(int classRedefinedCount) {
4137         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations =
4138             AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this);
4139         Class&lt;?&gt; superClass = getSuperclass();
4140         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations = null;
4141         if (superClass != null) {
4142             Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; superAnnotations =
4143                 superClass.annotationData().annotations;
4144             for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superAnnotations.entrySet()) {
4145                 Class&lt;? extends Annotation&gt; annotationClass = e.getKey();
4146                 if (AnnotationType.getInstance(annotationClass).isInherited()) {
4147                     if (annotations == null) { // lazy construction
4148                         annotations = new LinkedHashMap&lt;&gt;((Math.max(
4149                                 declaredAnnotations.size(),
4150                                 Math.min(12, declaredAnnotations.size() + superAnnotations.size())
4151                             ) * 4 + 2) / 3
4152                         );
4153                     }
4154                     annotations.put(annotationClass, e.getValue());
4155                 }
4156             }
4157         }
4158         if (annotations == null) {
4159             // no inherited annotations -&gt; share the Map with declaredAnnotations
4160             annotations = declaredAnnotations;
4161         } else {
4162             // at least one inherited annotation -&gt; declared may override inherited
4163             annotations.putAll(declaredAnnotations);
4164         }
4165         return new AnnotationData(annotations, declaredAnnotations, classRedefinedCount);
4166     }
4167 
4168     // Annotation types cache their internal (AnnotationType) form
4169 
4170     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
4171     private transient volatile AnnotationType annotationType;
4172 
4173     boolean casAnnotationType(AnnotationType oldType, AnnotationType newType) {
4174         return Atomic.casAnnotationType(this, oldType, newType);
4175     }
4176 
4177     AnnotationType getAnnotationType() {
4178         return annotationType;
4179     }
4180 
4181     Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap() {
4182         return annotationData().declaredAnnotations;
4183     }
4184 
4185     /* Backing store of user-defined values pertaining to this class.
4186      * Maintained by the ClassValue class.
4187      */
4188     transient ClassValue.ClassValueMap classValueMap;
4189 
4190     /**
4191      * Returns an {@code AnnotatedType} object that represents the use of a
4192      * type to specify the superclass of the entity represented by this {@code
4193      * Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify the superclass
4194      * in &#39;...  extends Foo&#39; is distinct from the &lt;em&gt;declaration&lt;/em&gt; of type
4195      * Foo.)
4196      *
4197      * &lt;p&gt; If this {@code Class} object represents a type whose declaration
4198      * does not explicitly indicate an annotated superclass, then the return
4199      * value is an {@code AnnotatedType} object representing an element with no
4200      * annotations.
4201      *
4202      * &lt;p&gt; If this {@code Class} represents either the {@code Object} class, an
4203      * interface type, an array type, a primitive type, or void, the return
4204      * value is {@code null}.
4205      *
4206      * @return an object representing the superclass
4207      * @since 1.8
4208      */
4209     public AnnotatedType getAnnotatedSuperclass() {
4210         if (this == Object.class ||
4211                 isInterface() ||
4212                 isArray() ||
4213                 isPrimitive() ||
4214                 this == Void.TYPE) {
4215             return null;
4216         }
4217 
4218         return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), this);
4219     }
4220 
4221     /**
4222      * Returns an array of {@code AnnotatedType} objects that represent the use
4223      * of types to specify superinterfaces of the entity represented by this
4224      * {@code Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify a
4225      * superinterface in &#39;... implements Foo&#39; is distinct from the
4226      * &lt;em&gt;declaration&lt;/em&gt; of type Foo.)
4227      *
4228      * &lt;p&gt; If this {@code Class} object represents a class, the return value is
4229      * an array containing objects representing the uses of interface types to
4230      * specify interfaces implemented by the class. The order of the objects in
4231      * the array corresponds to the order of the interface types used in the
4232      * &#39;implements&#39; clause of the declaration of this {@code Class} object.
4233      *
4234      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4235      * value is an array containing objects representing the uses of interface
4236      * types to specify interfaces directly extended by the interface. The
4237      * order of the objects in the array corresponds to the order of the
4238      * interface types used in the &#39;extends&#39; clause of the declaration of this
4239      * {@code Class} object.
4240      *
4241      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4242      * declaration does not explicitly indicate any annotated superinterfaces,
4243      * the return value is an array of length 0.
4244      *
4245      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4246      * class, an array type, a primitive type, or void, the return value is an
4247      * array of length 0.
4248      *
4249      * @return an array representing the superinterfaces
4250      * @since 1.8
4251      */
4252     public AnnotatedType[] getAnnotatedInterfaces() {
4253         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);
4254     }
4255 
4256     private native Class&lt;?&gt; getNestHost0();
4257 
4258     /**
4259      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4260      * or interface represented by this {@code Class} object belongs.
4261      * Every class and interface belongs to exactly one nest.
4262      *
4263      * If the nest host of this class or interface has previously
4264      * been determined, then this method returns the nest host.
4265      * If the nest host of this class or interface has
4266      * not previously been determined, then this method determines the nest
4267      * host using the algorithm of JVMS 5.4.4, and returns it.
4268      *
4269      * Often, a class or interface belongs to a nest consisting only of itself,
4270      * in which case this method returns {@code this} to indicate that the class
4271      * or interface is the nest host.
4272      *
4273      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,
4274      * or {@code void}, then this method returns {@code this},
4275      * indicating that the represented entity belongs to the nest consisting only of
4276      * itself, and is the nest host.
4277      *
4278      * @return the nest host of this class or interface
4279      *
4280      * @throws SecurityException
4281      *         If the returned class is not the current class, and
4282      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4283      *         class loader is not the same as or an ancestor of the class
4284      *         loader for the returned class and invocation of {@link
4285      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4286      *         denies access to the package of the returned class
4287      * @since 11
4288      * @jvms 4.7.28 The {@code NestHost} Attribute
4289      * @jvms 4.7.29 The {@code NestMembers} Attribute
4290      * @jvms 5.4.4 Access Control
4291      */
4292     @CallerSensitive
4293     public Class&lt;?&gt; getNestHost() {
4294         if (isPrimitive() || isArray()) {
4295             return this;
4296         }
4297 
4298         Class&lt;?&gt; host = getNestHost0();
4299         if (host == this) {
4300             return this;
4301         }
4302         // returning a different class requires a security check
4303         SecurityManager sm = System.getSecurityManager();
4304         if (sm != null) {
4305             checkPackageAccess(sm,
4306                                ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4307         }
4308         return host;
4309     }
4310 
4311     /**
4312      * Determines if the given {@code Class} is a nestmate of the
4313      * class or interface represented by this {@code Class} object.
4314      * Two classes or interfaces are nestmates
4315      * if they have the same {@linkplain #getNestHost() nest host}.
4316      *
4317      * @param c the class to check
4318      * @return {@code true} if this class and {@code c} are members of
4319      * the same nest; and {@code false} otherwise.
4320      *
4321      * @since 11
4322      */
4323     public boolean isNestmateOf(Class&lt;?&gt; c) {
4324         if (this == c) {
4325             return true;
4326         }
4327         if (isPrimitive() || isArray() ||
4328             c.isPrimitive() || c.isArray()) {
4329             return false;
4330         }
4331 
4332         return getNestHost() == c.getNestHost();
4333     }
4334 
4335     private native Class&lt;?&gt;[] getNestMembers0();
4336 
4337     /**
4338      * Returns an array containing {@code Class} objects representing all the
4339      * classes and interfaces that are members of the nest to which the class
4340      * or interface represented by this {@code Class} object belongs.
4341      *
4342      * First, this method obtains the {@linkplain #getNestHost() nest host},
4343      * {@code H}, of the nest to which the class or interface represented by
4344      * this {@code Class} object belongs. The zeroth element of the returned
4345      * array is {@code H}.
4346      *
4347      * Then, for each class or interface {@code C} which is recorded by {@code H}
4348      * as being a member of its nest, this method attempts to obtain the {@code Class}
4349      * object for {@code C} (using {@linkplain #getClassLoader() the defining class
4350      * loader} of the current {@code Class} object), and then obtains the
4351      * {@linkplain #getNestHost() nest host} of the nest to which {@code C} belongs.
4352      * The classes and interfaces which are recorded by {@code H} as being members
4353      * of its nest, and for which {@code H} can be determined as their nest host,
4354      * are indicated by subsequent elements of the returned array. The order of
4355      * such elements is unspecified. Duplicates are permitted.
4356      *
4357      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,
4358      * or {@code void}, then this method returns a single-element array containing
4359      * {@code this}.
4360      *
4361      * @apiNote
4362      * The returned array includes only the nest members recorded in the {@code NestMembers}
4363      * attribute, and not any hidden classes that were added to the nest via
4364      * {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
4365      * Lookup::defineHiddenClass}.
4366      *
4367      * @return an array of all classes and interfaces in the same nest as
4368      * this class or interface
4369      *
4370      * @throws SecurityException
4371      * If any returned class is not the current class, and
4372      * if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4373      * class loader is not the same as or an ancestor of the class
4374      * loader for that returned class and invocation of {@link
4375      * SecurityManager#checkPackageAccess s.checkPackageAccess()}
4376      * denies access to the package of that returned class
4377      *
4378      * @since 11
4379      * @see #getNestHost()
4380      * @jvms 4.7.28 The {@code NestHost} Attribute
4381      * @jvms 4.7.29 The {@code NestMembers} Attribute
4382      */
4383     @CallerSensitive
4384     public Class&lt;?&gt;[] getNestMembers() {
4385         if (isPrimitive() || isArray()) {
4386             return new Class&lt;?&gt;[] { this };
4387         }
4388         Class&lt;?&gt;[] members = getNestMembers0();
4389         // Can&#39;t actually enable this due to bootstrapping issues
4390         // assert(members.length != 1 || members[0] == this); // expected invariant from VM
4391 
4392         if (members.length &gt; 1) {
4393             // If we return anything other than the current class we need
4394             // a security check
4395             SecurityManager sm = System.getSecurityManager();
4396             if (sm != null) {
4397                 checkPackageAccess(sm,
4398                                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4399             }
4400         }
4401         return members;
4402     }
4403 
4404     /**
4405      * Returns the descriptor string of the entity (class, interface, array class,
4406      * primitive type, or {@code void}) represented by this {@code Class} object.
4407      *
4408      * &lt;p&gt; If this {@code Class} object represents a class or interface,
4409      * not an array class, then:
4410      * &lt;ul&gt;
4411      * &lt;li&gt; If the class or interface is not {@linkplain Class#isHidden() hidden},
4412      *      then the result is a field descriptor (JVMS {@jvms 4.3.2})
4413      *      for the class or interface. Calling
4414      *      {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}
4415      *      with the result descriptor string produces a {@link ClassDesc ClassDesc}
4416      *      describing this class or interface.
4417      * &lt;li&gt; If the class or interface is {@linkplain Class#isHidden() hidden},
4418      *      then the result is a string of the form:
4419      *      &lt;blockquote&gt;
4420      *      {@code &quot;L&quot; +} &lt;em&gt;N&lt;/em&gt; {@code + &quot;.&quot; + &lt;suffix&gt; + &quot;;&quot;}
4421      *      &lt;/blockquote&gt;
4422      *      where &lt;em&gt;N&lt;/em&gt; is the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
4423      *      encoded in internal form indicated by the {@code class} file passed to
4424      *      {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
4425      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.
4426      *      A hidden class or interface has no {@linkplain ClassDesc nominal descriptor}.
4427      *      The result string is not a type descriptor.
4428      * &lt;/ul&gt;
4429      *
4430      * &lt;p&gt; If this {@code Class} object represents an array class, then
4431      * the result is a string consisting of one or more &#39;{@code [}&#39; characters
4432      * representing the depth of the array nesting, followed by the
4433      * descriptor string of the element type.
4434      * &lt;ul&gt;
4435      * &lt;li&gt; If the element type is not a {@linkplain Class#isHidden() hidden} class
4436      * or interface, then this array class can be described nominally.
4437      * Calling {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}
4438      * with the result descriptor string produces a {@link ClassDesc ClassDesc}
4439      * describing this array class.
4440      * &lt;li&gt; If the element type is a {@linkplain Class#isHidden() hidden} class or
4441      * interface, then this array class cannot be described nominally.
4442      * The result string is not a type descriptor.
4443      * &lt;/ul&gt;
4444      *
4445      * &lt;p&gt; If this {@code Class} object represents a primitive type or
4446      * {@code void}, then the result is a field descriptor string which
4447      * is a one-letter code corresponding to a primitive type or {@code void}
4448      * ({@code &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;}) (JVMS {@jvms 4.3.2}).
4449      *
4450      * @apiNote
4451      * This is not a strict inverse of {@link #forName};
4452      * distinct classes which share a common name but have different class loaders
4453      * will have identical descriptor strings.
4454      *
4455      * @return the descriptor string for this {@code Class} object
4456      * @jvms 4.3.2 Field Descriptors
4457      * @since 12
4458      */
4459     @Override
4460     public String descriptorString() {
4461         if (isPrimitive())
4462             return Wrapper.forPrimitiveType(this).basicTypeString();
4463 
4464         if (isArray()) {
4465             return &quot;[&quot; + componentType.descriptorString();
4466         }
4467         String typeDesc = isInlineClass() ? &quot;Q&quot; : &quot;L&quot;;
4468         if (isHidden()) {
4469             String name = getName();
4470             int index = name.indexOf(&#39;/&#39;);
4471             return typeDesc + name.substring(0, index).replace(&#39;.&#39;, &#39;/&#39;)
4472                        + &quot;.&quot; + name.substring(index+1) + &quot;;&quot;;
4473         } else {
4474             return typeDesc + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;
4475         }
4476     }
4477 
4478     /**
4479      * Returns the component type of this {@code Class}, if it describes
4480      * an array type, or {@code null} otherwise.
4481      *
4482      * @implSpec
4483      * Equivalent to {@link Class#getComponentType()}.
4484      *
4485      * @return a {@code Class} describing the component type, or {@code null}
4486      * if this {@code Class} does not describe an array type
4487      * @since 12
4488      */
4489     @Override
4490     public Class&lt;?&gt; componentType() {
4491         return isArray() ? componentType : null;
4492     }
4493 
4494     /**
4495      * Returns a {@code Class} for an array type whose component type
4496      * is described by this {@linkplain Class}.
4497      *
4498      * @return a {@code Class} describing the array type
4499      * @since 12
4500      */
4501     @Override
4502     public Class&lt;?&gt; arrayType() {
4503         return Array.newInstance(this, 0).getClass();
4504     }
4505 
4506     /**
4507      * Returns a nominal descriptor for this instance, if one can be
4508      * constructed, or an empty {@link Optional} if one cannot be.
4509      *
4510      * @return An {@link Optional} containing the resulting nominal descriptor,
4511      * or an empty {@link Optional} if one cannot be constructed.
4512      * @since 12
4513      */
4514     @Override
4515     public Optional&lt;ClassDesc&gt; describeConstable() {
4516         Class&lt;?&gt; c = isArray() ? elementType() : this;
4517         return c.isHidden() ? Optional.empty()
4518                             : Optional.of(ClassDesc.ofDescriptor(descriptorString()));
4519    }
4520 
4521     /**
4522      * Returns {@code true} if and only if the underlying class is a hidden class.
4523      *
4524      * @return {@code true} if and only if this class is a hidden class.
4525      *
4526      * @since 15
4527      * @see MethodHandles.Lookup#defineHiddenClass
4528      */
4529     @HotSpotIntrinsicCandidate
4530     public native boolean isHidden();
4531 
4532     /**
4533      * {@preview Associated with sealed classes, a preview feature of the Java language.
4534      *
4535      *           This method is associated with &lt;i&gt;sealed classes&lt;/i&gt;, a preview
4536      *           feature of the Java language. Preview features
4537      *           may be removed in a future release, or upgraded to permanent
4538      *           features of the Java language.}
4539      *
4540      * Returns an array containing {@code ClassDesc} objects representing all the
4541      * direct subclasses or direct implementation classes permitted to extend or
4542      * implement this class or interface if it is sealed. The order of such elements
4543      * is unspecified. If this {@code Class} object represents a primitive type,
4544      * {@code void}, an array type, or a class or interface that is not sealed,
4545      * an empty array is returned.
4546      *
4547      * @return an array of class descriptors of all the permitted subclasses of this class or interface
4548      *
4549      * @jls 8.1 Class Declarations
4550      * @jls 9.1 Interface Declarations
4551      * @since 15
4552      */
4553     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.SEALED_CLASSES, essentialAPI=false)
4554     public ClassDesc[] permittedSubclasses() {
4555         String[] subclassNames;
4556         if (isArray() || isPrimitive() || (subclassNames = getPermittedSubclasses0()).length == 0) {
4557             return EMPTY_CLASS_DESC_ARRAY;
4558         }
4559         ClassDesc[] constants = new ClassDesc[subclassNames.length];
4560         int i = 0;
4561         for (String subclassName : subclassNames) {
4562             try {
4563                 constants[i++] = ClassDesc.of(subclassName.replace(&#39;/&#39;, &#39;.&#39;));
4564             } catch (IllegalArgumentException iae) {
4565                 throw new InternalError(&quot;Invalid type in permitted subclasses information: &quot; + subclassName, iae);
4566             }
4567         }
4568         return constants;
4569     }
4570 
4571     /**
4572      * * {@preview Associated with sealed classes, a preview feature of the Java language.
4573      *
4574      *           This method is associated with &lt;i&gt;sealed classes&lt;/i&gt;, a preview
4575      *           feature of the Java language. Preview features
4576      *           may be removed in a future release, or upgraded to permanent
4577      *           features of the Java language.}
4578      *
4579      * Returns {@code true} if and only if this {@code Class} object represents a sealed class or interface.
4580      * If this {@code Class} object represents a primitive type, {@code void}, or an array type, this method returns
4581      * {@code false}.
4582      *
4583      * @return {@code true} if and only if this {@code Class} object represents a sealed class or interface.
4584      *
4585      * @jls 8.1 Class Declarations
4586      * @jls 9.1 Interface Declarations
4587      * @since 15
4588      */
4589     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.SEALED_CLASSES, essentialAPI=false)
4590     @SuppressWarnings(&quot;preview&quot;)
4591     public boolean isSealed() {
4592         if (isArray() || isPrimitive()) {
4593             return false;
4594         }
4595         return permittedSubclasses().length != 0;
4596     }
4597 
4598     private native String[] getPermittedSubclasses0();
4599 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>