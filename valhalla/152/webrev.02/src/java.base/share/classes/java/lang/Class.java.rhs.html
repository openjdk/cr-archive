<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.constant.ClassDesc;
  30 import java.lang.invoke.TypeDescriptor;
  31 import java.lang.invoke.MethodHandles;
  32 import java.lang.module.ModuleReader;
  33 import java.lang.ref.SoftReference;
  34 import java.io.IOException;
  35 import java.io.InputStream;
  36 import java.io.ObjectStreamField;
  37 import java.lang.reflect.AnnotatedElement;
  38 import java.lang.reflect.AnnotatedType;
  39 import java.lang.reflect.Array;
  40 import java.lang.reflect.Constructor;
  41 import java.lang.reflect.Executable;
  42 import java.lang.reflect.Field;
  43 import java.lang.reflect.GenericArrayType;
  44 import java.lang.reflect.GenericDeclaration;
  45 import java.lang.reflect.InvocationTargetException;
  46 import java.lang.reflect.Member;
  47 import java.lang.reflect.Method;
  48 import java.lang.reflect.Modifier;
  49 import java.lang.reflect.Proxy;
  50 import java.lang.reflect.RecordComponent;
  51 import java.lang.reflect.Type;
  52 import java.lang.reflect.TypeVariable;
  53 import java.lang.constant.Constable;
  54 import java.net.URL;
  55 import java.security.AccessController;
  56 import java.security.PrivilegedAction;
  57 import java.util.ArrayList;
  58 import java.util.Arrays;
  59 import java.util.Collection;
  60 import java.util.HashMap;
  61 import java.util.LinkedHashMap;
  62 import java.util.LinkedHashSet;
  63 import java.util.List;
  64 import java.util.Map;
  65 import java.util.Objects;
  66 import java.util.Optional;
  67 import java.util.stream.Collectors;
  68 
  69 import jdk.internal.HotSpotIntrinsicCandidate;
  70 import jdk.internal.loader.BootLoader;
  71 import jdk.internal.loader.BuiltinClassLoader;
  72 import jdk.internal.misc.Unsafe;
  73 import jdk.internal.module.Resources;
  74 import jdk.internal.reflect.CallerSensitive;
  75 import jdk.internal.reflect.ConstantPool;
  76 import jdk.internal.reflect.Reflection;
  77 import jdk.internal.reflect.ReflectionFactory;
  78 import jdk.internal.vm.annotation.ForceInline;
  79 import sun.invoke.util.Wrapper;
  80 import sun.reflect.generics.factory.CoreReflectionFactory;
  81 import sun.reflect.generics.factory.GenericsFactory;
  82 import sun.reflect.generics.repository.ClassRepository;
  83 import sun.reflect.generics.repository.MethodRepository;
  84 import sun.reflect.generics.repository.ConstructorRepository;
  85 import sun.reflect.generics.scope.ClassScope;
  86 import sun.security.util.SecurityConstants;
  87 import sun.reflect.annotation.*;
  88 import sun.reflect.misc.ReflectUtil;
  89 
  90 /**
  91  * Instances of the class {@code Class} represent classes and
  92  * interfaces in a running Java application. An enum type and a record
  93  * type are kinds of class; an annotation type is a kind of
  94  * interface. Every array also belongs to a class that is reflected as
  95  * a {@code Class} object that is shared by all arrays with the same
  96  * element type and number of dimensions.  The primitive Java types
  97  * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
  98  * int}, {@code long}, {@code float}, and {@code double}), and the
  99  * keyword {@code void} are also represented as {@code Class} objects.
 100  *
 101  * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
 102  * object is constructed automatically by the Java Virtual Machine when
 103  * a class is derived from the bytes of a {@code class} file through
 104  * the invocation of one of the following methods:
 105  * &lt;ul&gt;
 106  * &lt;li&gt; {@link ClassLoader#defineClass(String, byte[], int, int) ClassLoader::defineClass}
 107  * &lt;li&gt; {@link java.lang.invoke.MethodHandles.Lookup#defineClass(byte[])
 108  *      java.lang.invoke.MethodHandles.Lookup::defineClass}
 109  * &lt;li&gt; {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 110  *      java.lang.invoke.MethodHandles.Lookup::defineHiddenClass}
 111  * &lt;/ul&gt;
 112  *
 113  * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
 114  * class or interface. Most characteristics are derived from the {@code class}
 115  * file that the class loader passed to the Java Virtual Machine or
 116  * from the {@code class} file passed to {@code Lookup::defineClass}
 117  * or {@code Lookup::defineHiddenClass}.
 118  * A few characteristics are determined by the class loading environment
 119  * at run time, such as the module returned by {@link #getModule() getModule()}.
 120  *
 121  * &lt;p&gt; The following example uses a {@code Class} object to print the
 122  * class name of an object:
 123  *
 124  * &lt;blockquote&gt;&lt;pre&gt;
 125  *     void printClassName(Object obj) {
 126  *         System.out.println(&quot;The class of &quot; + obj +
 127  *                            &quot; is &quot; + obj.getClass().getName());
 128  *     }
 129  * &lt;/pre&gt;&lt;/blockquote&gt;
 130  *
 131  * It is also possible to get the {@code Class} object for a named
 132  * type (or for {@code void}) using a &lt;i&gt;class literal&lt;/i&gt;.
 133  * For example:
 134  *
 135  * &lt;blockquote&gt;
 136  *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}
 137  * &lt;/blockquote&gt;
 138  *
 139  * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
 140  * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
 141  * another declaration. Other methods describe how a class or interface
 142  * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
 143  * classes and interfaces, in the same run-time package, that
 144  * allow mutual access to their {@code private} members.
 145  * The classes and interfaces are known as &lt;em&gt;nestmates&lt;/em&gt;.
 146  * One nestmate acts as the
 147  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 148  * belong to the nest; each of them in turn records it as the nest host.
 149  * The classes and interfaces which belong to a nest, including its host, are
 150  * determined when
 151  * {@code class} files are generated, for example, a Java compiler
 152  * will typically record a top-level class as the host of a nest where the
 153  * other members are the classes and interfaces whose declarations are
 154  * enclosed within the top-level class declaration.
 155  *
 156  * &lt;p&gt; A class or interface created by the invocation of
 157  * {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 158  * Lookup::defineHiddenClass} is a {@linkplain Class#isHidden() &lt;em&gt;hidden&lt;/em&gt;}
 159  * class or interface.
 160  * All kinds of class, including enum types and record types, may be
 161  * hidden classes; all kinds of interface, including annotation types,
 162  * may be hidden interfaces.
 163  *
 164  * The {@linkplain #getName() name of a hidden class or interface} is
 165  * not a &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;,
 166  * which means the following:
 167  * &lt;ul&gt;
 168  * &lt;li&gt;A hidden class or interface cannot be referenced by the constant pools
 169  *     of other classes and interfaces.
 170  * &lt;li&gt;A hidden class or interface cannot be described in
 171  *     {@linkplain java.lang.constant.ConstantDesc &lt;em&gt;nominal form&lt;/em&gt;} by
 172  *     {@link #describeConstable() Class::describeConstable},
 173  *     {@link ClassDesc#of(String) ClassDesc::of}, or
 174  *     {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}.
 175  * &lt;li&gt;A hidden class or interface cannot be discovered by {@link #forName Class::forName}
 176  *     or {@link ClassLoader#loadClass(String, boolean) ClassLoader::loadClass}.
 177  * &lt;/ul&gt;
 178  *
 179  * A hidden class or interface is never an array class, but may be
 180  * the element type of an array. In all other respects, the fact that
 181  * a class or interface is hidden has no bearing on the characteristics
 182  * exposed by the methods of class {@code Class}.
 183  *
 184  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 185  * object.  For example, the type of {@code String.class} is {@code
 186  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 187  * unknown.
 188  *
 189  * @author  unascribed
 190  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 191  * @since   1.0
 192  * @jls 15.8.2 Class Literals
 193  */
 194 public final class Class&lt;T&gt; implements java.io.Serializable,
 195                               GenericDeclaration,
 196                               Type,
 197                               AnnotatedElement,
 198                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 199                               Constable {
 200     private static final int ANNOTATION = 0x00002000;
 201     private static final int ENUM       = 0x00004000;
 202     private static final int SYNTHETIC  = 0x00001000;
 203     private static final int INLINE     = 0x00000100;
 204 
 205     private static final ClassDesc[] EMPTY_CLASS_DESC_ARRAY = new ClassDesc[0];
 206 
 207     private static native void registerNatives();
 208     static {
 209         registerNatives();
 210     }
 211 
 212     /*
 213      * Private constructor. Only the Java Virtual Machine creates Class objects.
 214      * This constructor is not used and prevents the default constructor being
 215      * generated.
 216      */
 217     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 218         // Initialize final field for classLoader.  The initialization value of non-null
 219         // prevents future JIT optimizations from assuming this final field is null.
 220         classLoader = loader;
 221         componentType = arrayComponentType;
 222     }
 223 
 224     /**
 225      * Converts the object to a string. The string representation is the
 226      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 227      * name of the class in the format returned by {@code getName}.
 228      * If this {@code Class} object represents a primitive type,
 229      * this method returns the name of the primitive type.  If
 230      * this {@code Class} object represents void this method returns
 231      * &quot;void&quot;. If this {@code Class} object represents an array type,
 232      * this method returns &quot;class &quot; followed by {@code getName}.
 233      *
 234      * @return a string representation of this {@code Class} object.
 235      */
 236     public String toString() {
 237         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 238                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
 239                + getName();
 240     }
 241 
 242     /**
 243      * Returns a string describing this {@code Class}, including
 244      * information about modifiers and type parameters.
 245      *
 246      * The string is formatted as a list of type modifiers, if any,
 247      * followed by the kind of type (empty string for primitive types
 248      * and {@code class}, {@code enum}, {@code interface},
 249      * {@code @interface}, or {@code record} as appropriate), followed
 250      * by the type&#39;s name, followed by an angle-bracketed
 251      * comma-separated list of the type&#39;s type parameters, if any,
 252      * including informative bounds on the type parameters, if any.
 253      *
 254      * A space is used to separate modifiers from one another and to
 255      * separate any modifiers from the kind of type. The modifiers
 256      * occur in canonical order. If there are no type parameters, the
 257      * type parameter list is elided.
 258      *
 259      * For an array type, the string starts with the type name,
 260      * followed by an angle-bracketed comma-separated list of the
 261      * type&#39;s type parameters, if any, followed by a sequence of
 262      * {@code []} characters, one set of brackets per dimension of
 263      * the array.
 264      *
 265      * &lt;p&gt;Note that since information about the runtime representation
 266      * of a type is being generated, modifiers not present on the
 267      * originating source code or illegal on the originating source
 268      * code may be present.
 269      *
 270      * @return a string describing this {@code Class}, including
 271      * information about modifiers and type parameters
 272      *
 273      * @since 1.8
 274      */
 275     @SuppressWarnings(&quot;preview&quot;)
 276     public String toGenericString() {
 277         if (isPrimitive()) {
 278             return toString();
 279         } else {
 280             StringBuilder sb = new StringBuilder();
 281             Class&lt;?&gt; component = this;
 282             int arrayDepth = 0;
 283 
 284             if (isArray()) {
 285                 do {
 286                     arrayDepth++;
 287                     component = component.getComponentType();
 288                 } while (component.isArray());
 289                 sb.append(component.getName());
 290             } else {
 291                 // Class modifiers are a superset of interface modifiers
 292                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 293                 if (modifiers != 0) {
 294                     sb.append(Modifier.toString(modifiers));
 295                     sb.append(&#39; &#39;);
 296                 }
 297 
 298                 if (isAnnotation()) {
 299                     sb.append(&#39;@&#39;);
 300                 }
 301                 if (isInlineClass()) {
 302                     sb.append(&quot;inline&quot;);
 303                     sb.append(&#39; &#39;);
 304                 }
 305                 if (isInterface()) { // Note: all annotation types are interfaces
 306                     sb.append(&quot;interface&quot;);
 307                 } else {
 308                     if (isEnum())
 309                         sb.append(&quot;enum&quot;);
 310                     else if (isRecord())
 311                         sb.append(&quot;record&quot;);
 312                     else
 313                         sb.append(&quot;class&quot;);
 314                 }
 315                 sb.append(&#39; &#39;);
 316                 sb.append(getName());
 317             }
 318 
 319             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 320             if (typeparms.length &gt; 0) {
 321                 sb.append(Arrays.stream(typeparms)
 322                           .map(Class::typeVarBounds)
 323                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 324             }
 325 
 326             if (arrayDepth &gt; 0) sb.append(&quot;[]&quot;.repeat(arrayDepth));
 327 
 328             return sb.toString();
 329         }
 330     }
 331 
 332     static String typeVarBounds(TypeVariable&lt;?&gt; typeVar) {
 333         Type[] bounds = typeVar.getBounds();
 334         if (bounds.length == 1 &amp;&amp; bounds[0].equals(Object.class)) {
 335             return typeVar.getName();
 336         } else {
 337             return typeVar.getName() + &quot; extends &quot; +
 338                 Arrays.stream(bounds)
 339                 .map(Type::getTypeName)
 340                 .collect(Collectors.joining(&quot; &amp; &quot;));
 341         }
 342     }
 343 
 344     /**
 345      * Returns the {@code Class} object associated with the class or
 346      * interface with the given string name.  Invoking this method is
 347      * equivalent to:
 348      *
 349      * &lt;blockquote&gt;
 350      *  {@code Class.forName(className, true, currentLoader)}
 351      * &lt;/blockquote&gt;
 352      *
 353      * where {@code currentLoader} denotes the defining class loader of
 354      * the current class.
 355      *
 356      * &lt;p&gt; For example, the following code fragment returns the
 357      * runtime {@code Class} descriptor for the class named
 358      * {@code java.lang.Thread}:
 359      *
 360      * &lt;blockquote&gt;
 361      *   {@code Class t = Class.forName(&quot;java.lang.Thread&quot;)}
 362      * &lt;/blockquote&gt;
 363      * &lt;p&gt;
 364      * A call to {@code forName(&quot;X&quot;)} causes the class named
 365      * {@code X} to be initialized.
 366      *
 367      * @param      className   the fully qualified name of the desired class.
 368      * @return     the {@code Class} object for the class with the
 369      *             specified name.
 370      * @throws    LinkageError if the linkage fails
 371      * @throws    ExceptionInInitializerError if the initialization provoked
 372      *            by this method fails
 373      * @throws    ClassNotFoundException if the class cannot be located
 374      *
 375      * @jls 12.2 Loading of Classes and Interfaces
 376      * @jls 12.3 Linking of Classes and Interfaces
 377      * @jls 12.4 Initialization of Classes and Interfaces
 378      */
 379     @CallerSensitive
 380     public static Class&lt;?&gt; forName(String className)
 381                 throws ClassNotFoundException {
 382         Class&lt;?&gt; caller = Reflection.getCallerClass();
 383         return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
 384     }
 385 
 386 
 387     /**
 388      * Returns the {@code Class} object associated with the class or
 389      * interface with the given string name, using the given class loader.
 390      * Given the fully qualified name for a class or interface (in the same
 391      * format returned by {@code getName}) this method attempts to
 392      * locate and load the class or interface.  The specified class
 393      * loader is used to load the class or interface.  If the parameter
 394      * {@code loader} is null, the class is loaded through the bootstrap
 395      * class loader.  The class is initialized only if the
 396      * {@code initialize} parameter is {@code true} and if it has
 397      * not been initialized earlier.
 398      *
 399      * &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
 400      * will be made to locate a user-defined class in the unnamed package whose
 401      * name is {@code name}. Therefore, this method cannot be used to
 402      * obtain any of the {@code Class} objects representing primitive
 403      * types or void.
 404      *
 405      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 406      * the array class is loaded but not initialized.
 407      *
 408      * &lt;p&gt; For example, in an instance method the expression:
 409      *
 410      * &lt;blockquote&gt;
 411      *  {@code Class.forName(&quot;Foo&quot;)}
 412      * &lt;/blockquote&gt;
 413      *
 414      * is equivalent to:
 415      *
 416      * &lt;blockquote&gt;
 417      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 418      * &lt;/blockquote&gt;
 419      *
 420      * Note that this method throws errors related to loading, linking
 421      * or initializing as specified in Sections {@jls 12.2}, {@jls
 422      * 12.3}, and {@jls 12.4} of &lt;cite&gt;The Java&amp;trade; Language
 423      * Specification&lt;/cite&gt;.
 424      * Note that this method does not check whether the requested class
 425      * is accessible to its caller.
 426      *
 427      * @param name       fully qualified name of the desired class
 428 
 429      * @param initialize if {@code true} the class will be initialized
 430      *                   (which implies linking). See Section {@jls
 431      *                   12.4} of &lt;cite&gt;The Java&amp;trade; Language
 432      *                   Specification&lt;/cite&gt;.
 433      * @param loader     class loader from which the class must be loaded
 434      * @return           class object representing the desired class
 435      *
 436      * @throws    LinkageError if the linkage fails
 437      * @throws    ExceptionInInitializerError if the initialization provoked
 438      *            by this method fails
 439      * @throws    ClassNotFoundException if the class cannot be located by
 440      *            the specified class loader
 441      * @throws    SecurityException
 442      *            if a security manager is present, and the {@code loader} is
 443      *            {@code null}, and the caller&#39;s class loader is not
 444      *            {@code null}, and the caller does not have the
 445      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 446      *
 447      * @see       java.lang.Class#forName(String)
 448      * @see       java.lang.ClassLoader
 449      *
 450      * @jls 12.2 Loading of Classes and Interfaces
 451      * @jls 12.3 Linking of Classes and Interfaces
 452      * @jls 12.4 Initialization of Classes and Interfaces
 453      * @since     1.2
 454      */
 455     @CallerSensitive
 456     public static Class&lt;?&gt; forName(String name, boolean initialize,
 457                                    ClassLoader loader)
 458         throws ClassNotFoundException
 459     {
 460         Class&lt;?&gt; caller = null;
 461         SecurityManager sm = System.getSecurityManager();
 462         if (sm != null) {
 463             // Reflective call to get caller class is only needed if a security manager
 464             // is present.  Avoid the overhead of making this call otherwise.
 465             caller = Reflection.getCallerClass();
 466             if (loader == null) {
 467                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 468                 if (ccl != null) {
 469                     sm.checkPermission(
 470                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 471                 }
 472             }
 473         }
 474         return forName0(name, initialize, loader, caller);
 475     }
 476 
 477     /** Called after security check for system loader access checks have been made. */
 478     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
 479                                     ClassLoader loader,
 480                                     Class&lt;?&gt; caller)
 481         throws ClassNotFoundException;
 482 
 483 
 484     /**
 485      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 486      * binary name&lt;/a&gt; in the given module.
 487      *
 488      * &lt;p&gt; This method attempts to locate and load the class or interface.
 489      * It does not link the class, and does not run the class initializer.
 490      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 491      *
 492      * &lt;p&gt; If the class loader of the given module defines other modules and
 493      * the given name is a class defined in a different module, this method
 494      * returns {@code null} after the class is loaded. &lt;/p&gt;
 495      *
 496      * &lt;p&gt; This method does not check whether the requested class is
 497      * accessible to its caller. &lt;/p&gt;
 498      *
 499      * @apiNote
 500      * This method returns {@code null} on failure rather than
 501      * throwing a {@link ClassNotFoundException}, as is done by
 502      * the {@link #forName(String, boolean, ClassLoader)} method.
 503      * The security check is a stack-based permission check if the caller
 504      * loads a class in another module.
 505      *
 506      * @param  module   A module
 507      * @param  name     The &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 508      *                  of the class
 509      * @return {@code Class} object of the given name defined in the given module;
 510      *         {@code null} if not found.
 511      *
 512      * @throws NullPointerException if the given module or name is {@code null}
 513      *
 514      * @throws LinkageError if the linkage fails
 515      *
 516      * @throws SecurityException
 517      *         &lt;ul&gt;
 518      *         &lt;li&gt; if the caller is not the specified module and
 519      *         {@code RuntimePermission(&quot;getClassLoader&quot;)} permission is denied; or&lt;/li&gt;
 520      *         &lt;li&gt; access to the module content is denied. For example,
 521      *         permission check will be performed when a class loader calls
 522      *         {@link ModuleReader#open(String)} to read the bytes of a class file
 523      *         in a module.&lt;/li&gt;
 524      *         &lt;/ul&gt;
 525      *
 526      * @jls 12.2 Loading of Classes and Interfaces
 527      * @jls 12.3 Linking of Classes and Interfaces
 528      * @since 9
 529      * @spec JPMS
 530      */
 531     @CallerSensitive
 532     public static Class&lt;?&gt; forName(Module module, String name) {
 533         Objects.requireNonNull(module);
 534         Objects.requireNonNull(name);
 535 
 536         ClassLoader cl;
 537         SecurityManager sm = System.getSecurityManager();
 538         if (sm != null) {
 539             Class&lt;?&gt; caller = Reflection.getCallerClass();
 540             if (caller != null &amp;&amp; caller.getModule() != module) {
 541                 // if caller is null, Class.forName is the last java frame on the stack.
 542                 // java.base has all permissions
 543                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 544             }
 545             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 546             cl = AccessController.doPrivileged(pa);
 547         } else {
 548             cl = module.getClassLoader();
 549         }
 550 
 551         if (cl != null) {
 552             return cl.loadClass(module, name);
 553         } else {
 554             return BootLoader.loadClass(module, name);
 555         }
 556     }
 557 
 558     /**
 559      * Returns {@code true} if this class is an inline class.
 560      *
 561      * @return {@code true} if this class is an inline class
 562      * @since Valhalla
 563      */
 564     public boolean isInlineClass() {
 565         return (this.getModifiers() &amp; INLINE) != 0;
 566     }
 567 
 568     /**
 569      * Returns a {@code Class} object representing the &lt;em&gt;value projection&lt;/em&gt;
 570      * type of this class if this {@code Class} represents the reference projection
 571      * type of an {@linkplain #isInlineClass() inline class}.
 572      * If this {@code Class} represents the value projection type
 573      * of an inline class, then this method returns this class.
 574      * Otherwise an empty {@link Optional} is returned.
 575      *
 576      * @return the {@code Class} object representing the value projection type of
 577      *         this class if this class is the value projection type
 578      *         or the reference projection type of an inline class;
 579      *         an empty {@link Optional} otherwise
 580      * @since Valhalla
 581      */
<a name="1" id="anc1"></a><span class="line-modified"> 582     public Optional&lt;Class&lt;?&gt;&gt; valueType() {</span>
<span class="line-modified"> 583         if (isPrimitive() || isInterface() || isArray())</span>
<span class="line-added"> 584             return Optional.empty();</span>
<span class="line-added"> 585 </span>
<span class="line-added"> 586         Class&lt;?&gt;[] valRefTypes = getProjectionTypes();</span>
<span class="line-added"> 587         return valRefTypes.length &gt; 0 ? Optional.of(valRefTypes[0]) : Optional.empty();</span>
 588     }
 589 
 590     /**
<a name="2" id="anc2"></a><span class="line-modified"> 591      * Returns a {@code Class} object representing the reference type</span>
<span class="line-modified"> 592      * of this class.</span>
<span class="line-modified"> 593      * &lt;p&gt;</span>
<span class="line-modified"> 594      * If this {@code Class} represents an {@linkplain #isInlineClass()</span>
<span class="line-added"> 595      * inline class} with a reference projection type, then this method</span>
<span class="line-added"> 596      * returns the &lt;em&gt;reference projection&lt;/em&gt; type of this inline class.</span>
<span class="line-added"> 597      * &lt;p&gt;</span>
<span class="line-added"> 598      * If this {@code Class} represents the reference projection type</span>
 599      * of an inline class, then this method returns this class.
<a name="3" id="anc3"></a><span class="line-modified"> 600      * &lt;p&gt;</span>
<span class="line-modified"> 601      * If this class is an {@linkplain #isInlineClass() inline class}</span>
<span class="line-modified"> 602      * without a reference projection, then this method returns an empty</span>
<span class="line-added"> 603      * {@code Optional}.</span>
<span class="line-added"> 604      * &lt;p&gt;</span>
<span class="line-added"> 605      * If this class is an identity class, then this method returns this</span>
<span class="line-added"> 606      * class.</span>
<span class="line-added"> 607      * &lt;p&gt;</span>
<span class="line-added"> 608      * Otherwise this method returns an empty {@code Optional}.</span>
 609      *
<a name="4" id="anc4"></a><span class="line-modified"> 610      * @return the {@code Class} object representing a reference type for</span>
<span class="line-modified"> 611      *         this class if present; an empty {@link Optional} otherwise.</span>


 612      * @since Valhalla
 613      */
<a name="5" id="anc5"></a><span class="line-modified"> 614     public Optional&lt;Class&lt;?&gt;&gt; referenceType() {</span>
<span class="line-modified"> 615         if (isPrimitive()) return Optional.empty();</span>
<span class="line-added"> 616         if (isInterface() || isArray()) return Optional.of(this);</span>
<span class="line-added"> 617 </span>
<span class="line-added"> 618         Class&lt;?&gt;[] valRefTypes = getProjectionTypes();</span>
<span class="line-added"> 619         return valRefTypes.length == 2 ? Optional.of(valRefTypes[1]) : Optional.empty();</span>
<span class="line-added"> 620     }</span>
<span class="line-added"> 621 </span>
<span class="line-added"> 622     /*</span>
<span class="line-added"> 623      * Returns true if this Class object represents a reference projection</span>
<span class="line-added"> 624      * type for an inline class.</span>
<span class="line-added"> 625      *</span>
<span class="line-added"> 626      * A reference projection type must be a sealed abstract class that</span>
<span class="line-added"> 627      * permits the inline projection type to extend.  The inline projection</span>
<span class="line-added"> 628      * type and reference projection type for an inline type must be of</span>
<span class="line-added"> 629      * the same package.</span>
<span class="line-added"> 630      */</span>
<span class="line-added"> 631     private boolean isReferenceProjectionType() {</span>
<span class="line-added"> 632         if (isPrimitive() || isArray() || isInterface() || isInlineClass())</span>
<span class="line-added"> 633             return false;</span>
<span class="line-added"> 634 </span>
<span class="line-added"> 635         int mods = getModifiers();</span>
<span class="line-added"> 636         if (!Modifier.isAbstract(mods)) {</span>
<span class="line-added"> 637             return false;</span>
<span class="line-added"> 638         }</span>
<span class="line-added"> 639 </span>
<span class="line-added"> 640         Class&lt;?&gt;[] valRefTypes = getProjectionTypes();</span>
<span class="line-added"> 641         return valRefTypes.length == 2 &amp;&amp; valRefTypes[1] == this;</span>
<span class="line-added"> 642     }</span>
<span class="line-added"> 643 </span>
<span class="line-added"> 644     private transient Class&lt;?&gt;[] projectionTypes;</span>
<span class="line-added"> 645     private Class&lt;?&gt;[] getProjectionTypes() {</span>
<span class="line-added"> 646         ensureProjectionTypesInited();</span>
<span class="line-added"> 647         return projectionTypes;</span>
<span class="line-added"> 648     }</span>
<span class="line-added"> 649 </span>
<span class="line-added"> 650     /*</span>
<span class="line-added"> 651      * Returns an array of Class object whose element at index 0 represents the</span>
<span class="line-added"> 652      * value projection type and element at index 1 represents the reference</span>
<span class="line-added"> 653      * projection type if present.</span>
<span class="line-added"> 654      *</span>
<span class="line-added"> 655      * If this Class object is neither a value projection type nor</span>
<span class="line-added"> 656      * a reference projection type for an inline class, then an empty array</span>
<span class="line-added"> 657      * is returned.</span>
<span class="line-added"> 658      */</span>
<span class="line-added"> 659     private Class&lt;?&gt;[] newProjectionTypeArray() {</span>
<span class="line-added"> 660         if (isPrimitive() || isArray() || isInterface())</span>
<span class="line-added"> 661             return null;</span>
<span class="line-added"> 662 </span>
<span class="line-added"> 663         if (isInlineClass()) {</span>
<span class="line-added"> 664             Class&lt;?&gt; superClass = getSuperclass();</span>
<span class="line-added"> 665             if (superClass != Object.class &amp;&amp; superClass.isReferenceProjectionType()) {</span>
<span class="line-added"> 666                 return new Class&lt;?&gt;[] { this, superClass };</span>
<span class="line-added"> 667             } else {</span>
<span class="line-added"> 668                 return new Class&lt;?&gt;[] { this };</span>
<span class="line-added"> 669             }</span>
<span class="line-added"> 670         } else {</span>
<span class="line-added"> 671             Class&lt;?&gt; valType = valueProjectionType();</span>
<span class="line-added"> 672             if (valType != null) {</span>
<span class="line-added"> 673                 return new Class&lt;?&gt;[] { valType, this};</span>
<span class="line-added"> 674             } else {</span>
<span class="line-added"> 675                 return EMPTY_CLASS_ARRAY;</span>
<span class="line-added"> 676             }</span>
<span class="line-added"> 677         }</span>
 678     }
 679 
<a name="6" id="anc6"></a><span class="line-modified"> 680     /*</span>
<span class="line-modified"> 681      * Returns the value projection type if this Class represents</span>
<span class="line-modified"> 682      * a reference projection type.  If this class is an inline class</span>
<span class="line-modified"> 683      * then this method returns this class.  Otherwise, returns null.</span>
<span class="line-added"> 684      */</span>
<span class="line-added"> 685     private Class&lt;?&gt; valueProjectionType() {</span>
<span class="line-added"> 686         if (isPrimitive() || isArray() || isInterface())</span>
<span class="line-added"> 687             return null;</span>
<span class="line-added"> 688 </span>
<span class="line-added"> 689         if (isInlineClass())</span>
<span class="line-added"> 690             return this;</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692         int mods = getModifiers();</span>
<span class="line-added"> 693         if (!Modifier.isAbstract(mods)) {</span>
<span class="line-added"> 694             return null;</span>
<span class="line-added"> 695         }</span>
<span class="line-added"> 696 </span>
<span class="line-added"> 697         // A reference projection type must be a sealed abstract class</span>
<span class="line-added"> 698         // that permits the inline projection type to extend.</span>
<span class="line-added"> 699         // The inline projection type and reference projection type for</span>
<span class="line-added"> 700         // an inline type must be of the same package.</span>
<span class="line-added"> 701         String[] subclassNames = getPermittedSubclasses0();</span>
<span class="line-added"> 702         if (subclassNames.length == 1) {</span>
<span class="line-added"> 703             String cn = subclassNames[0].replace(&#39;/&#39;, &#39;.&#39;);</span>
<span class="line-added"> 704             int index = cn.lastIndexOf(&#39;.&#39;);</span>
<span class="line-added"> 705             String pn = index &gt; 0 ? cn.substring(0, index) : &quot;&quot;;</span>
<span class="line-added"> 706             if (pn.equals(getPackageName())) {</span>
<span class="line-added"> 707                 try {</span>
<span class="line-added"> 708                     Class&lt;?&gt; valType = Class.forName(cn, false, getClassLoader());</span>
<span class="line-added"> 709                     if (valType.isInlineClass()) {</span>
<span class="line-added"> 710                         return valType;</span>
<span class="line-added"> 711                     }</span>
<span class="line-added"> 712                 } catch (ClassNotFoundException e) {}</span>
<span class="line-added"> 713             }</span>
<span class="line-added"> 714         }</span>
<span class="line-added"> 715         return null;</span>
<span class="line-added"> 716     }</span>
<span class="line-added"> 717 </span>
<span class="line-added"> 718     private void ensureProjectionTypesInited() {</span>
<span class="line-added"> 719         if (isPrimitive() || isArray() || isInterface())</span>
<span class="line-added"> 720             return;</span>
<span class="line-added"> 721 </span>
<span class="line-added"> 722         Class&lt;?&gt;[] valRefTypes = projectionTypes;</span>
<span class="line-added"> 723         if (valRefTypes == null) {</span>
<span class="line-added"> 724             // C.ensureProjectionTypesInited calls initProjectionTypes that may</span>
<span class="line-added"> 725             // call D.ensureProjectionTypesInited where D is its superclass.</span>
<span class="line-added"> 726             // So initProjectionTypes is called without holding any lock to</span>
<span class="line-added"> 727             // avoid deadlock when multiple threads attempt to ensure</span>
<span class="line-added"> 728             valRefTypes = newProjectionTypeArray();</span>
<span class="line-added"> 729         }</span>
<span class="line-added"> 730         synchronized (this) {</span>
<span class="line-added"> 731             if (projectionTypes == null) {</span>
<span class="line-added"> 732                 projectionTypes = valRefTypes;</span>
<span class="line-added"> 733             }</span>
<span class="line-added"> 734         }</span>
<span class="line-added"> 735     }</span>
 736 
 737     /**
 738      * Creates a new instance of the class represented by this {@code Class}
 739      * object.  The class is instantiated as if by a {@code new}
 740      * expression with an empty argument list.  The class is initialized if it
 741      * has not already been initialized.
 742      *
 743      * @deprecated This method propagates any exception thrown by the
 744      * nullary constructor, including a checked exception.  Use of
 745      * this method effectively bypasses the compile-time exception
 746      * checking that would otherwise be performed by the compiler.
 747      * The {@link
 748      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 749      * Constructor.newInstance} method avoids this problem by wrapping
 750      * any exception thrown by the constructor in a (checked) {@link
 751      * java.lang.reflect.InvocationTargetException}.
 752      *
 753      * &lt;p&gt;The call
 754      *
 755      * &lt;pre&gt;{@code
 756      * clazz.newInstance()
 757      * }&lt;/pre&gt;
 758      *
 759      * can be replaced by
 760      *
 761      * &lt;pre&gt;{@code
 762      * clazz.getDeclaredConstructor().newInstance()
 763      * }&lt;/pre&gt;
 764      *
 765      * The latter sequence of calls is inferred to be able to throw
 766      * the additional exception types {@link
 767      * InvocationTargetException} and {@link
 768      * NoSuchMethodException}. Both of these exception types are
 769      * subclasses of {@link ReflectiveOperationException}.
 770      *
 771      * @return  a newly allocated instance of the class represented by this
 772      *          object.
 773      * @throws  IllegalAccessException  if the class or its nullary
 774      *          constructor is not accessible.
 775      * @throws  InstantiationException
 776      *          if this {@code Class} represents an abstract class,
 777      *          an interface, an array class, a primitive type, or void;
 778      *          or if the class has no nullary constructor;
 779      *          or if the instantiation fails for some other reason.
 780      * @throws  ExceptionInInitializerError if the initialization
 781      *          provoked by this method fails.
 782      * @throws  SecurityException
 783      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
 784      *          the caller&#39;s class loader is not the same as or an
 785      *          ancestor of the class loader for the current class and
 786      *          invocation of {@link SecurityManager#checkPackageAccess
 787      *          s.checkPackageAccess()} denies access to the package
 788      *          of this class.
 789      */
 790     @CallerSensitive
 791     @Deprecated(since=&quot;9&quot;)
 792     public T newInstance()
 793         throws InstantiationException, IllegalAccessException
 794     {
 795         SecurityManager sm = System.getSecurityManager();
 796         if (sm != null) {
 797             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
 798         }
 799 
 800         // Constructor lookup
 801         Constructor&lt;T&gt; tmpConstructor = cachedConstructor;
 802         if (tmpConstructor == null) {
 803             if (this == Class.class) {
 804                 throw new IllegalAccessException(
 805                     &quot;Can not call newInstance() on the Class for java.lang.Class&quot;
 806                 );
 807             }
 808             try {
 809                 Class&lt;?&gt;[] empty = {};
 810                 final Constructor&lt;T&gt; c = getReflectionFactory().copyConstructor(
 811                     getConstructor0(empty, Member.DECLARED));
 812                 // Disable accessibility checks on the constructor
 813                 // access check is done with the true caller
 814                 java.security.AccessController.doPrivileged(
 815                     new java.security.PrivilegedAction&lt;&gt;() {
 816                         public Void run() {
 817                                 c.setAccessible(true);
 818                                 return null;
 819                             }
 820                         });
 821                 cachedConstructor = tmpConstructor = c;
 822             } catch (NoSuchMethodException e) {
 823                 throw (InstantiationException)
 824                     new InstantiationException(getName()).initCause(e);
 825             }
 826         }
 827 
 828         try {
 829             Class&lt;?&gt; caller = Reflection.getCallerClass();
 830             return getReflectionFactory().newInstance(tmpConstructor, null, caller);
 831         } catch (InvocationTargetException e) {
 832             Unsafe.getUnsafe().throwException(e.getTargetException());
 833             // Not reached
 834             return null;
 835         }
 836     }
 837 
 838     private transient volatile Constructor&lt;T&gt; cachedConstructor;
 839 
 840     /**
 841      * Determines if the specified {@code Object} is assignment-compatible
 842      * with the object represented by this {@code Class}.  This method is
 843      * the dynamic equivalent of the Java language {@code instanceof}
 844      * operator. The method returns {@code true} if the specified
 845      * {@code Object} argument is non-null and can be cast to the
 846      * reference type represented by this {@code Class} object without
 847      * raising a {@code ClassCastException.} It returns {@code false}
 848      * otherwise.
 849      *
 850      * &lt;p&gt; Specifically, if this {@code Class} object represents a
 851      * declared class, this method returns {@code true} if the specified
 852      * {@code Object} argument is an instance of the represented class (or
 853      * of any of its subclasses); it returns {@code false} otherwise. If
 854      * this {@code Class} object represents an array class, this method
 855      * returns {@code true} if the specified {@code Object} argument
 856      * can be converted to an object of the array class by an identity
 857      * conversion or by a widening reference conversion; it returns
 858      * {@code false} otherwise. If this {@code Class} object
 859      * represents an interface, this method returns {@code true} if the
 860      * class or any superclass of the specified {@code Object} argument
 861      * implements this interface; it returns {@code false} otherwise. If
 862      * this {@code Class} object represents a primitive type, this method
 863      * returns {@code false}.
 864      *
 865      * @param   obj the object to check
 866      * @return  true if {@code obj} is an instance of this class
 867      *
 868      * @since 1.1
 869      */
 870     @HotSpotIntrinsicCandidate
 871     public native boolean isInstance(Object obj);
 872 
 873 
 874     /**
 875      * Determines if the class or interface represented by this
 876      * {@code Class} object is either the same as, or is a superclass or
 877      * superinterface of, the class or interface represented by the specified
 878      * {@code Class} parameter. It returns {@code true} if so;
 879      * otherwise it returns {@code false}. If this {@code Class}
 880      * object represents a primitive type, this method returns
 881      * {@code true} if the specified {@code Class} parameter is
 882      * exactly this {@code Class} object; otherwise it returns
 883      * {@code false}.
 884      *
 885      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 886      * specified {@code Class} parameter can be converted to the type
 887      * represented by this {@code Class} object via an identity conversion
 888      * or via a widening reference conversion. See &lt;cite&gt;The Java&amp;trade; Language
 889      * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},
 890      * for details.
 891      *
 892      * @param     cls the {@code Class} object to be checked
 893      * @return    the {@code boolean} value indicating whether objects of the
 894      *            type {@code cls} can be assigned to objects of this class
 895      * @throws    NullPointerException if the specified Class parameter is
 896      *            null.
 897      * @since     1.1
 898      */
 899     @HotSpotIntrinsicCandidate
 900     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 901 
 902 
 903     /**
 904      * Determines if this {@code Class} object represents an
 905      * interface type.
 906      *
 907      * @return  {@code true} if this {@code Class} object represents an interface;
 908      *          {@code false} otherwise.
 909      */
 910     @HotSpotIntrinsicCandidate
 911     public native boolean isInterface();
 912 
 913 
 914     /**
 915      * Determines if this {@code Class} object represents an array class.
 916      *
 917      * @return  {@code true} if this {@code Class} object represents an array class;
 918      *          {@code false} otherwise.
 919      * @since   1.1
 920      */
 921     @HotSpotIntrinsicCandidate
 922     public native boolean isArray();
 923 
 924 
 925     /**
 926      * Determines if the specified {@code Class} object represents a
 927      * primitive type.
 928      *
 929      * &lt;p&gt; There are nine predefined {@code Class} objects to represent
 930      * the eight primitive types and void.  These are created by the Java
 931      * Virtual Machine, and have the same names as the primitive types that
 932      * they represent, namely {@code boolean}, {@code byte},
 933      * {@code char}, {@code short}, {@code int},
 934      * {@code long}, {@code float}, and {@code double}.
 935      *
 936      * &lt;p&gt; These objects may only be accessed via the following public static
 937      * final variables, and are the only {@code Class} objects for which
 938      * this method returns {@code true}.
 939      *
 940      * @return true if and only if this class represents a primitive type
 941      *
 942      * @see     java.lang.Boolean#TYPE
 943      * @see     java.lang.Character#TYPE
 944      * @see     java.lang.Byte#TYPE
 945      * @see     java.lang.Short#TYPE
 946      * @see     java.lang.Integer#TYPE
 947      * @see     java.lang.Long#TYPE
 948      * @see     java.lang.Float#TYPE
 949      * @see     java.lang.Double#TYPE
 950      * @see     java.lang.Void#TYPE
 951      * @since 1.1
 952      */
 953     @HotSpotIntrinsicCandidate
 954     public native boolean isPrimitive();
 955 
 956     /**
 957      * Returns true if this {@code Class} object represents an annotation
 958      * type.  Note that if this method returns true, {@link #isInterface()}
 959      * would also return true, as all annotation types are also interfaces.
 960      *
 961      * @return {@code true} if this {@code Class} object represents an annotation
 962      *      type; {@code false} otherwise
 963      * @since 1.5
 964      */
 965     public boolean isAnnotation() {
 966         return (getModifiers() &amp; ANNOTATION) != 0;
 967     }
 968 
 969     /**
 970      * Returns {@code true} if and only if this class has the synthetic modifier
 971      * bit set.
 972      *
 973      * @return {@code true} if and only if this class has the synthetic modifier bit set
 974      * @jls 13.1 The Form of a Binary
 975      * @jvms 4.1 The {@code ClassFile} Structure
 976      * @since 1.5
 977      */
 978     public boolean isSynthetic() {
 979         return (getModifiers() &amp; SYNTHETIC) != 0;
 980     }
 981 
 982     /**
 983      * Returns the  name of the entity (class, interface, array class,
 984      * primitive type, or void) represented by this {@code Class} object.
 985      *
 986      * &lt;p&gt; If this {@code Class} object represents a class or interface,
 987      * not an array class, then:
 988      * &lt;ul&gt;
 989      * &lt;li&gt; If the class or interface is not {@linkplain #isHidden() hidden},
 990      *      then the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 991      *      of the class or interface is returned.
 992      * &lt;li&gt; If the class or interface is hidden, then the result is a string
 993      *      of the form: {@code N + &#39;/&#39; + &lt;suffix&gt;}
 994      *      where {@code N} is the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 995      *      indicated by the {@code class} file passed to
 996      *      {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 997      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.
 998      * &lt;/ul&gt;
 999      *
1000      * &lt;p&gt; If this {@code Class} object represents an array class, then
1001      * the result is a string consisting of one or more &#39;{@code [}&#39; characters
1002      * representing the depth of the array nesting, followed by the element
1003      * type as encoded using the following table:
1004      *
1005      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
1006      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
1007      * &lt;thead&gt;
1008      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
1009      * &lt;/thead&gt;
1010      * &lt;tbody style=&quot;text-align:left&quot;&gt;
1011      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code boolean} &lt;td style=&quot;text-align:center&quot;&gt; {@code Z}
1012      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code byte}    &lt;td style=&quot;text-align:center&quot;&gt; {@code B}
1013      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code char}    &lt;td style=&quot;text-align:center&quot;&gt; {@code C}
1014      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;
1015      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code L}&lt;em&gt;N&lt;/em&gt;{@code ;}
1016      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@linkplain #isInlineClass() inline class} with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;
1017      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code Q}&lt;em&gt;N&lt;/em&gt;{@code ;}
1018      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code double}  &lt;td style=&quot;text-align:center&quot;&gt; {@code D}
1019      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code float}   &lt;td style=&quot;text-align:center&quot;&gt; {@code F}
1020      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code int}     &lt;td style=&quot;text-align:center&quot;&gt; {@code I}
1021      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code long}    &lt;td style=&quot;text-align:center&quot;&gt; {@code J}
1022      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code short}   &lt;td style=&quot;text-align:center&quot;&gt; {@code S}
1023      * &lt;/tbody&gt;
1024      * &lt;/table&gt;&lt;/blockquote&gt;
1025      *
1026      * &lt;p&gt; If this {@code Class} object represents a primitive type or {@code void},
1027      * then the result is a string with the same spelling as the Java language
1028      * keyword which corresponds to the primitive type or {@code void}.
1029      *
1030      * &lt;p&gt; Examples:
1031      * &lt;blockquote&gt;&lt;pre&gt;
1032      * String.class.getName()
1033      *     returns &quot;java.lang.String&quot;
1034      * byte.class.getName()
1035      *     returns &quot;byte&quot;
1036      * Point.class.getName()
1037      *     returns &quot;Point&quot;
1038      * (new Object[3]).getClass().getName()
1039      *     returns &quot;[Ljava.lang.Object;&quot;
1040      * (new Point[3]).getClass().getName()
1041      *     returns &quot;[QPoint;&quot;
1042      * (new Point.ref[3][4]).getClass().getName()
1043      *     returns &quot;[[LPoint$ref;&quot;
1044      * (new int[3][4][5][6][7][8][9]).getClass().getName()
1045      *     returns &quot;[[[[[[[I&quot;
1046      * &lt;/pre&gt;&lt;/blockquote&gt;
1047      *
1048      * @return  the name of the class, interface, or other entity
1049      *          represented by this {@code Class} object.
1050      * @jls 13.1 The Form of a Binary
1051      */
1052     public String getName() {
1053         String name = this.name;
1054         return name != null ? name : initClassName();
1055     }
1056 
1057     // Cache the name to reduce the number of calls into the VM.
1058     // This field would be set by VM itself during initClassName call.
1059     private transient String name;
1060     private native String initClassName();
1061 
1062     /**
1063      * Returns the class loader for the class.  Some implementations may use
1064      * null to represent the bootstrap class loader. This method will return
1065      * null in such implementations if this class was loaded by the bootstrap
1066      * class loader.
1067      *
1068      * &lt;p&gt;If this {@code Class} object
1069      * represents a primitive type or void, null is returned.
1070      *
1071      * @return  the class loader that loaded the class or interface
1072      *          represented by this {@code Class} object.
1073      * @throws  SecurityException
1074      *          if a security manager is present, and the caller&#39;s class loader
1075      *          is not {@code null} and is not the same as or an ancestor of the
1076      *          class loader for the class whose class loader is requested,
1077      *          and the caller does not have the
1078      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
1079      * @see java.lang.ClassLoader
1080      * @see SecurityManager#checkPermission
1081      * @see java.lang.RuntimePermission
1082      */
1083     @CallerSensitive
1084     @ForceInline // to ensure Reflection.getCallerClass optimization
1085     public ClassLoader getClassLoader() {
1086         ClassLoader cl = getClassLoader0();
1087         if (cl == null)
1088             return null;
1089         SecurityManager sm = System.getSecurityManager();
1090         if (sm != null) {
1091             ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
1092         }
1093         return cl;
1094     }
1095 
1096     // Package-private to allow ClassLoader access
1097     ClassLoader getClassLoader0() { return classLoader; }
1098 
1099     /**
1100      * Returns the module that this class or interface is a member of.
1101      *
1102      * If this class represents an array type then this method returns the
1103      * {@code Module} for the element type. If this class represents a
1104      * primitive type or void, then the {@code Module} object for the
1105      * {@code java.base} module is returned.
1106      *
1107      * If this class is in an unnamed module then the {@linkplain
1108      * ClassLoader#getUnnamedModule() unnamed} {@code Module} of the class
1109      * loader for this class is returned.
1110      *
1111      * @return the module that this class or interface is a member of
1112      *
1113      * @since 9
1114      * @spec JPMS
1115      */
1116     public Module getModule() {
1117         return module;
1118     }
1119 
1120     // set by VM
1121     private transient Module module;
1122 
1123     // Initialized in JVM not by private constructor
1124     // This field is filtered from reflection access, i.e. getDeclaredField
1125     // will throw NoSuchFieldException
1126     private final ClassLoader classLoader;
1127 
1128     // Set by VM
1129     private transient Object classData;
1130 
1131     // package-private
1132     Object getClassData() {
1133         return classData;
1134     }
1135 
1136     /**
1137      * Returns an array of {@code TypeVariable} objects that represent the
1138      * type variables declared by the generic declaration represented by this
1139      * {@code GenericDeclaration} object, in declaration order.  Returns an
1140      * array of length 0 if the underlying generic declaration declares no type
1141      * variables.
1142      *
1143      * @return an array of {@code TypeVariable} objects that represent
1144      *     the type variables declared by this generic declaration
1145      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1146      *     signature of this generic declaration does not conform to
1147      *     the format specified in section {@jvms 4.7.9} of
1148      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
1149      * @since 1.5
1150      */
1151     @SuppressWarnings(&quot;unchecked&quot;)
1152     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
1153         ClassRepository info = getGenericInfo();
1154         if (info != null)
1155             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
1156         else
1157             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
1158     }
1159 
1160 
1161     /**
1162      * Returns the {@code Class} representing the direct superclass of the
1163      * entity (class, interface, primitive type or void) represented by
1164      * this {@code Class}.  If this {@code Class} represents either the
1165      * {@code Object} class, an interface, a primitive type, or void, then
1166      * null is returned.  If this {@code Class} object represents an array class
1167      * then the {@code Class} object representing the {@code Object} class is
1168      * returned.
1169      *
1170      * @return the direct superclass of the class represented by this {@code Class} object
1171      */
1172     @HotSpotIntrinsicCandidate
1173     public native Class&lt;? super T&gt; getSuperclass();
1174 
1175 
1176     /**
1177      * Returns the {@code Type} representing the direct superclass of
1178      * the entity (class, interface, primitive type or void) represented by
1179      * this {@code Class} object.
1180      *
1181      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
1182      * object returned must accurately reflect the actual type
1183      * arguments used in the source code. The parameterized type
1184      * representing the superclass is created if it had not been
1185      * created before. See the declaration of {@link
1186      * java.lang.reflect.ParameterizedType ParameterizedType} for the
1187      * semantics of the creation process for parameterized types.  If
1188      * this {@code Class} object represents either the {@code Object}
1189      * class, an interface, a primitive type, or void, then null is
1190      * returned.  If this {@code Class} object represents an array class
1191      * then the {@code Class} object representing the {@code Object} class is
1192      * returned.
1193      *
1194      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1195      *     class signature does not conform to the format specified in
1196      *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual
1197      *     Machine Specification&lt;/cite&gt;
1198      * @throws TypeNotPresentException if the generic superclass
1199      *     refers to a non-existent type declaration
1200      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
1201      *     generic superclass refers to a parameterized type that cannot be
1202      *     instantiated  for any reason
1203      * @return the direct superclass of the class represented by this {@code Class} object
1204      * @since 1.5
1205      */
1206     public Type getGenericSuperclass() {
1207         ClassRepository info = getGenericInfo();
1208         if (info == null) {
1209             return getSuperclass();
1210         }
1211 
1212         // Historical irregularity:
1213         // Generic signature marks interfaces with superclass = Object
1214         // but this API returns null for interfaces
1215         if (isInterface()) {
1216             return null;
1217         }
1218 
1219         return info.getSuperclass();
1220     }
1221 
1222     /**
1223      * Gets the package of this class.
1224      *
1225      * &lt;p&gt;If this class represents an array type, a primitive type or void,
1226      * this method returns {@code null}.
1227      *
1228      * @return the package of this class.
1229      * @revised 9
1230      * @spec JPMS
1231      */
1232     public Package getPackage() {
1233         if (isPrimitive() || isArray()) {
1234             return null;
1235         }
1236         ClassLoader cl = getClassLoader0();
1237         return cl != null ? cl.definePackage(this)
1238                           : BootLoader.definePackage(this);
1239     }
1240 
1241     /**
1242      * Returns the fully qualified package name.
1243      *
1244      * &lt;p&gt; If this class is a top level class, then this method returns the fully
1245      * qualified name of the package that the class is a member of, or the
1246      * empty string if the class is in an unnamed package.
1247      *
1248      * &lt;p&gt; If this class is a member class, then this method is equivalent to
1249      * invoking {@code getPackageName()} on the {@linkplain #getEnclosingClass
1250      * enclosing class}.
1251      *
1252      * &lt;p&gt; If this class is a {@linkplain #isLocalClass local class} or an {@linkplain
1253      * #isAnonymousClass() anonymous class}, then this method is equivalent to
1254      * invoking {@code getPackageName()} on the {@linkplain #getDeclaringClass
1255      * declaring class} of the {@linkplain #getEnclosingMethod enclosing method} or
1256      * {@linkplain #getEnclosingConstructor enclosing constructor}.
1257      *
1258      * &lt;p&gt; If this class represents an array type then this method returns the
1259      * package name of the element type. If this class represents a primitive
1260      * type or void then the package name &quot;{@code java.lang}&quot; is returned.
1261      *
1262      * @return the fully qualified package name
1263      *
1264      * @since 9
1265      * @spec JPMS
1266      * @jls 6.7 Fully Qualified Names
1267      */
1268     public String getPackageName() {
1269         String pn = this.packageName;
1270         if (pn == null) {
1271             Class&lt;?&gt; c = isArray() ? elementType() : this;
1272             if (c.isPrimitive()) {
1273                 pn = &quot;java.lang&quot;;
1274             } else {
1275                 String cn = c.getName();
1276                 int dot = cn.lastIndexOf(&#39;.&#39;);
1277                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1278             }
1279             this.packageName = pn;
1280         }
1281         return pn;
1282     }
1283 
1284     // cached package name
1285     private transient String packageName;
1286 
1287     /**
1288      * Returns the interfaces directly implemented by the class or interface
1289      * represented by this {@code Class} object.
1290      *
1291      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1292      * containing objects representing all interfaces directly implemented by
1293      * the class.  The order of the interface objects in the array corresponds
1294      * to the order of the interface names in the {@code implements} clause of
1295      * the declaration of the class represented by this {@code Class} object.  For example,
1296      * given the declaration:
1297      * &lt;blockquote&gt;
1298      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
1299      * &lt;/blockquote&gt;
1300      * suppose the value of {@code s} is an instance of
1301      * {@code Shimmer}; the value of the expression:
1302      * &lt;blockquote&gt;
1303      * {@code s.getClass().getInterfaces()[0]}
1304      * &lt;/blockquote&gt;
1305      * is the {@code Class} object that represents interface
1306      * {@code FloorWax}; and the value of:
1307      * &lt;blockquote&gt;
1308      * {@code s.getClass().getInterfaces()[1]}
1309      * &lt;/blockquote&gt;
1310      * is the {@code Class} object that represents interface
1311      * {@code DessertTopping}.
1312      *
1313      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1314      * representing all interfaces directly extended by the interface.  The
1315      * order of the interface objects in the array corresponds to the order of
1316      * the interface names in the {@code extends} clause of the declaration of
1317      * the interface represented by this {@code Class} object.
1318      *
1319      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1320      * interfaces, the method returns an array of length 0.
1321      *
1322      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1323      * returns an array of length 0.
1324      *
1325      * &lt;p&gt;If this {@code Class} object represents an array type, the
1326      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1327      * returned in that order.
1328      *
1329      * @return an array of interfaces directly implemented by this class
1330      */
1331     public Class&lt;?&gt;[] getInterfaces() {
1332         // defensively copy before handing over to user code
1333         return getInterfaces(true);
1334     }
1335 
1336     private Class&lt;?&gt;[] getInterfaces(boolean cloneArray) {
1337         ReflectionData&lt;T&gt; rd = reflectionData();
1338         if (rd == null) {
1339             // no cloning required
1340             return getInterfaces0();
1341         } else {
1342             Class&lt;?&gt;[] interfaces = rd.interfaces;
1343             if (interfaces == null) {
1344                 interfaces = getInterfaces0();
1345                 rd.interfaces = interfaces;
1346             }
1347             // defensively copy if requested
1348             return cloneArray ? interfaces.clone() : interfaces;
1349         }
1350     }
1351 
1352     private native Class&lt;?&gt;[] getInterfaces0();
1353 
1354     /**
1355      * Returns the {@code Type}s representing the interfaces
1356      * directly implemented by the class or interface represented by
1357      * this {@code Class} object.
1358      *
1359      * &lt;p&gt;If a superinterface is a parameterized type, the
1360      * {@code Type} object returned for it must accurately reflect
1361      * the actual type arguments used in the source code. The
1362      * parameterized type representing each superinterface is created
1363      * if it had not been created before. See the declaration of
1364      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1365      * for the semantics of the creation process for parameterized
1366      * types.
1367      *
1368      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1369      * containing objects representing all interfaces directly implemented by
1370      * the class.  The order of the interface objects in the array corresponds
1371      * to the order of the interface names in the {@code implements} clause of
1372      * the declaration of the class represented by this {@code Class} object.
1373      *
1374      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1375      * representing all interfaces directly extended by the interface.  The
1376      * order of the interface objects in the array corresponds to the order of
1377      * the interface names in the {@code extends} clause of the declaration of
1378      * the interface represented by this {@code Class} object.
1379      *
1380      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1381      * interfaces, the method returns an array of length 0.
1382      *
1383      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1384      * returns an array of length 0.
1385      *
1386      * &lt;p&gt;If this {@code Class} object represents an array type, the
1387      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1388      * returned in that order.
1389      *
1390      * @throws java.lang.reflect.GenericSignatureFormatError
1391      *     if the generic class signature does not conform to the
1392      *     format specified in section {@jvms 4.7.9} of &lt;cite&gt;The
1393      *     Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
1394      * @throws TypeNotPresentException if any of the generic
1395      *     superinterfaces refers to a non-existent type declaration
1396      * @throws java.lang.reflect.MalformedParameterizedTypeException
1397      *     if any of the generic superinterfaces refer to a parameterized
1398      *     type that cannot be instantiated for any reason
1399      * @return an array of interfaces directly implemented by this class
1400      * @since 1.5
1401      */
1402     public Type[] getGenericInterfaces() {
1403         ClassRepository info = getGenericInfo();
1404         return (info == null) ?  getInterfaces() : info.getSuperInterfaces();
1405     }
1406 
1407 
1408     /**
1409      * Returns the {@code Class} representing the component type of an
1410      * array.  If this class does not represent an array class this method
1411      * returns null.
1412      *
1413      * @return the {@code Class} representing the component type of this
1414      * class if this class is an array
1415      * @see     java.lang.reflect.Array
1416      * @since 1.1
1417      */
1418     public Class&lt;?&gt; getComponentType() {
1419         // Only return for array types. Storage may be reused for Class for instance types.
1420         if (isArray()) {
1421             return componentType;
1422         } else {
1423             return null;
1424         }
1425     }
1426 
1427     private final Class&lt;?&gt; componentType;
1428 
1429     /*
1430      * Returns the {@code Class} representing the element type of an array class.
1431      * If this class does not represent an array class, then this method returns
1432      * {@code null}.
1433      */
1434     private Class&lt;?&gt; elementType() {
1435         if (!isArray()) return null;
1436 
1437         Class&lt;?&gt; c = this;
1438         while (c.isArray()) {
1439             c = c.getComponentType();
1440         }
1441         return c;
1442     }
1443 
1444     /**
1445      * Returns the Java language modifiers for this class or interface, encoded
1446      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1447      * constants for {@code public}, {@code protected},
1448      * {@code private}, {@code final}, {@code static},
1449      * {@code abstract} and {@code interface}; they should be decoded
1450      * using the methods of class {@code Modifier}.
1451      *
1452      * &lt;p&gt; If the underlying class is an array class, then its
1453      * {@code public}, {@code private} and {@code protected}
1454      * modifiers are the same as those of its component type.  If this
1455      * {@code Class} object represents a primitive type or void, its
1456      * {@code public} modifier is always {@code true}, and its
1457      * {@code protected} and {@code private} modifiers are always
1458      * {@code false}. If this {@code Class} object represents an array class, a
1459      * primitive type or void, then its {@code final} modifier is always
1460      * {@code true} and its interface modifier is always
1461      * {@code false}. The values of its other modifiers are not determined
1462      * by this specification.
1463      *
1464      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1465      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1466      *
1467      * @return the {@code int} representing the modifiers for this class
1468      * @see     java.lang.reflect.Modifier
1469      * @since 1.1
1470      */
1471     @HotSpotIntrinsicCandidate
1472     public native int getModifiers();
1473 
1474     /**
1475      * Gets the signers of this class.
1476      *
1477      * @return  the signers of this class, or null if there are no signers.  In
1478      *          particular, this method returns null if this {@code Class} object represents
1479      *          a primitive type or void.
1480      * @since   1.1
1481      */
1482     public native Object[] getSigners();
1483 
1484     /**
1485      * Set the signers of this class.
1486      */
1487     native void setSigners(Object[] signers);
1488 
1489 
1490     /**
1491      * If this {@code Class} object represents a local or anonymous
1492      * class within a method, returns a {@link
1493      * java.lang.reflect.Method Method} object representing the
1494      * immediately enclosing method of the underlying class. Returns
1495      * {@code null} otherwise.
1496      *
1497      * In particular, this method returns {@code null} if the underlying
1498      * class is a local or anonymous class immediately enclosed by a type
1499      * declaration, instance initializer or static initializer.
1500      *
1501      * @return the immediately enclosing method of the underlying class, if
1502      *     that class is a local or anonymous class; otherwise {@code null}.
1503      *
1504      * @throws SecurityException
1505      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1506      *         following conditions is met:
1507      *
1508      *         &lt;ul&gt;
1509      *
1510      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1511      *         class loader of the enclosing class and invocation of
1512      *         {@link SecurityManager#checkPermission
1513      *         s.checkPermission} method with
1514      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1515      *         denies access to the methods within the enclosing class
1516      *
1517      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1518      *         ancestor of the class loader for the enclosing class and
1519      *         invocation of {@link SecurityManager#checkPackageAccess
1520      *         s.checkPackageAccess()} denies access to the package
1521      *         of the enclosing class
1522      *
1523      *         &lt;/ul&gt;
1524      * @since 1.5
1525      */
1526     @CallerSensitive
1527     public Method getEnclosingMethod() throws SecurityException {
1528         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1529 
1530         if (enclosingInfo == null)
1531             return null;
1532         else {
1533             if (!enclosingInfo.isMethod())
1534                 return null;
1535 
1536             MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),
1537                                                               getFactory());
1538             Class&lt;?&gt;   returnType       = toClass(typeInfo.getReturnType());
1539             Type []    parameterTypes   = typeInfo.getParameterTypes();
1540             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1541 
1542             // Convert Types to Classes; returned types *should*
1543             // be class objects since the methodDescriptor&#39;s used
1544             // don&#39;t have generics information
1545             for(int i = 0; i &lt; parameterClasses.length; i++)
1546                 parameterClasses[i] = toClass(parameterTypes[i]);
1547 
1548             // Perform access check
1549             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1550             SecurityManager sm = System.getSecurityManager();
1551             if (sm != null) {
1552                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1553                                                      Reflection.getCallerClass(), true);
1554             }
1555             Method[] candidates = enclosingCandidate.privateGetDeclaredMethods(false);
1556 
1557             /*
1558              * Loop over all declared methods; match method name,
1559              * number of and type of parameters, *and* return
1560              * type.  Matching return type is also necessary
1561              * because of covariant returns, etc.
1562              */
1563             ReflectionFactory fact = getReflectionFactory();
1564             for (Method m : candidates) {
1565                 if (m.getName().equals(enclosingInfo.getName()) &amp;&amp;
1566                     arrayContentsEq(parameterClasses,
1567                                     fact.getExecutableSharedParameterTypes(m))) {
1568                     // finally, check return type
1569                     if (m.getReturnType().equals(returnType)) {
1570                         return fact.copyMethod(m);
1571                     }
1572                 }
1573             }
1574 
1575             throw new InternalError(&quot;Enclosing method not found&quot;);
1576         }
1577     }
1578 
1579     private native Object[] getEnclosingMethod0();
1580 
1581     private EnclosingMethodInfo getEnclosingMethodInfo() {
1582         Object[] enclosingInfo = getEnclosingMethod0();
1583         if (enclosingInfo == null)
1584             return null;
1585         else {
1586             return new EnclosingMethodInfo(enclosingInfo);
1587         }
1588     }
1589 
1590     private static final class EnclosingMethodInfo {
1591         private final Class&lt;?&gt; enclosingClass;
1592         private final String name;
1593         private final String descriptor;
1594 
1595         static void validate(Object[] enclosingInfo) {
1596             if (enclosingInfo.length != 3)
1597                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1598             try {
1599                 // The array is expected to have three elements:
1600 
1601                 // the immediately enclosing class
1602                 Class&lt;?&gt; enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1603                 assert(enclosingClass != null);
1604 
1605                 // the immediately enclosing method or constructor&#39;s
1606                 // name (can be null).
1607                 String name = (String)enclosingInfo[1];
1608 
1609                 // the immediately enclosing method or constructor&#39;s
1610                 // descriptor (null iff name is).
1611                 String descriptor = (String)enclosingInfo[2];
1612                 assert((name != null &amp;&amp; descriptor != null) || name == descriptor);
1613             } catch (ClassCastException cce) {
1614                 throw new InternalError(&quot;Invalid type in enclosing method information&quot;, cce);
1615             }
1616         }
1617 
1618         EnclosingMethodInfo(Object[] enclosingInfo) {
1619             validate(enclosingInfo);
1620             this.enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1621             this.name = (String)enclosingInfo[1];
1622             this.descriptor = (String)enclosingInfo[2];
1623         }
1624 
1625         boolean isPartial() {
1626             return enclosingClass == null || name == null || descriptor == null;
1627         }
1628 
1629         boolean isConstructor() { return !isPartial() &amp;&amp; &quot;&lt;init&gt;&quot;.equals(name); }
1630 
1631         boolean isMethod() { return !isPartial() &amp;&amp; !isConstructor() &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name); }
1632 
1633         Class&lt;?&gt; getEnclosingClass() { return enclosingClass; }
1634 
1635         String getName() { return name; }
1636 
1637         String getDescriptor() { return descriptor; }
1638 
1639     }
1640 
1641     private static Class&lt;?&gt; toClass(Type o) {
1642         if (o instanceof GenericArrayType)
1643             return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),
1644                                      0)
1645                 .getClass();
1646         return (Class&lt;?&gt;)o;
1647      }
1648 
1649     /**
1650      * If this {@code Class} object represents a local or anonymous
1651      * class within a constructor, returns a {@link
1652      * java.lang.reflect.Constructor Constructor} object representing
1653      * the immediately enclosing constructor of the underlying
1654      * class. Returns {@code null} otherwise.  In particular, this
1655      * method returns {@code null} if the underlying class is a local
1656      * or anonymous class immediately enclosed by a type declaration,
1657      * instance initializer or static initializer.
1658      *
1659      * @return the immediately enclosing constructor of the underlying class, if
1660      *     that class is a local or anonymous class; otherwise {@code null}.
1661      * @throws SecurityException
1662      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1663      *         following conditions is met:
1664      *
1665      *         &lt;ul&gt;
1666      *
1667      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1668      *         class loader of the enclosing class and invocation of
1669      *         {@link SecurityManager#checkPermission
1670      *         s.checkPermission} method with
1671      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1672      *         denies access to the constructors within the enclosing class
1673      *
1674      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1675      *         ancestor of the class loader for the enclosing class and
1676      *         invocation of {@link SecurityManager#checkPackageAccess
1677      *         s.checkPackageAccess()} denies access to the package
1678      *         of the enclosing class
1679      *
1680      *         &lt;/ul&gt;
1681      * @since 1.5
1682      */
1683     @CallerSensitive
1684     public Constructor&lt;?&gt; getEnclosingConstructor() throws SecurityException {
1685         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1686 
1687         if (enclosingInfo == null)
1688             return null;
1689         else {
1690             if (!enclosingInfo.isConstructor())
1691                 return null;
1692 
1693             ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),
1694                                                                         getFactory());
1695             Type []    parameterTypes   = typeInfo.getParameterTypes();
1696             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1697 
1698             // Convert Types to Classes; returned types *should*
1699             // be class objects since the methodDescriptor&#39;s used
1700             // don&#39;t have generics information
1701             for(int i = 0; i &lt; parameterClasses.length; i++)
1702                 parameterClasses[i] = toClass(parameterTypes[i]);
1703 
1704             // Perform access check
1705             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1706             SecurityManager sm = System.getSecurityManager();
1707             if (sm != null) {
1708                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1709                                                      Reflection.getCallerClass(), true);
1710             }
1711 
1712             Constructor&lt;?&gt;[] candidates = enclosingCandidate
1713                     .privateGetDeclaredConstructors(false);
1714             /*
1715              * Loop over all declared constructors; match number
1716              * of and type of parameters.
1717              */
1718             ReflectionFactory fact = getReflectionFactory();
1719             for (Constructor&lt;?&gt; c : candidates) {
1720                 if (arrayContentsEq(parameterClasses,
1721                                     fact.getExecutableSharedParameterTypes(c))) {
1722                     return fact.copyConstructor(c);
1723                 }
1724             }
1725 
1726             throw new InternalError(&quot;Enclosing constructor not found&quot;);
1727         }
1728     }
1729 
1730 
1731     /**
1732      * If the class or interface represented by this {@code Class} object
1733      * is a member of another class, returns the {@code Class} object
1734      * representing the class in which it was declared.  This method returns
1735      * null if this class or interface is not a member of any other class.  If
1736      * this {@code Class} object represents an array class, a primitive
1737      * type, or void,then this method returns null.
1738      *
1739      * @return the declaring class for this class
1740      * @throws SecurityException
1741      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1742      *         class loader is not the same as or an ancestor of the class
1743      *         loader for the declaring class and invocation of {@link
1744      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
1745      *         denies access to the package of the declaring class
1746      * @since 1.1
1747      */
1748     @CallerSensitive
1749     public Class&lt;?&gt; getDeclaringClass() throws SecurityException {
1750         final Class&lt;?&gt; candidate = getDeclaringClass0();
1751 
1752         if (candidate != null) {
1753             SecurityManager sm = System.getSecurityManager();
1754             if (sm != null) {
1755                 candidate.checkPackageAccess(sm,
1756                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1757             }
1758         }
1759         return candidate;
1760     }
1761 
1762     private native Class&lt;?&gt; getDeclaringClass0();
1763 
1764 
1765     /**
1766      * Returns the immediately enclosing class of the underlying
1767      * class.  If the underlying class is a top level class this
1768      * method returns {@code null}.
1769      * @return the immediately enclosing class of the underlying class
1770      * @throws     SecurityException
1771      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1772      *             class loader is not the same as or an ancestor of the class
1773      *             loader for the enclosing class and invocation of {@link
1774      *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
1775      *             denies access to the package of the enclosing class
1776      * @since 1.5
1777      */
1778     @CallerSensitive
1779     public Class&lt;?&gt; getEnclosingClass() throws SecurityException {
1780         // There are five kinds of classes (or interfaces):
1781         // a) Top level classes
1782         // b) Nested classes (static member classes)
1783         // c) Inner classes (non-static member classes)
1784         // d) Local classes (named classes declared within a method)
1785         // e) Anonymous classes
1786 
1787 
1788         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1789         // attribute if and only if it is a local class or an
1790         // anonymous class.
1791         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1792         Class&lt;?&gt; enclosingCandidate;
1793 
1794         if (enclosingInfo == null) {
1795             // This is a top level or a nested class or an inner class (a, b, or c)
1796             enclosingCandidate = getDeclaringClass0();
1797         } else {
1798             Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass();
1799             // This is a local class or an anonymous class (d or e)
1800             if (enclosingClass == this || enclosingClass == null)
1801                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1802             else
1803                 enclosingCandidate = enclosingClass;
1804         }
1805 
1806         if (enclosingCandidate != null) {
1807             SecurityManager sm = System.getSecurityManager();
1808             if (sm != null) {
1809                 enclosingCandidate.checkPackageAccess(sm,
1810                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1811             }
1812         }
1813         return enclosingCandidate;
1814     }
1815 
1816     /**
1817      * Returns the simple name of the underlying class as given in the
1818      * source code. Returns an empty string if the underlying class is
1819      * anonymous.
1820      *
1821      * &lt;p&gt;The simple name of an array is the simple name of the
1822      * component type with &quot;[]&quot; appended.  In particular the simple
1823      * name of an array whose component type is anonymous is &quot;[]&quot;.
1824      *
1825      * @return the simple name of the underlying class
1826      * @since 1.5
1827      */
1828     public String getSimpleName() {
1829         ReflectionData&lt;T&gt; rd = reflectionData();
1830         String simpleName = rd.simpleName;
1831         if (simpleName == null) {
1832             rd.simpleName = simpleName = getSimpleName0();
1833         }
1834         return simpleName;
1835     }
1836 
1837     private String getSimpleName0() {
1838         if (isArray()) {
1839             return getComponentType().getSimpleName() + &quot;[]&quot;;
1840         }
1841         String simpleName = getSimpleBinaryName();
1842         if (simpleName == null) { // top level class
1843             simpleName = getName();
1844             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1845         }
1846         return simpleName;
1847     }
1848 
1849     /**
1850      * Return an informative string for the name of this type.
1851      *
1852      * @return an informative string for the name of this type
1853      * @since 1.8
1854      */
1855     public String getTypeName() {
1856         if (isArray()) {
1857             try {
1858                 Class&lt;?&gt; cl = this;
1859                 int dimensions = 0;
1860                 do {
1861                     dimensions++;
1862                     cl = cl.getComponentType();
1863                 } while (cl.isArray());
1864                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1865             } catch (Throwable e) { /*FALLTHRU*/ }
1866         }
1867         return getName();
1868     }
1869 
1870     /**
1871      * Returns the canonical name of the underlying class as
1872      * defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
1873      * Returns {@code null} if the underlying class does not have a canonical
1874      * name. Classes without canonical names include:
1875      * &lt;ul&gt;
1876      * &lt;li&gt;a {@linkplain #isLocalClass() local class}
1877      * &lt;li&gt;a {@linkplain #isAnonymousClass() anonymous class}
1878      * &lt;li&gt;a {@linkplain #isHidden() hidden class}
1879      * &lt;li&gt;an array whose component type does not have a canonical name&lt;/li&gt;
1880      * &lt;/ul&gt;
1881      *
1882      * @return the canonical name of the underlying class if it exists, and
1883      * {@code null} otherwise.
1884      * @since 1.5
1885      */
1886     public String getCanonicalName() {
1887         ReflectionData&lt;T&gt; rd = reflectionData();
1888         String canonicalName = rd.canonicalName;
1889         if (canonicalName == null) {
1890             rd.canonicalName = canonicalName = getCanonicalName0();
1891         }
1892         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1893     }
1894 
1895     private String getCanonicalName0() {
1896         if (isArray()) {
1897             String canonicalName = getComponentType().getCanonicalName();
1898             if (canonicalName != null)
1899                 return canonicalName + &quot;[]&quot;;
1900             else
1901                 return ReflectionData.NULL_SENTINEL;
1902         }
1903         if (isHidden() || isLocalOrAnonymousClass())
1904             return ReflectionData.NULL_SENTINEL;
1905         Class&lt;?&gt; enclosingClass = getEnclosingClass();
1906         if (enclosingClass == null) { // top level class
1907             return getName();
1908         } else {
1909             String enclosingName = enclosingClass.getCanonicalName();
1910             if (enclosingName == null)
1911                 return ReflectionData.NULL_SENTINEL;
1912             return enclosingName + &quot;.&quot; + getSimpleName();
1913         }
1914     }
1915 
1916     /**
1917      * Returns {@code true} if and only if the underlying class
1918      * is an anonymous class.
1919      *
1920      * @apiNote
1921      * An anonymous class is not a {@linkplain #isHidden() hidden class}.
1922      *
1923      * @return {@code true} if and only if this class is an anonymous class.
1924      * @since 1.5
1925      */
1926     public boolean isAnonymousClass() {
1927         return !isArray() &amp;&amp; isLocalOrAnonymousClass() &amp;&amp;
1928                 getSimpleBinaryName0() == null;
1929     }
1930 
1931     /**
1932      * Returns {@code true} if and only if the underlying class
1933      * is a local class.
1934      *
1935      * @return {@code true} if and only if this class is a local class.
1936      * @since 1.5
1937      */
1938     public boolean isLocalClass() {
1939         return isLocalOrAnonymousClass() &amp;&amp;
1940                 (isArray() || getSimpleBinaryName0() != null);
1941     }
1942 
1943     /**
1944      * Returns {@code true} if and only if the underlying class
1945      * is a member class.
1946      *
1947      * @return {@code true} if and only if this class is a member class.
1948      * @since 1.5
1949      */
1950     public boolean isMemberClass() {
1951         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() != null;
1952     }
1953 
1954     /**
1955      * Returns the &quot;simple binary name&quot; of the underlying class, i.e.,
1956      * the binary name without the leading enclosing class name.
1957      * Returns {@code null} if the underlying class is a top level
1958      * class.
1959      */
1960     private String getSimpleBinaryName() {
1961         if (isTopLevelClass())
1962             return null;
1963         String name = getSimpleBinaryName0();
1964         if (name == null) // anonymous class
1965             return &quot;&quot;;
1966         return name;
1967     }
1968 
1969     private native String getSimpleBinaryName0();
1970 
1971     /**
1972      * Returns {@code true} if this is a top level class.  Returns {@code false}
1973      * otherwise.
1974      */
1975     private boolean isTopLevelClass() {
1976         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() == null;
1977     }
1978 
1979     /**
1980      * Returns {@code true} if this is a local class or an anonymous
1981      * class.  Returns {@code false} otherwise.
1982      */
1983     private boolean isLocalOrAnonymousClass() {
1984         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1985         // attribute if and only if it is a local class or an
1986         // anonymous class.
1987         return hasEnclosingMethodInfo();
1988     }
1989 
1990     private boolean hasEnclosingMethodInfo() {
1991         Object[] enclosingInfo = getEnclosingMethod0();
1992         if (enclosingInfo != null) {
1993             EnclosingMethodInfo.validate(enclosingInfo);
1994             return true;
1995         }
1996         return false;
1997     }
1998 
1999     /**
2000      * Returns an array containing {@code Class} objects representing all
2001      * the public classes and interfaces that are members of the class
2002      * represented by this {@code Class} object.  This includes public
2003      * class and interface members inherited from superclasses and public class
2004      * and interface members declared by the class.  This method returns an
2005      * array of length 0 if this {@code Class} object has no public member
2006      * classes or interfaces.  This method also returns an array of length 0 if
2007      * this {@code Class} object represents a primitive type, an array
2008      * class, or void.
2009      *
2010      * @return the array of {@code Class} objects representing the public
2011      *         members of this class
2012      * @throws SecurityException
2013      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2014      *         the caller&#39;s class loader is not the same as or an
2015      *         ancestor of the class loader for the current class and
2016      *         invocation of {@link SecurityManager#checkPackageAccess
2017      *         s.checkPackageAccess()} denies access to the package
2018      *         of this class.
2019      *
2020      * @since 1.1
2021      */
2022     @CallerSensitive
2023     public Class&lt;?&gt;[] getClasses() {
2024         SecurityManager sm = System.getSecurityManager();
2025         if (sm != null) {
2026             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
2027         }
2028 
2029         // Privileged so this implementation can look at DECLARED classes,
2030         // something the caller might not have privilege to do.  The code here
2031         // is allowed to look at DECLARED classes because (1) it does not hand
2032         // out anything other than public members and (2) public member access
2033         // has already been ok&#39;d by the SecurityManager.
2034 
2035         return java.security.AccessController.doPrivileged(
2036             new java.security.PrivilegedAction&lt;&gt;() {
2037                 public Class&lt;?&gt;[] run() {
2038                     List&lt;Class&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();
2039                     Class&lt;?&gt; currentClass = Class.this;
2040                     while (currentClass != null) {
2041                         for (Class&lt;?&gt; m : currentClass.getDeclaredClasses()) {
2042                             if (Modifier.isPublic(m.getModifiers())) {
2043                                 list.add(m);
2044                             }
2045                         }
2046                         currentClass = currentClass.getSuperclass();
2047                     }
2048                     return list.toArray(new Class&lt;?&gt;[0]);
2049                 }
2050             });
2051     }
2052 
2053 
2054     /**
2055      * Returns an array containing {@code Field} objects reflecting all
2056      * the accessible public fields of the class or interface represented by
2057      * this {@code Class} object.
2058      *
2059      * &lt;p&gt; If this {@code Class} object represents a class or interface with
2060      * no accessible public fields, then this method returns an array of length
2061      * 0.
2062      *
2063      * &lt;p&gt; If this {@code Class} object represents a class, then this method
2064      * returns the public fields of the class and of all its superclasses and
2065      * superinterfaces.
2066      *
2067      * &lt;p&gt; If this {@code Class} object represents an interface, then this
2068      * method returns the fields of the interface and of all its
2069      * superinterfaces.
2070      *
2071      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2072      * type, or void, then this method returns an array of length 0.
2073      *
2074      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2075      * particular order.
2076      *
2077      * @return the array of {@code Field} objects representing the
2078      *         public fields
2079      * @throws SecurityException
2080      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2081      *         the caller&#39;s class loader is not the same as or an
2082      *         ancestor of the class loader for the current class and
2083      *         invocation of {@link SecurityManager#checkPackageAccess
2084      *         s.checkPackageAccess()} denies access to the package
2085      *         of this class.
2086      *
2087      * @since 1.1
2088      * @jls 8.2 Class Members
2089      * @jls 8.3 Field Declarations
2090      */
2091     @CallerSensitive
2092     public Field[] getFields() throws SecurityException {
2093         SecurityManager sm = System.getSecurityManager();
2094         if (sm != null) {
2095             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2096         }
2097         return copyFields(privateGetPublicFields());
2098     }
2099 
2100 
2101     /**
2102      * Returns an array containing {@code Method} objects reflecting all the
2103      * public methods of the class or interface represented by this {@code
2104      * Class} object, including those declared by the class or interface and
2105      * those inherited from superclasses and superinterfaces.
2106      *
2107      * &lt;p&gt; If this {@code Class} object represents an array type, then the
2108      * returned array has a {@code Method} object for each of the public
2109      * methods inherited by the array type from {@code Object}. It does not
2110      * contain a {@code Method} object for {@code clone()}.
2111      *
2112      * &lt;p&gt; If this {@code Class} object represents an interface then the
2113      * returned array does not contain any implicitly declared methods from
2114      * {@code Object}. Therefore, if no methods are explicitly declared in
2115      * this interface or any of its superinterfaces then the returned array
2116      * has length 0. (Note that a {@code Class} object which represents a class
2117      * always has public methods, inherited from {@code Object}.)
2118      *
2119      * &lt;p&gt; The returned array never contains methods with names &quot;{@code &lt;init&gt;}&quot;
2120      * or &quot;{@code &lt;clinit&gt;}&quot;.
2121      *
2122      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2123      * particular order.
2124      *
2125      * &lt;p&gt; Generally, the result is computed as with the following 4 step algorithm.
2126      * Let C be the class or interface represented by this {@code Class} object:
2127      * &lt;ol&gt;
2128      * &lt;li&gt; A union of methods is composed of:
2129      *   &lt;ol type=&quot;a&quot;&gt;
2130      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
2131      *        {@link #getDeclaredMethods()} and filtered to include only public
2132      *        methods.&lt;/li&gt;
2133      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
2134      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
2135      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
2136      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
2137      *   &lt;/ol&gt;&lt;/li&gt;
2138      * &lt;li&gt; Union from step 1 is partitioned into subsets of methods with same
2139      *      signature (name, parameter types) and return type.&lt;/li&gt;
2140      * &lt;li&gt; Within each such subset only the most specific methods are selected.
2141      *      Let method M be a method from a set of methods with same signature
2142      *      and return type. M is most specific if there is no such method
2143      *      N != M from the same set, such that N is more specific than M.
2144      *      N is more specific than M if:
2145      *   &lt;ol type=&quot;a&quot;&gt;
2146      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
2147      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
2148      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
2149      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
2150      *        M and N are the same method).&lt;/li&gt;
2151      *   &lt;/ol&gt;&lt;/li&gt;
2152      * &lt;li&gt; The result of this algorithm is the union of all selected methods from
2153      *      step 3.&lt;/li&gt;
2154      * &lt;/ol&gt;
2155      *
2156      * @apiNote There may be more than one method with a particular name
2157      * and parameter types in a class because while the Java language forbids a
2158      * class to declare multiple methods with the same signature but different
2159      * return types, the Java virtual machine does not.  This
2160      * increased flexibility in the virtual machine can be used to
2161      * implement various language features.  For example, covariant
2162      * returns can be implemented with {@linkplain
2163      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2164      * method and the overriding method would have the same
2165      * signature but different return types.
2166      *
2167      * @return the array of {@code Method} objects representing the
2168      *         public methods of this class
2169      * @throws SecurityException
2170      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2171      *         the caller&#39;s class loader is not the same as or an
2172      *         ancestor of the class loader for the current class and
2173      *         invocation of {@link SecurityManager#checkPackageAccess
2174      *         s.checkPackageAccess()} denies access to the package
2175      *         of this class.
2176      *
2177      * @jls 8.2 Class Members
2178      * @jls 8.4 Method Declarations
2179      * @since 1.1
2180      */
2181     @CallerSensitive
2182     public Method[] getMethods() throws SecurityException {
2183         SecurityManager sm = System.getSecurityManager();
2184         if (sm != null) {
2185             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2186         }
2187         return copyMethods(privateGetPublicMethods());
2188     }
2189 
2190 
2191     /**
2192      * Returns an array containing {@code Constructor} objects reflecting
2193      * all the public constructors of the class represented by this
2194      * {@code Class} object.  An array of length 0 is returned if the
2195      * class has no public constructors, or if the class is an array class, or
2196      * if the class reflects a primitive type or void.
2197      *
2198      * @apiNote
2199      * While this method returns an array of {@code
2200      * Constructor&lt;T&gt;} objects (that is an array of constructors from
2201      * this class), the return type of this method is {@code
2202      * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
2203      * might be expected.  This less informative return type is
2204      * necessary since after being returned from this method, the
2205      * array could be modified to hold {@code Constructor} objects for
2206      * different classes, which would violate the type guarantees of
2207      * {@code Constructor&lt;T&gt;[]}.
2208      *
2209      * @return the array of {@code Constructor} objects representing the
2210      *         public constructors of this class
2211      * @throws SecurityException
2212      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2213      *         the caller&#39;s class loader is not the same as or an
2214      *         ancestor of the class loader for the current class and
2215      *         invocation of {@link SecurityManager#checkPackageAccess
2216      *         s.checkPackageAccess()} denies access to the package
2217      *         of this class.
2218      *
2219      * @since 1.1
2220      */
2221     @CallerSensitive
2222     public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
2223         SecurityManager sm = System.getSecurityManager();
2224         if (sm != null) {
2225             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2226         }
2227         return copyConstructors(privateGetDeclaredConstructors(true));
2228     }
2229 
2230 
2231     /**
2232      * Returns a {@code Field} object that reflects the specified public member
2233      * field of the class or interface represented by this {@code Class}
2234      * object. The {@code name} parameter is a {@code String} specifying the
2235      * simple name of the desired field.
2236      *
2237      * &lt;p&gt; The field to be reflected is determined by the algorithm that
2238      * follows.  Let C be the class or interface represented by this {@code Class} object:
2239      *
2240      * &lt;OL&gt;
2241      * &lt;LI&gt; If C declares a public field with the name specified, that is the
2242      *      field to be reflected.&lt;/LI&gt;
2243      * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
2244      *      recursively to each direct superinterface of C. The direct
2245      *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
2246      * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
2247      *      superclass S, then this algorithm is invoked recursively upon S.
2248      *      If C has no superclass, then a {@code NoSuchFieldException}
2249      *      is thrown.&lt;/LI&gt;
2250      * &lt;/OL&gt;
2251      *
2252      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2253      * method does not find the {@code length} field of the array type.
2254      *
2255      * @param name the field name
2256      * @return the {@code Field} object of this class specified by
2257      *         {@code name}
2258      * @throws NoSuchFieldException if a field with the specified name is
2259      *         not found.
2260      * @throws NullPointerException if {@code name} is {@code null}
2261      * @throws SecurityException
2262      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2263      *         the caller&#39;s class loader is not the same as or an
2264      *         ancestor of the class loader for the current class and
2265      *         invocation of {@link SecurityManager#checkPackageAccess
2266      *         s.checkPackageAccess()} denies access to the package
2267      *         of this class.
2268      *
2269      * @since 1.1
2270      * @jls 8.2 Class Members
2271      * @jls 8.3 Field Declarations
2272      */
2273     @CallerSensitive
2274     public Field getField(String name)
2275         throws NoSuchFieldException, SecurityException {
2276         Objects.requireNonNull(name);
2277         SecurityManager sm = System.getSecurityManager();
2278         if (sm != null) {
2279             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2280         }
2281         Field field = getField0(name);
2282         if (field == null) {
2283             throw new NoSuchFieldException(name);
2284         }
2285         return getReflectionFactory().copyField(field);
2286     }
2287 
2288 
2289     /**
2290      * Returns a {@code Method} object that reflects the specified public
2291      * member method of the class or interface represented by this
2292      * {@code Class} object. The {@code name} parameter is a
2293      * {@code String} specifying the simple name of the desired method. The
2294      * {@code parameterTypes} parameter is an array of {@code Class}
2295      * objects that identify the method&#39;s formal parameter types, in declared
2296      * order. If {@code parameterTypes} is {@code null}, it is
2297      * treated as if it were an empty array.
2298      *
2299      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2300      * method finds any public method inherited by the array type from
2301      * {@code Object} except method {@code clone()}.
2302      *
2303      * &lt;p&gt; If this {@code Class} object represents an interface then this
2304      * method does not find any implicitly declared method from
2305      * {@code Object}. Therefore, if no methods are explicitly declared in
2306      * this interface or any of its superinterfaces, then this method does not
2307      * find any method.
2308      *
2309      * &lt;p&gt; This method does not find any method with name &quot;{@code &lt;init&gt;}&quot; or
2310      * &quot;{@code &lt;clinit&gt;}&quot;.
2311      *
2312      * &lt;p&gt; Generally, the method to be reflected is determined by the 4 step
2313      * algorithm that follows.
2314      * Let C be the class or interface represented by this {@code Class} object:
2315      * &lt;ol&gt;
2316      * &lt;li&gt; A union of methods is composed of:
2317      *   &lt;ol type=&quot;a&quot;&gt;
2318      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
2319      *        {@link #getDeclaredMethods()} and filtered to include only public
2320      *        methods that match given {@code name} and {@code parameterTypes}&lt;/li&gt;
2321      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
2322      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
2323      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
2324      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
2325      *   &lt;/ol&gt;&lt;/li&gt;
2326      * &lt;li&gt; This union is partitioned into subsets of methods with same
2327      *      return type (the selection of methods from step 1 also guarantees that
2328      *      they have the same method name and parameter types).&lt;/li&gt;
2329      * &lt;li&gt; Within each such subset only the most specific methods are selected.
2330      *      Let method M be a method from a set of methods with same VM
2331      *      signature (return type, name, parameter types).
2332      *      M is most specific if there is no such method N != M from the same
2333      *      set, such that N is more specific than M. N is more specific than M
2334      *      if:
2335      *   &lt;ol type=&quot;a&quot;&gt;
2336      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
2337      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
2338      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
2339      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
2340      *        M and N are the same method).&lt;/li&gt;
2341      *   &lt;/ol&gt;&lt;/li&gt;
2342      * &lt;li&gt; The result of this algorithm is chosen arbitrarily from the methods
2343      *      with most specific return type among all selected methods from step 3.
2344      *      Let R be a return type of a method M from the set of all selected methods
2345      *      from step 3. M is a method with most specific return type if there is
2346      *      no such method N != M from the same set, having return type S != R,
2347      *      such that S is a subtype of R as determined by
2348      *      R.class.{@link #isAssignableFrom}(S.class).
2349      * &lt;/ol&gt;
2350      *
2351      * @apiNote There may be more than one method with matching name and
2352      * parameter types in a class because while the Java language forbids a
2353      * class to declare multiple methods with the same signature but different
2354      * return types, the Java virtual machine does not.  This
2355      * increased flexibility in the virtual machine can be used to
2356      * implement various language features.  For example, covariant
2357      * returns can be implemented with {@linkplain
2358      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2359      * method and the overriding method would have the same
2360      * signature but different return types. This method would return the
2361      * overriding method as it would have a more specific return type.
2362      *
2363      * @param name the name of the method
2364      * @param parameterTypes the list of parameters
2365      * @return the {@code Method} object that matches the specified
2366      *         {@code name} and {@code parameterTypes}
2367      * @throws NoSuchMethodException if a matching method is not found
2368      *         or if the name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot;.
2369      * @throws NullPointerException if {@code name} is {@code null}
2370      * @throws SecurityException
2371      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2372      *         the caller&#39;s class loader is not the same as or an
2373      *         ancestor of the class loader for the current class and
2374      *         invocation of {@link SecurityManager#checkPackageAccess
2375      *         s.checkPackageAccess()} denies access to the package
2376      *         of this class.
2377      *
2378      * @jls 8.2 Class Members
2379      * @jls 8.4 Method Declarations
2380      * @since 1.1
2381      */
2382     @CallerSensitive
2383     public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)
2384         throws NoSuchMethodException, SecurityException {
2385         Objects.requireNonNull(name);
2386         SecurityManager sm = System.getSecurityManager();
2387         if (sm != null) {
2388             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2389         }
2390         Method method = getMethod0(name, parameterTypes);
2391         if (method == null) {
2392             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2393         }
2394         return getReflectionFactory().copyMethod(method);
2395     }
2396 
2397     /**
2398      * Returns a {@code Constructor} object that reflects the specified
2399      * public constructor of the class represented by this {@code Class}
2400      * object. The {@code parameterTypes} parameter is an array of
2401      * {@code Class} objects that identify the constructor&#39;s formal
2402      * parameter types, in declared order.
2403      *
2404      * If this {@code Class} object represents an inner class
2405      * declared in a non-static context, the formal parameter types
2406      * include the explicit enclosing instance as the first parameter.
2407      *
2408      * &lt;p&gt; The constructor to reflect is the public constructor of the class
2409      * represented by this {@code Class} object whose formal parameter
2410      * types match those specified by {@code parameterTypes}.
2411      *
2412      * @param parameterTypes the parameter array
2413      * @return the {@code Constructor} object of the public constructor that
2414      *         matches the specified {@code parameterTypes}
2415      * @throws NoSuchMethodException if a matching method is not found.
2416      * @throws SecurityException
2417      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2418      *         the caller&#39;s class loader is not the same as or an
2419      *         ancestor of the class loader for the current class and
2420      *         invocation of {@link SecurityManager#checkPackageAccess
2421      *         s.checkPackageAccess()} denies access to the package
2422      *         of this class.
2423      *
2424      * @since 1.1
2425      */
2426     @CallerSensitive
2427     public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)
2428         throws NoSuchMethodException, SecurityException
2429     {
2430         SecurityManager sm = System.getSecurityManager();
2431         if (sm != null) {
2432             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2433         }
2434         return getReflectionFactory().copyConstructor(
2435             getConstructor0(parameterTypes, Member.PUBLIC));
2436     }
2437 
2438 
2439     /**
2440      * Returns an array of {@code Class} objects reflecting all the
2441      * classes and interfaces declared as members of the class represented by
2442      * this {@code Class} object. This includes public, protected, default
2443      * (package) access, and private classes and interfaces declared by the
2444      * class, but excludes inherited classes and interfaces.  This method
2445      * returns an array of length 0 if the class declares no classes or
2446      * interfaces as members, or if this {@code Class} object represents a
2447      * primitive type, an array class, or void.
2448      *
2449      * @return the array of {@code Class} objects representing all the
2450      *         declared members of this class
2451      * @throws SecurityException
2452      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2453      *         following conditions is met:
2454      *
2455      *         &lt;ul&gt;
2456      *
2457      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
2458      *         class loader of this class and invocation of
2459      *         {@link SecurityManager#checkPermission
2460      *         s.checkPermission} method with
2461      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2462      *         denies access to the declared classes within this class
2463      *
2464      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
2465      *         ancestor of the class loader for the current class and
2466      *         invocation of {@link SecurityManager#checkPackageAccess
2467      *         s.checkPackageAccess()} denies access to the package
2468      *         of this class
2469      *
2470      *         &lt;/ul&gt;
2471      *
2472      * @since 1.1
2473      */
2474     @CallerSensitive
2475     public Class&lt;?&gt;[] getDeclaredClasses() throws SecurityException {
2476         SecurityManager sm = System.getSecurityManager();
2477         if (sm != null) {
2478             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), false);
2479         }
2480         return getDeclaredClasses0();
2481     }
2482 
2483 
2484     /**
2485      * Returns an array of {@code Field} objects reflecting all the fields
2486      * declared by the class or interface represented by this
2487      * {@code Class} object. This includes public, protected, default
2488      * (package) access, and private fields, but excludes inherited fields.
2489      *
2490      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2491      * declared fields, then this method returns an array of length 0.
2492      *
2493      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2494      * type, or void, then this method returns an array of length 0.
2495      *
2496      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2497      * particular order.
2498      *
2499      * @return  the array of {@code Field} objects representing all the
2500      *          declared fields of this class
2501      * @throws  SecurityException
2502      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2503      *          following conditions is met:
2504      *
2505      *          &lt;ul&gt;
2506      *
2507      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2508      *          class loader of this class and invocation of
2509      *          {@link SecurityManager#checkPermission
2510      *          s.checkPermission} method with
2511      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2512      *          denies access to the declared fields within this class
2513      *
2514      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2515      *          ancestor of the class loader for the current class and
2516      *          invocation of {@link SecurityManager#checkPackageAccess
2517      *          s.checkPackageAccess()} denies access to the package
2518      *          of this class
2519      *
2520      *          &lt;/ul&gt;
2521      *
2522      * @since 1.1
2523      * @jls 8.2 Class Members
2524      * @jls 8.3 Field Declarations
2525      */
2526     @CallerSensitive
2527     public Field[] getDeclaredFields() throws SecurityException {
2528         SecurityManager sm = System.getSecurityManager();
2529         if (sm != null) {
2530             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2531         }
2532         return copyFields(privateGetDeclaredFields(false));
2533     }
2534 
2535     /**
2536      * {@preview Associated with records, a preview feature of the Java language.
2537      *
2538      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
2539      *           feature of the Java language. Preview features
2540      *           may be removed in a future release, or upgraded to permanent
2541      *           features of the Java language.}
2542      *
2543      * Returns an array of {@code RecordComponent} objects representing all the
2544      * record components of this record class, or {@code null} if this class is
2545      * not a record class.
2546      *
2547      * &lt;p&gt; The components are returned in the same order that they are declared
2548      * in the record header. The array is empty if this record class has no
2549      * components. If the class is not a record class, that is {@link
2550      * #isRecord()} returns {@code false}, then this method returns {@code null}.
2551      * Conversely, if {@link #isRecord()} returns {@code true}, then this method
2552      * returns a non-null value.
2553      *
2554      * @return  An array of {@code RecordComponent} objects representing all the
2555      *          record components of this record class, or {@code null} if this
2556      *          class is not a record class
2557      * @throws  SecurityException
2558      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2559      *          following conditions is met:
2560      *
2561      *          &lt;ul&gt;
2562      *
2563      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2564      *          class loader of this class and invocation of
2565      *          {@link SecurityManager#checkPermission
2566      *          s.checkPermission} method with
2567      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2568      *          denies access to the declared methods within this class
2569      *
2570      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2571      *          ancestor of the class loader for the current class and
2572      *          invocation of {@link SecurityManager#checkPackageAccess
2573      *          s.checkPackageAccess()} denies access to the package
2574      *          of this class
2575      *
2576      *          &lt;/ul&gt;
2577      *
2578      * @jls 8.10 Record Types
2579      * @since 14
2580      */
2581     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
2582                                  essentialAPI=false)
2583     @SuppressWarnings(&quot;preview&quot;)
2584     @CallerSensitive
2585     public RecordComponent[] getRecordComponents() {
2586         SecurityManager sm = System.getSecurityManager();
2587         if (sm != null) {
2588             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2589         }
2590         if (!isRecord()) {
2591             return null;
2592         }
2593         RecordComponent[] recordComponents = getRecordComponents0();
2594         if (recordComponents == null) {
2595             return new RecordComponent[0];
2596         }
2597         return recordComponents;
2598     }
2599 
2600     /**
2601      * Returns an array containing {@code Method} objects reflecting all the
2602      * declared methods of the class or interface represented by this {@code
2603      * Class} object, including public, protected, default (package)
2604      * access, and private methods, but excluding inherited methods.
2605      *
2606      * &lt;p&gt; If this {@code Class} object represents a type that has multiple
2607      * declared methods with the same name and parameter types, but different
2608      * return types, then the returned array has a {@code Method} object for
2609      * each such method.
2610      *
2611      * &lt;p&gt; If this {@code Class} object represents a type that has a class
2612      * initialization method {@code &lt;clinit&gt;}, then the returned array does
2613      * &lt;em&gt;not&lt;/em&gt; have a corresponding {@code Method} object.
2614      *
2615      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2616      * declared methods, then the returned array has length 0.
2617      *
2618      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2619      * type, or void, then the returned array has length 0.
2620      *
2621      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2622      * particular order.
2623      *
2624      * @return  the array of {@code Method} objects representing all the
2625      *          declared methods of this class
2626      * @throws  SecurityException
2627      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2628      *          following conditions is met:
2629      *
2630      *          &lt;ul&gt;
2631      *
2632      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2633      *          class loader of this class and invocation of
2634      *          {@link SecurityManager#checkPermission
2635      *          s.checkPermission} method with
2636      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2637      *          denies access to the declared methods within this class
2638      *
2639      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2640      *          ancestor of the class loader for the current class and
2641      *          invocation of {@link SecurityManager#checkPackageAccess
2642      *          s.checkPackageAccess()} denies access to the package
2643      *          of this class
2644      *
2645      *          &lt;/ul&gt;
2646      *
2647      * @jls 8.2 Class Members
2648      * @jls 8.4 Method Declarations
2649      * @since 1.1
2650      */
2651     @CallerSensitive
2652     public Method[] getDeclaredMethods() throws SecurityException {
2653         SecurityManager sm = System.getSecurityManager();
2654         if (sm != null) {
2655             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2656         }
2657         return copyMethods(privateGetDeclaredMethods(false));
2658     }
2659 
2660 
2661     /**
2662      * Returns an array of {@code Constructor} objects reflecting all the
2663      * constructors declared by the class represented by this
2664      * {@code Class} object. These are public, protected, default
2665      * (package) access, and private constructors.  The elements in the array
2666      * returned are not sorted and are not in any particular order.  If the
2667      * class has a default constructor, it is included in the returned array.
2668      * This method returns an array of length 0 if this {@code Class}
2669      * object represents an interface, a primitive type, an array class, or
2670      * void.
2671      *
2672      * &lt;p&gt; See &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
2673      * section {@jls 8.2}.
2674      *
2675      * @return  the array of {@code Constructor} objects representing all the
2676      *          declared constructors of this class
2677      * @throws  SecurityException
2678      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2679      *          following conditions is met:
2680      *
2681      *          &lt;ul&gt;
2682      *
2683      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2684      *          class loader of this class and invocation of
2685      *          {@link SecurityManager#checkPermission
2686      *          s.checkPermission} method with
2687      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2688      *          denies access to the declared constructors within this class
2689      *
2690      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2691      *          ancestor of the class loader for the current class and
2692      *          invocation of {@link SecurityManager#checkPackageAccess
2693      *          s.checkPackageAccess()} denies access to the package
2694      *          of this class
2695      *
2696      *          &lt;/ul&gt;
2697      *
2698      * @since 1.1
2699      */
2700     @CallerSensitive
2701     public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException {
2702         SecurityManager sm = System.getSecurityManager();
2703         if (sm != null) {
2704             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2705         }
2706         return copyConstructors(privateGetDeclaredConstructors(false));
2707     }
2708 
2709 
2710     /**
2711      * Returns a {@code Field} object that reflects the specified declared
2712      * field of the class or interface represented by this {@code Class}
2713      * object. The {@code name} parameter is a {@code String} that specifies
2714      * the simple name of the desired field.
2715      *
2716      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2717      * method does not find the {@code length} field of the array type.
2718      *
2719      * @param name the name of the field
2720      * @return  the {@code Field} object for the specified field in this
2721      *          class
2722      * @throws  NoSuchFieldException if a field with the specified name is
2723      *          not found.
2724      * @throws  NullPointerException if {@code name} is {@code null}
2725      * @throws  SecurityException
2726      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2727      *          following conditions is met:
2728      *
2729      *          &lt;ul&gt;
2730      *
2731      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2732      *          class loader of this class and invocation of
2733      *          {@link SecurityManager#checkPermission
2734      *          s.checkPermission} method with
2735      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2736      *          denies access to the declared field
2737      *
2738      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2739      *          ancestor of the class loader for the current class and
2740      *          invocation of {@link SecurityManager#checkPackageAccess
2741      *          s.checkPackageAccess()} denies access to the package
2742      *          of this class
2743      *
2744      *          &lt;/ul&gt;
2745      *
2746      * @since 1.1
2747      * @jls 8.2 Class Members
2748      * @jls 8.3 Field Declarations
2749      */
2750     @CallerSensitive
2751     public Field getDeclaredField(String name)
2752         throws NoSuchFieldException, SecurityException {
2753         Objects.requireNonNull(name);
2754         SecurityManager sm = System.getSecurityManager();
2755         if (sm != null) {
2756             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2757         }
2758         Field field = searchFields(privateGetDeclaredFields(false), name);
2759         if (field == null) {
2760             throw new NoSuchFieldException(name);
2761         }
2762         return getReflectionFactory().copyField(field);
2763     }
2764 
2765 
2766     /**
2767      * Returns a {@code Method} object that reflects the specified
2768      * declared method of the class or interface represented by this
2769      * {@code Class} object. The {@code name} parameter is a
2770      * {@code String} that specifies the simple name of the desired
2771      * method, and the {@code parameterTypes} parameter is an array of
2772      * {@code Class} objects that identify the method&#39;s formal parameter
2773      * types, in declared order.  If more than one method with the same
2774      * parameter types is declared in a class, and one of these methods has a
2775      * return type that is more specific than any of the others, that method is
2776      * returned; otherwise one of the methods is chosen arbitrarily.  If the
2777      * name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot; a {@code NoSuchMethodException}
2778      * is raised.
2779      *
2780      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2781      * method does not find the {@code clone()} method.
2782      *
2783      * @param name the name of the method
2784      * @param parameterTypes the parameter array
2785      * @return  the {@code Method} object for the method of this class
2786      *          matching the specified name and parameters
2787      * @throws  NoSuchMethodException if a matching method is not found.
2788      * @throws  NullPointerException if {@code name} is {@code null}
2789      * @throws  SecurityException
2790      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2791      *          following conditions is met:
2792      *
2793      *          &lt;ul&gt;
2794      *
2795      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2796      *          class loader of this class and invocation of
2797      *          {@link SecurityManager#checkPermission
2798      *          s.checkPermission} method with
2799      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2800      *          denies access to the declared method
2801      *
2802      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2803      *          ancestor of the class loader for the current class and
2804      *          invocation of {@link SecurityManager#checkPackageAccess
2805      *          s.checkPackageAccess()} denies access to the package
2806      *          of this class
2807      *
2808      *          &lt;/ul&gt;
2809      *
2810      * @jls 8.2 Class Members
2811      * @jls 8.4 Method Declarations
2812      * @since 1.1
2813      */
2814     @CallerSensitive
2815     public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)
2816         throws NoSuchMethodException, SecurityException {
2817         Objects.requireNonNull(name);
2818         SecurityManager sm = System.getSecurityManager();
2819         if (sm != null) {
2820             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2821         }
2822         Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);
2823         if (method == null) {
2824             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2825         }
2826         return getReflectionFactory().copyMethod(method);
2827     }
2828 
2829     /**
2830      * Returns the list of {@code Method} objects for the declared public
2831      * methods of this class or interface that have the specified method name
2832      * and parameter types.
2833      *
2834      * @param name the name of the method
2835      * @param parameterTypes the parameter array
2836      * @return the list of {@code Method} objects for the public methods of
2837      *         this class matching the specified name and parameters
2838      */
2839     List&lt;Method&gt; getDeclaredPublicMethods(String name, Class&lt;?&gt;... parameterTypes) {
2840         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
2841         ReflectionFactory factory = getReflectionFactory();
2842         List&lt;Method&gt; result = new ArrayList&lt;&gt;();
2843         for (Method method : methods) {
2844             if (method.getName().equals(name)
2845                 &amp;&amp; Arrays.equals(
2846                     factory.getExecutableSharedParameterTypes(method),
2847                     parameterTypes)) {
2848                 result.add(factory.copyMethod(method));
2849             }
2850         }
2851         return result;
2852     }
2853 
2854     /**
2855      * Returns a {@code Constructor} object that reflects the specified
2856      * constructor of the class or interface represented by this
2857      * {@code Class} object.  The {@code parameterTypes} parameter is
2858      * an array of {@code Class} objects that identify the constructor&#39;s
2859      * formal parameter types, in declared order.
2860      *
2861      * If this {@code Class} object represents an inner class
2862      * declared in a non-static context, the formal parameter types
2863      * include the explicit enclosing instance as the first parameter.
2864      *
2865      * @param parameterTypes the parameter array
2866      * @return  The {@code Constructor} object for the constructor with the
2867      *          specified parameter list
2868      * @throws  NoSuchMethodException if a matching method is not found.
2869      * @throws  SecurityException
2870      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2871      *          following conditions is met:
2872      *
2873      *          &lt;ul&gt;
2874      *
2875      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2876      *          class loader of this class and invocation of
2877      *          {@link SecurityManager#checkPermission
2878      *          s.checkPermission} method with
2879      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2880      *          denies access to the declared constructor
2881      *
2882      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2883      *          ancestor of the class loader for the current class and
2884      *          invocation of {@link SecurityManager#checkPackageAccess
2885      *          s.checkPackageAccess()} denies access to the package
2886      *          of this class
2887      *
2888      *          &lt;/ul&gt;
2889      *
2890      * @since 1.1
2891      */
2892     @CallerSensitive
2893     public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)
2894         throws NoSuchMethodException, SecurityException
2895     {
2896         SecurityManager sm = System.getSecurityManager();
2897         if (sm != null) {
2898             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2899         }
2900 
2901         return getReflectionFactory().copyConstructor(
2902             getConstructor0(parameterTypes, Member.DECLARED));
2903     }
2904 
2905     /**
2906      * Finds a resource with a given name.
2907      *
2908      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2909      * will attempt to find the resource in the module. This is done by
2910      * delegating to the module&#39;s class loader {@link
2911      * ClassLoader#findResource(String,String) findResource(String,String)}
2912      * method, invoking it with the module name and the absolute name of the
2913      * resource. Resources in named modules are subject to the rules for
2914      * encapsulation specified in the {@code Module} {@link
2915      * Module#getResourceAsStream getResourceAsStream} method and so this
2916      * method returns {@code null} when the resource is a
2917      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2918      * caller&#39;s module.
2919      *
2920      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2921      * searching resources associated with a given class are implemented by the
2922      * defining {@linkplain ClassLoader class loader} of the class.  This method
2923      * delegates to this {@code Class} object&#39;s class loader.
2924      * If this {@code Class} object was loaded by the bootstrap class loader,
2925      * the method delegates to {@link ClassLoader#getSystemResourceAsStream}.
2926      *
2927      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2928      * given resource name using this algorithm:
2929      *
2930      * &lt;ul&gt;
2931      *
2932      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2933      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2934      * portion of the {@code name} following the {@code &#39;/&#39;}.
2935      *
2936      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2937      *
2938      * &lt;blockquote&gt;
2939      *   {@code modified_package_name/name}
2940      * &lt;/blockquote&gt;
2941      *
2942      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2943      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2944      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2945      *
2946      * &lt;/ul&gt;
2947      *
2948      * @param  name name of the desired resource
2949      * @return  A {@link java.io.InputStream} object; {@code null} if no
2950      *          resource with this name is found, the resource is in a package
2951      *          that is not {@linkplain Module#isOpen(String, Module) open} to at
2952      *          least the caller module, or access to the resource is denied
2953      *          by the security manager.
2954      * @throws  NullPointerException If {@code name} is {@code null}
2955      *
2956      * @see Module#getResourceAsStream(String)
2957      * @since  1.1
2958      * @revised 9
2959      * @spec JPMS
2960      */
2961     @CallerSensitive
2962     public InputStream getResourceAsStream(String name) {
2963         name = resolveName(name);
2964 
2965         Module thisModule = getModule();
2966         if (thisModule.isNamed()) {
2967             // check if resource can be located by caller
2968             if (Resources.canEncapsulate(name)
2969                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2970                 return null;
2971             }
2972 
2973             // resource not encapsulated or in package open to caller
2974             String mn = thisModule.getName();
2975             ClassLoader cl = getClassLoader0();
2976             try {
2977 
2978                 // special-case built-in class loaders to avoid the
2979                 // need for a URL connection
2980                 if (cl == null) {
2981                     return BootLoader.findResourceAsStream(mn, name);
2982                 } else if (cl instanceof BuiltinClassLoader) {
2983                     return ((BuiltinClassLoader) cl).findResourceAsStream(mn, name);
2984                 } else {
2985                     URL url = cl.findResource(mn, name);
2986                     return (url != null) ? url.openStream() : null;
2987                 }
2988 
2989             } catch (IOException | SecurityException e) {
2990                 return null;
2991             }
2992         }
2993 
2994         // unnamed module
2995         ClassLoader cl = getClassLoader0();
2996         if (cl == null) {
2997             return ClassLoader.getSystemResourceAsStream(name);
2998         } else {
2999             return cl.getResourceAsStream(name);
3000         }
3001     }
3002 
3003     /**
3004      * Finds a resource with a given name.
3005      *
3006      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
3007      * will attempt to find the resource in the module. This is done by
3008      * delegating to the module&#39;s class loader {@link
3009      * ClassLoader#findResource(String,String) findResource(String,String)}
3010      * method, invoking it with the module name and the absolute name of the
3011      * resource. Resources in named modules are subject to the rules for
3012      * encapsulation specified in the {@code Module} {@link
3013      * Module#getResourceAsStream getResourceAsStream} method and so this
3014      * method returns {@code null} when the resource is a
3015      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
3016      * caller&#39;s module.
3017      *
3018      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
3019      * searching resources associated with a given class are implemented by the
3020      * defining {@linkplain ClassLoader class loader} of the class.  This method
3021      * delegates to this {@code Class} object&#39;s class loader.
3022      * If this {@code Class} object was loaded by the bootstrap class loader,
3023      * the method delegates to {@link ClassLoader#getSystemResource}.
3024      *
3025      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
3026      * given resource name using this algorithm:
3027      *
3028      * &lt;ul&gt;
3029      *
3030      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
3031      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
3032      * portion of the {@code name} following the {@code &#39;/&#39;}.
3033      *
3034      * &lt;li&gt; Otherwise, the absolute name is of the following form:
3035      *
3036      * &lt;blockquote&gt;
3037      *   {@code modified_package_name/name}
3038      * &lt;/blockquote&gt;
3039      *
3040      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
3041      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
3042      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
3043      *
3044      * &lt;/ul&gt;
3045      *
3046      * @param  name name of the desired resource
3047      * @return A {@link java.net.URL} object; {@code null} if no resource with
3048      *         this name is found, the resource cannot be located by a URL, the
3049      *         resource is in a package that is not
3050      *         {@linkplain Module#isOpen(String, Module) open} to at least the caller
3051      *         module, or access to the resource is denied by the security
3052      *         manager.
3053      * @throws NullPointerException If {@code name} is {@code null}
3054      * @since  1.1
3055      * @revised 9
3056      * @spec JPMS
3057      */
3058     @CallerSensitive
3059     public URL getResource(String name) {
3060         name = resolveName(name);
3061 
3062         Module thisModule = getModule();
3063         if (thisModule.isNamed()) {
3064             // check if resource can be located by caller
3065             if (Resources.canEncapsulate(name)
3066                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
3067                 return null;
3068             }
3069 
3070             // resource not encapsulated or in package open to caller
3071             String mn = thisModule.getName();
3072             ClassLoader cl = getClassLoader0();
3073             try {
3074                 if (cl == null) {
3075                     return BootLoader.findResource(mn, name);
3076                 } else {
3077                     return cl.findResource(mn, name);
3078                 }
3079             } catch (IOException ioe) {
3080                 return null;
3081             }
3082         }
3083 
3084         // unnamed module
3085         ClassLoader cl = getClassLoader0();
3086         if (cl == null) {
3087             return ClassLoader.getSystemResource(name);
3088         } else {
3089             return cl.getResource(name);
3090         }
3091     }
3092 
3093     /**
3094      * Returns true if a resource with the given name can be located by the
3095      * given caller. All resources in a module can be located by code in
3096      * the module. For other callers, then the package needs to be open to
3097      * the caller.
3098      */
3099     private boolean isOpenToCaller(String name, Class&lt;?&gt; caller) {
3100         // assert getModule().isNamed();
3101         Module thisModule = getModule();
3102         Module callerModule = (caller != null) ? caller.getModule() : null;
3103         if (callerModule != thisModule) {
3104             String pn = Resources.toPackageName(name);
3105             if (thisModule.getDescriptor().packages().contains(pn)) {
3106                 if (callerModule == null &amp;&amp; !thisModule.isOpen(pn)) {
3107                     // no caller, package not open
3108                     return false;
3109                 }
3110                 if (!thisModule.isOpen(pn, callerModule)) {
3111                     // package not open to caller
3112                     return false;
3113                 }
3114             }
3115         }
3116         return true;
3117     }
3118 
3119 
3120     /** protection domain returned when the internal domain is null */
3121     private static java.security.ProtectionDomain allPermDomain;
3122 
3123     /**
3124      * Returns the {@code ProtectionDomain} of this class.  If there is a
3125      * security manager installed, this method first calls the security
3126      * manager&#39;s {@code checkPermission} method with a
3127      * {@code RuntimePermission(&quot;getProtectionDomain&quot;)} permission to
3128      * ensure it&#39;s ok to get the
3129      * {@code ProtectionDomain}.
3130      *
3131      * @return the ProtectionDomain of this class
3132      *
3133      * @throws SecurityException
3134      *        if a security manager exists and its
3135      *        {@code checkPermission} method doesn&#39;t allow
3136      *        getting the ProtectionDomain.
3137      *
3138      * @see java.security.ProtectionDomain
3139      * @see SecurityManager#checkPermission
3140      * @see java.lang.RuntimePermission
3141      * @since 1.2
3142      */
3143     public java.security.ProtectionDomain getProtectionDomain() {
3144         SecurityManager sm = System.getSecurityManager();
3145         if (sm != null) {
3146             sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
3147         }
3148         return protectionDomain();
3149     }
3150 
3151     // package-private
3152     java.security.ProtectionDomain protectionDomain() {
3153         java.security.ProtectionDomain pd = getProtectionDomain0();
3154         if (pd == null) {
3155             if (allPermDomain == null) {
3156                 java.security.Permissions perms =
3157                     new java.security.Permissions();
3158                 perms.add(SecurityConstants.ALL_PERMISSION);
3159                 allPermDomain =
3160                     new java.security.ProtectionDomain(null, perms);
3161             }
3162             pd = allPermDomain;
3163         }
3164         return pd;
3165     }
3166 
3167     /**
3168      * Returns the ProtectionDomain of this class.
3169      */
3170     private native java.security.ProtectionDomain getProtectionDomain0();
3171 
3172     /*
3173      * Return the Virtual Machine&#39;s Class object for the named
3174      * primitive type.
3175      */
3176     static native Class&lt;?&gt; getPrimitiveClass(String name);
3177 
3178     /*
3179      * Check if client is allowed to access members.  If access is denied,
3180      * throw a SecurityException.
3181      *
3182      * This method also enforces package access.
3183      *
3184      * &lt;p&gt; Default policy: allow all clients access with normal Java access
3185      * control.
3186      *
3187      * &lt;p&gt; NOTE: should only be called if a SecurityManager is installed
3188      */
3189     private void checkMemberAccess(SecurityManager sm, int which,
3190                                    Class&lt;?&gt; caller, boolean checkProxyInterfaces) {
3191         /* Default policy allows access to all {@link Member#PUBLIC} members,
3192          * as well as access to classes that have the same class loader as the caller.
3193          * In all other cases, it requires RuntimePermission(&quot;accessDeclaredMembers&quot;)
3194          * permission.
3195          */
3196         final ClassLoader ccl = ClassLoader.getClassLoader(caller);
3197         if (which != Member.PUBLIC) {
3198             final ClassLoader cl = getClassLoader0();
3199             if (ccl != cl) {
3200                 sm.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3201             }
3202         }
3203         this.checkPackageAccess(sm, ccl, checkProxyInterfaces);
3204     }
3205 
3206     /*
3207      * Checks if a client loaded in ClassLoader ccl is allowed to access this
3208      * class under the current package access policy. If access is denied,
3209      * throw a SecurityException.
3210      *
3211      * NOTE: this method should only be called if a SecurityManager is active
3212      */
3213     private void checkPackageAccess(SecurityManager sm, final ClassLoader ccl,
3214                                     boolean checkProxyInterfaces) {
3215         final ClassLoader cl = getClassLoader0();
3216 
3217         if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {
3218             String pkg = this.getPackageName();
3219             if (pkg != null &amp;&amp; !pkg.isEmpty()) {
3220                 // skip the package access check on a proxy class in default proxy package
3221                 if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {
3222                     sm.checkPackageAccess(pkg);
3223                 }
3224             }
3225         }
3226         // check package access on the proxy interfaces
3227         if (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(this)) {
3228             ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());
3229         }
3230     }
3231 
3232     /**
3233      * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
3234      * if name is absolute
3235      */
3236     private String resolveName(String name) {
3237         if (!name.startsWith(&quot;/&quot;)) {
3238             Class&lt;?&gt; c = isArray() ? elementType() : this;
3239             String baseName = c.getPackageName();
3240             if (baseName != null &amp;&amp; !baseName.isEmpty()) {
3241                 name = baseName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; + name;
3242             }
3243         } else {
3244             name = name.substring(1);
3245         }
3246         return name;
3247     }
3248 
3249     /**
3250      * Atomic operations support.
3251      */
3252     private static class Atomic {
3253         // initialize Unsafe machinery here, since we need to call Class.class instance method
3254         // and have to avoid calling it in the static initializer of the Class class...
3255         private static final Unsafe unsafe = Unsafe.getUnsafe();
3256         // offset of Class.reflectionData instance field
3257         private static final long reflectionDataOffset
3258                 = unsafe.objectFieldOffset(Class.class, &quot;reflectionData&quot;);
3259         // offset of Class.annotationType instance field
3260         private static final long annotationTypeOffset
3261                 = unsafe.objectFieldOffset(Class.class, &quot;annotationType&quot;);
3262         // offset of Class.annotationData instance field
3263         private static final long annotationDataOffset
3264                 = unsafe.objectFieldOffset(Class.class, &quot;annotationData&quot;);
3265 
3266         static &lt;T&gt; boolean casReflectionData(Class&lt;?&gt; clazz,
3267                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldData,
3268                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; newData) {
3269             return unsafe.compareAndSetReference(clazz, reflectionDataOffset, oldData, newData);
3270         }
3271 
3272         static &lt;T&gt; boolean casAnnotationType(Class&lt;?&gt; clazz,
3273                                              AnnotationType oldType,
3274                                              AnnotationType newType) {
3275             return unsafe.compareAndSetReference(clazz, annotationTypeOffset, oldType, newType);
3276         }
3277 
3278         static &lt;T&gt; boolean casAnnotationData(Class&lt;?&gt; clazz,
3279                                              AnnotationData oldData,
3280                                              AnnotationData newData) {
3281             return unsafe.compareAndSetReference(clazz, annotationDataOffset, oldData, newData);
3282         }
3283     }
3284 
3285     /**
3286      * Reflection support.
3287      */
3288 
3289     // Reflection data caches various derived names and reflective members. Cached
3290     // values may be invalidated when JVM TI RedefineClasses() is called
3291     private static class ReflectionData&lt;T&gt; {
3292         volatile Field[] declaredFields;
3293         volatile Field[] publicFields;
3294         volatile Method[] declaredMethods;
3295         volatile Method[] publicMethods;
3296         volatile Constructor&lt;T&gt;[] declaredConstructors;
3297         volatile Constructor&lt;T&gt;[] publicConstructors;
3298         // Intermediate results for getFields and getMethods
3299         volatile Field[] declaredPublicFields;
3300         volatile Method[] declaredPublicMethods;
3301         volatile Class&lt;?&gt;[] interfaces;
3302 
3303         // Cached names
3304         String simpleName;
3305         String canonicalName;
3306         static final String NULL_SENTINEL = new String();
3307 
3308         // Value of classRedefinedCount when we created this ReflectionData instance
3309         final int redefinedCount;
3310 
3311         ReflectionData(int redefinedCount) {
3312             this.redefinedCount = redefinedCount;
3313         }
3314     }
3315 
3316     private transient volatile SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;
3317 
3318     // Incremented by the VM on each call to JVM TI RedefineClasses()
3319     // that redefines this class or a superclass.
3320     private transient volatile int classRedefinedCount;
3321 
3322     // Lazily create and cache ReflectionData
3323     private ReflectionData&lt;T&gt; reflectionData() {
3324         SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData;
3325         int classRedefinedCount = this.classRedefinedCount;
3326         ReflectionData&lt;T&gt; rd;
3327         if (reflectionData != null &amp;&amp;
3328             (rd = reflectionData.get()) != null &amp;&amp;
3329             rd.redefinedCount == classRedefinedCount) {
3330             return rd;
3331         }
3332         // else no SoftReference or cleared SoftReference or stale ReflectionData
3333         // -&gt; create and replace new instance
3334         return newReflectionData(reflectionData, classRedefinedCount);
3335     }
3336 
3337     private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,
3338                                                 int classRedefinedCount) {
3339         while (true) {
3340             ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount);
3341             // try to CAS it...
3342             if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {
3343                 return rd;
3344             }
3345             // else retry
3346             oldReflectionData = this.reflectionData;
3347             classRedefinedCount = this.classRedefinedCount;
3348             if (oldReflectionData != null &amp;&amp;
3349                 (rd = oldReflectionData.get()) != null &amp;&amp;
3350                 rd.redefinedCount == classRedefinedCount) {
3351                 return rd;
3352             }
3353         }
3354     }
3355 
3356     // Generic signature handling
3357     private native String getGenericSignature0();
3358 
3359     // Generic info repository; lazily initialized
3360     private transient volatile ClassRepository genericInfo;
3361 
3362     // accessor for factory
3363     private GenericsFactory getFactory() {
3364         // create scope and factory
3365         return CoreReflectionFactory.make(this, ClassScope.make(this));
3366     }
3367 
3368     // accessor for generic info repository;
3369     // generic info is lazily initialized
3370     private ClassRepository getGenericInfo() {
3371         ClassRepository genericInfo = this.genericInfo;
3372         if (genericInfo == null) {
3373             String signature = getGenericSignature0();
3374             if (signature == null) {
3375                 genericInfo = ClassRepository.NONE;
3376             } else {
3377                 genericInfo = ClassRepository.make(signature, getFactory());
3378             }
3379             this.genericInfo = genericInfo;
3380         }
3381         return (genericInfo != ClassRepository.NONE) ? genericInfo : null;
3382     }
3383 
3384     // Annotations handling
3385     native byte[] getRawAnnotations();
3386     // Since 1.8
3387     native byte[] getRawTypeAnnotations();
3388     static byte[] getExecutableTypeAnnotationBytes(Executable ex) {
3389         return getReflectionFactory().getExecutableTypeAnnotationBytes(ex);
3390     }
3391 
3392     native ConstantPool getConstantPool();
3393 
3394     //
3395     //
3396     // java.lang.reflect.Field handling
3397     //
3398     //
3399 
3400     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3401     // be propagated to the outside world, but must instead be copied
3402     // via ReflectionFactory.copyField.
3403     private Field[] privateGetDeclaredFields(boolean publicOnly) {
3404         Field[] res;
3405         ReflectionData&lt;T&gt; rd = reflectionData();
3406         if (rd != null) {
3407             res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;
3408             if (res != null) return res;
3409         }
3410         // No cached value available; request value from VM
3411         res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
3412         if (rd != null) {
3413             if (publicOnly) {
3414                 rd.declaredPublicFields = res;
3415             } else {
3416                 rd.declaredFields = res;
3417             }
3418         }
3419         return res;
3420     }
3421 
3422     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3423     // be propagated to the outside world, but must instead be copied
3424     // via ReflectionFactory.copyField.
3425     private Field[] privateGetPublicFields() {
3426         Field[] res;
3427         ReflectionData&lt;T&gt; rd = reflectionData();
3428         if (rd != null) {
3429             res = rd.publicFields;
3430             if (res != null) return res;
3431         }
3432 
3433         // Use a linked hash set to ensure order is preserved and
3434         // fields from common super interfaces are not duplicated
3435         LinkedHashSet&lt;Field&gt; fields = new LinkedHashSet&lt;&gt;();
3436 
3437         // Local fields
3438         addAll(fields, privateGetDeclaredFields(true));
3439 
3440         // Direct superinterfaces, recursively
3441         for (Class&lt;?&gt; si : getInterfaces()) {
3442             addAll(fields, si.privateGetPublicFields());
3443         }
3444 
3445         // Direct superclass, recursively
3446         Class&lt;?&gt; sc = getSuperclass();
3447         if (sc != null) {
3448             addAll(fields, sc.privateGetPublicFields());
3449         }
3450 
3451         res = fields.toArray(new Field[0]);
3452         if (rd != null) {
3453             rd.publicFields = res;
3454         }
3455         return res;
3456     }
3457 
3458     private static void addAll(Collection&lt;Field&gt; c, Field[] o) {
3459         for (Field f : o) {
3460             c.add(f);
3461         }
3462     }
3463 
3464 
3465     //
3466     //
3467     // java.lang.reflect.Constructor handling
3468     //
3469     //
3470 
3471     // Returns an array of &quot;root&quot; constructors. These Constructor
3472     // objects must NOT be propagated to the outside world, but must
3473     // instead be copied via ReflectionFactory.copyConstructor.
3474     private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
3475         Constructor&lt;T&gt;[] res;
3476         ReflectionData&lt;T&gt; rd = reflectionData();
3477         if (rd != null) {
3478             res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;
3479             if (res != null) return res;
3480         }
3481         // No cached value available; request value from VM
3482         if (isInterface()) {
3483             @SuppressWarnings(&quot;unchecked&quot;)
3484             Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];
3485             res = temporaryRes;
3486         } else {
3487             res = getDeclaredConstructors0(publicOnly);
3488         }
3489         if (rd != null) {
3490             if (publicOnly) {
3491                 rd.publicConstructors = res;
3492             } else {
3493                 rd.declaredConstructors = res;
3494             }
3495         }
3496         return res;
3497     }
3498 
3499     //
3500     //
3501     // java.lang.reflect.Method handling
3502     //
3503     //
3504 
3505     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3506     // be propagated to the outside world, but must instead be copied
3507     // via ReflectionFactory.copyMethod.
3508     private Method[] privateGetDeclaredMethods(boolean publicOnly) {
3509         Method[] res;
3510         ReflectionData&lt;T&gt; rd = reflectionData();
3511         if (rd != null) {
3512             res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;
3513             if (res != null) return res;
3514         }
3515         // No cached value available; request value from VM
3516         res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
3517         if (rd != null) {
3518             if (publicOnly) {
3519                 rd.declaredPublicMethods = res;
3520             } else {
3521                 rd.declaredMethods = res;
3522             }
3523         }
3524         return res;
3525     }
3526 
3527     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3528     // be propagated to the outside world, but must instead be copied
3529     // via ReflectionFactory.copyMethod.
3530     private Method[] privateGetPublicMethods() {
3531         Method[] res;
3532         ReflectionData&lt;T&gt; rd = reflectionData();
3533         if (rd != null) {
3534             res = rd.publicMethods;
3535             if (res != null) return res;
3536         }
3537 
3538         // No cached value available; compute value recursively.
3539         // Start by fetching public declared methods...
3540         PublicMethods pms = new PublicMethods();
3541         for (Method m : privateGetDeclaredMethods(/* publicOnly */ true)) {
3542             pms.merge(m);
3543         }
3544         // ...then recur over superclass methods...
3545         Class&lt;?&gt; sc = getSuperclass();
3546         if (sc != null) {
3547             for (Method m : sc.privateGetPublicMethods()) {
3548                 pms.merge(m);
3549             }
3550         }
3551         // ...and finally over direct superinterfaces.
3552         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3553             for (Method m : intf.privateGetPublicMethods()) {
3554                 // static interface methods are not inherited
3555                 if (!Modifier.isStatic(m.getModifiers())) {
3556                     pms.merge(m);
3557                 }
3558             }
3559         }
3560 
3561         res = pms.toArray();
3562         if (rd != null) {
3563             rd.publicMethods = res;
3564         }
3565         return res;
3566     }
3567 
3568 
3569     //
3570     // Helpers for fetchers of one field, method, or constructor
3571     //
3572 
3573     // This method does not copy the returned Field object!
3574     private static Field searchFields(Field[] fields, String name) {
3575         for (Field field : fields) {
3576             if (field.getName().equals(name)) {
3577                 return field;
3578             }
3579         }
3580         return null;
3581     }
3582 
3583     // Returns a &quot;root&quot; Field object. This Field object must NOT
3584     // be propagated to the outside world, but must instead be copied
3585     // via ReflectionFactory.copyField.
3586     private Field getField0(String name) {
3587         // Note: the intent is that the search algorithm this routine
3588         // uses be equivalent to the ordering imposed by
3589         // privateGetPublicFields(). It fetches only the declared
3590         // public fields for each class, however, to reduce the number
3591         // of Field objects which have to be created for the common
3592         // case where the field being requested is declared in the
3593         // class which is being queried.
3594         Field res;
3595         // Search declared public fields
3596         if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {
3597             return res;
3598         }
3599         // Direct superinterfaces, recursively
3600         Class&lt;?&gt;[] interfaces = getInterfaces(/* cloneArray */ false);
3601         for (Class&lt;?&gt; c : interfaces) {
3602             if ((res = c.getField0(name)) != null) {
3603                 return res;
3604             }
3605         }
3606         // Direct superclass, recursively
3607         if (!isInterface()) {
3608             Class&lt;?&gt; c = getSuperclass();
3609             if (c != null) {
3610                 if ((res = c.getField0(name)) != null) {
3611                     return res;
3612                 }
3613             }
3614         }
3615         return null;
3616     }
3617 
3618     // This method does not copy the returned Method object!
3619     private static Method searchMethods(Method[] methods,
3620                                         String name,
3621                                         Class&lt;?&gt;[] parameterTypes)
3622     {
3623         ReflectionFactory fact = getReflectionFactory();
3624         Method res = null;
3625         for (Method m : methods) {
3626             if (m.getName().equals(name)
3627                 &amp;&amp; arrayContentsEq(parameterTypes,
3628                                    fact.getExecutableSharedParameterTypes(m))
3629                 &amp;&amp; (res == null
3630                     || (res.getReturnType() != m.getReturnType()
3631                         &amp;&amp; res.getReturnType().isAssignableFrom(m.getReturnType()))))
3632                 res = m;
3633         }
3634         return res;
3635     }
3636 
3637     private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];
3638 
3639     // Returns a &quot;root&quot; Method object. This Method object must NOT
3640     // be propagated to the outside world, but must instead be copied
3641     // via ReflectionFactory.copyMethod.
3642     private Method getMethod0(String name, Class&lt;?&gt;[] parameterTypes) {
3643         PublicMethods.MethodList res = getMethodsRecursive(
3644             name,
3645             parameterTypes == null ? EMPTY_CLASS_ARRAY : parameterTypes,
3646             /* includeStatic */ true);
3647         return res == null ? null : res.getMostSpecific();
3648     }
3649 
3650     // Returns a list of &quot;root&quot; Method objects. These Method objects must NOT
3651     // be propagated to the outside world, but must instead be copied
3652     // via ReflectionFactory.copyMethod.
3653     private PublicMethods.MethodList getMethodsRecursive(String name,
3654                                                          Class&lt;?&gt;[] parameterTypes,
3655                                                          boolean includeStatic) {
3656         // 1st check declared public methods
3657         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
3658         PublicMethods.MethodList res = PublicMethods.MethodList
3659             .filter(methods, name, parameterTypes, includeStatic);
3660         // if there is at least one match among declared methods, we need not
3661         // search any further as such match surely overrides matching methods
3662         // declared in superclass(es) or interface(s).
3663         if (res != null) {
3664             return res;
3665         }
3666 
3667         // if there was no match among declared methods,
3668         // we must consult the superclass (if any) recursively...
3669         Class&lt;?&gt; sc = getSuperclass();
3670         if (sc != null) {
3671             res = sc.getMethodsRecursive(name, parameterTypes, includeStatic);
3672         }
3673 
3674         // ...and coalesce the superclass methods with methods obtained
3675         // from directly implemented interfaces excluding static methods...
3676         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3677             res = PublicMethods.MethodList.merge(
3678                 res, intf.getMethodsRecursive(name, parameterTypes,
3679                                               /* includeStatic */ false));
3680         }
3681 
3682         return res;
3683     }
3684 
3685     // Returns a &quot;root&quot; Constructor object. This Constructor object must NOT
3686     // be propagated to the outside world, but must instead be copied
3687     // via ReflectionFactory.copyConstructor.
3688     private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,
3689                                         int which) throws NoSuchMethodException
3690     {
3691         ReflectionFactory fact = getReflectionFactory();
3692         Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
3693         for (Constructor&lt;T&gt; constructor : constructors) {
3694             if (arrayContentsEq(parameterTypes,
3695                                 fact.getExecutableSharedParameterTypes(constructor))) {
3696                 return constructor;
3697             }
3698         }
3699         throw new NoSuchMethodException(methodToString(&quot;&lt;init&gt;&quot;, parameterTypes));
3700     }
3701 
3702     //
3703     // Other helpers and base implementation
3704     //
3705 
3706     private static boolean arrayContentsEq(Object[] a1, Object[] a2) {
3707         if (a1 == null) {
3708             return a2 == null || a2.length == 0;
3709         }
3710 
3711         if (a2 == null) {
3712             return a1.length == 0;
3713         }
3714 
3715         if (a1.length != a2.length) {
3716             return false;
3717         }
3718 
3719         for (int i = 0; i &lt; a1.length; i++) {
3720             if (a1[i] != a2[i]) {
3721                 return false;
3722             }
3723         }
3724 
3725         return true;
3726     }
3727 
3728     private static Field[] copyFields(Field[] arg) {
3729         Field[] out = new Field[arg.length];
3730         ReflectionFactory fact = getReflectionFactory();
3731         for (int i = 0; i &lt; arg.length; i++) {
3732             out[i] = fact.copyField(arg[i]);
3733         }
3734         return out;
3735     }
3736 
3737     private static Method[] copyMethods(Method[] arg) {
3738         Method[] out = new Method[arg.length];
3739         ReflectionFactory fact = getReflectionFactory();
3740         for (int i = 0; i &lt; arg.length; i++) {
3741             out[i] = fact.copyMethod(arg[i]);
3742         }
3743         return out;
3744     }
3745 
3746     private static &lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) {
3747         Constructor&lt;U&gt;[] out = arg.clone();
3748         ReflectionFactory fact = getReflectionFactory();
3749         for (int i = 0; i &lt; out.length; i++) {
3750             out[i] = fact.copyConstructor(out[i]);
3751         }
3752         return out;
3753     }
3754 
3755     private native Field[]       getDeclaredFields0(boolean publicOnly);
3756     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3757     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3758     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3759     @SuppressWarnings(&quot;preview&quot;)
3760     private native RecordComponent[] getRecordComponents0();
3761     private native boolean      isRecord0();
3762 
3763     /**
3764      * Helper method to get the method name from arguments.
3765      */
3766     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3767         return getName() + &#39;.&#39; + name +
3768                 ((argTypes == null || argTypes.length == 0) ?
3769                 &quot;()&quot; :
3770                 Arrays.stream(argTypes)
3771                         .map(c -&gt; c == null ? &quot;null&quot; : c.getName())
3772                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3773     }
3774 
3775     /** use serialVersionUID from JDK 1.1 for interoperability */
3776     @java.io.Serial
3777     private static final long serialVersionUID = 3206093459760846163L;
3778 
3779 
3780     /**
3781      * Class Class is special cased within the Serialization Stream Protocol.
3782      *
3783      * A Class instance is written initially into an ObjectOutputStream in the
3784      * following format:
3785      * &lt;pre&gt;
3786      *      {@code TC_CLASS} ClassDescriptor
3787      *      A ClassDescriptor is a special cased serialization of
3788      *      a {@code java.io.ObjectStreamClass} instance.
3789      * &lt;/pre&gt;
3790      * A new handle is generated for the initial time the class descriptor
3791      * is written into the stream. Future references to the class descriptor
3792      * are written as references to the initial class descriptor instance.
3793      *
3794      * @see java.io.ObjectStreamClass
3795      */
3796     @java.io.Serial
3797     private static final ObjectStreamField[] serialPersistentFields =
3798         new ObjectStreamField[0];
3799 
3800 
3801     /**
3802      * Returns the assertion status that would be assigned to this
3803      * class if it were to be initialized at the time this method is invoked.
3804      * If this class has had its assertion status set, the most recent
3805      * setting will be returned; otherwise, if any package default assertion
3806      * status pertains to this class, the most recent setting for the most
3807      * specific pertinent package default assertion status is returned;
3808      * otherwise, if this class is not a system class (i.e., it has a
3809      * class loader) its class loader&#39;s default assertion status is returned;
3810      * otherwise, the system class default assertion status is returned.
3811      *
3812      * @apiNote
3813      * Few programmers will have any need for this method; it is provided
3814      * for the benefit of the JDK itself.  (It allows a class to determine at
3815      * the time that it is initialized whether assertions should be enabled.)
3816      * Note that this method is not guaranteed to return the actual
3817      * assertion status that was (or will be) associated with the specified
3818      * class when it was (or will be) initialized.
3819      *
3820      * @return the desired assertion status of the specified class.
3821      * @see    java.lang.ClassLoader#setClassAssertionStatus
3822      * @see    java.lang.ClassLoader#setPackageAssertionStatus
3823      * @see    java.lang.ClassLoader#setDefaultAssertionStatus
3824      * @since  1.4
3825      */
3826     public boolean desiredAssertionStatus() {
3827         ClassLoader loader = getClassLoader0();
3828         // If the loader is null this is a system class, so ask the VM
3829         if (loader == null)
3830             return desiredAssertionStatus0(this);
3831 
3832         // If the classloader has been initialized with the assertion
3833         // directives, ask it. Otherwise, ask the VM.
3834         synchronized(loader.assertionLock) {
3835             if (loader.classAssertionStatus != null) {
3836                 return loader.desiredAssertionStatus(getName());
3837             }
3838         }
3839         return desiredAssertionStatus0(this);
3840     }
3841 
3842     // Retrieves the desired assertion status of this class from the VM
3843     private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);
3844 
3845     /**
3846      * Returns true if and only if this class was declared as an enum in the
3847      * source code.
3848      *
3849      * Note that {@link java.lang.Enum} is not itself an enum type.
3850      *
3851      * Also note that if an enum constant is declared with a class body,
3852      * the class of that enum constant object is an anonymous class
3853      * and &lt;em&gt;not&lt;/em&gt; the class of the declaring enum type. The
3854      * {@link Enum#getDeclaringClass} method of an enum constant can
3855      * be used to get the class of the enum type declaring the
3856      * constant.
3857      *
3858      * @return true if and only if this class was declared as an enum in the
3859      *     source code
3860      * @since 1.5
3861      * @jls 8.9.1 Enum Constants
3862      */
3863     public boolean isEnum() {
3864         // An enum must both directly extend java.lang.Enum and have
3865         // the ENUM bit set; classes for specialized enum constants
3866         // don&#39;t do the former.
3867         return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;
3868         this.getSuperclass() == java.lang.Enum.class;
3869     }
3870 
3871     /** java.lang.Record.class */
3872     private static final Class&lt;?&gt; JAVA_LANG_RECORD_CLASS = javaLangRecordClass();
3873     private static Class&lt;?&gt; javaLangRecordClass() {
3874         try {
3875             return Class.forName0(&quot;java.lang.Record&quot;, false, null, null);
3876         } catch (ClassNotFoundException e) {
3877             throw new InternalError(&quot;should not reach here&quot;, e);
3878         }
3879     }
3880 
3881     /**
3882      * {@preview Associated with records, a preview feature of the Java language.
3883      *
3884      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
3885      *           feature of the Java language. Preview features
3886      *           may be removed in a future release, or upgraded to permanent
3887      *           features of the Java language.}
3888      *
3889      * Returns {@code true} if and only if this class is a record class.
3890      *
3891      * &lt;p&gt; The {@linkplain #getSuperclass() direct superclass} of a record
3892      * class is {@code java.lang.Record}. A record class has (possibly zero)
3893      * record components, that is, {@link #getRecordComponents()} returns a
3894      * non-null value.
3895      *
3896      * &lt;p&gt; Note that class {@link Record} is not a record type and thus invoking
3897      * this method on class {@code Record} returns {@code false}.
3898      *
3899      * @return true if and only if this class is a record class, otherwise false
3900      * @jls 8.10 Record Types
3901      * @since 14
3902      */
3903     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
3904                                  essentialAPI=false)
3905     public boolean isRecord() {
3906         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();
3907     }
3908 
3909     // Fetches the factory for reflective objects
3910     private static ReflectionFactory getReflectionFactory() {
3911         if (reflectionFactory == null) {
3912             reflectionFactory =
3913                 java.security.AccessController.doPrivileged
3914                     (new ReflectionFactory.GetReflectionFactoryAction());
3915         }
3916         return reflectionFactory;
3917     }
3918     private static ReflectionFactory reflectionFactory;
3919 
3920     /**
3921      * Returns the elements of this enum class or null if this
3922      * Class object does not represent an enum type.
3923      *
3924      * @return an array containing the values comprising the enum class
3925      *     represented by this {@code Class} object in the order they&#39;re
3926      *     declared, or null if this {@code Class} object does not
3927      *     represent an enum type
3928      * @since 1.5
3929      */
3930     public T[] getEnumConstants() {
3931         T[] values = getEnumConstantsShared();
3932         return (values != null) ? values.clone() : null;
3933     }
3934 
3935     /**
3936      * Returns the elements of this enum class or null if this
3937      * Class object does not represent an enum type;
3938      * identical to getEnumConstants except that the result is
3939      * uncloned, cached, and shared by all callers.
3940      */
3941     T[] getEnumConstantsShared() {
3942         T[] constants = enumConstants;
3943         if (constants == null) {
3944             if (!isEnum()) return null;
3945             try {
3946                 final Method values = getMethod(&quot;values&quot;);
3947                 java.security.AccessController.doPrivileged(
3948                     new java.security.PrivilegedAction&lt;&gt;() {
3949                         public Void run() {
3950                                 values.setAccessible(true);
3951                                 return null;
3952                             }
3953                         });
3954                 @SuppressWarnings(&quot;unchecked&quot;)
3955                 T[] temporaryConstants = (T[])values.invoke(null);
3956                 enumConstants = constants = temporaryConstants;
3957             }
3958             // These can happen when users concoct enum-like classes
3959             // that don&#39;t comply with the enum spec.
3960             catch (InvocationTargetException | NoSuchMethodException |
3961                    IllegalAccessException ex) { return null; }
3962         }
3963         return constants;
3964     }
3965     private transient volatile T[] enumConstants;
3966 
3967     /**
3968      * Returns a map from simple name to enum constant.  This package-private
3969      * method is used internally by Enum to implement
3970      * {@code public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)}
3971      * efficiently.  Note that the map is returned by this method is
3972      * created lazily on first use.  Typically it won&#39;t ever get created.
3973      */
3974     Map&lt;String, T&gt; enumConstantDirectory() {
3975         Map&lt;String, T&gt; directory = enumConstantDirectory;
3976         if (directory == null) {
3977             T[] universe = getEnumConstantsShared();
3978             if (universe == null)
3979                 throw new IllegalArgumentException(
3980                     getName() + &quot; is not an enum type&quot;);
3981             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3982             for (T constant : universe) {
3983                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3984             }
3985             enumConstantDirectory = directory;
3986         }
3987         return directory;
3988     }
3989     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3990 
3991     /**
3992      * Casts an object to the class or interface represented
3993      * by this {@code Class} object.
3994      *
3995      * @param obj the object to be cast
3996      * @return the object after casting, or null if obj is null
3997      *
3998      * @throws ClassCastException if the object is not
3999      * {@code null} and is not assignable to the type T.
4000      * @throws NullPointerException if this is an {@linkplain #isInlineClass()
4001      * inline type} and the object is {@code null}
4002      *
4003      * @since 1.5
4004      */
4005     @SuppressWarnings(&quot;unchecked&quot;)
4006     @HotSpotIntrinsicCandidate
4007     public T cast(Object obj) {
4008         if (isInlineClass() &amp;&amp; obj == null)
4009             throw new NullPointerException(getName() + &quot; is an inline class&quot;);
4010 
4011         if (obj != null &amp;&amp; !isInstance(obj))
4012             throw new ClassCastException(cannotCastMsg(obj));
4013         return (T) obj;
4014     }
4015 
4016     private String cannotCastMsg(Object obj) {
4017         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
4018     }
4019 
4020     /**
4021      * Casts this {@code Class} object to represent a subclass of the class
4022      * represented by the specified class object.  Checks that the cast
4023      * is valid, and throws a {@code ClassCastException} if it is not.  If
4024      * this method succeeds, it always returns a reference to this {@code Class} object.
4025      *
4026      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
4027      * a {@code Class} object to pass it to an API that restricts the
4028      * {@code Class} objects that it is willing to accept.  A cast would
4029      * generate a compile-time warning, as the correctness of the cast
4030      * could not be checked at runtime (because generic types are implemented
4031      * by erasure).
4032      *
4033      * @param &lt;U&gt; the type to cast this {@code Class} object to
4034      * @param clazz the class of the type to cast this {@code Class} object to
4035      * @return this {@code Class} object, cast to represent a subclass of
4036      *    the specified class object.
4037      * @throws ClassCastException if this {@code Class} object does not
4038      *    represent a subclass of the specified class (here &quot;subclass&quot; includes
4039      *    the class itself).
4040      * @since 1.5
4041      */
4042     @SuppressWarnings(&quot;unchecked&quot;)
4043     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
4044         if (clazz.isAssignableFrom(this))
4045             return (Class&lt;? extends U&gt;) this;
4046         else
4047             throw new ClassCastException(this.toString());
4048     }
4049 
4050     /**
4051      * {@inheritDoc}
4052      * &lt;p&gt;Note that any annotation returned by this method is a
4053      * declaration annotation.
4054      *
4055      * @throws NullPointerException {@inheritDoc}
4056      * @since 1.5
4057      */
4058     @Override
4059     @SuppressWarnings(&quot;unchecked&quot;)
4060     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
4061         Objects.requireNonNull(annotationClass);
4062 
4063         return (A) annotationData().annotations.get(annotationClass);
4064     }
4065 
4066     /**
4067      * {@inheritDoc}
4068      * @throws NullPointerException {@inheritDoc}
4069      * @since 1.5
4070      */
4071     @Override
4072     public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
4073         return GenericDeclaration.super.isAnnotationPresent(annotationClass);
4074     }
4075 
4076     /**
4077      * {@inheritDoc}
4078      * &lt;p&gt;Note that any annotations returned by this method are
4079      * declaration annotations.
4080      *
4081      * @throws NullPointerException {@inheritDoc}
4082      * @since 1.8
4083      */
4084     @Override
4085     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
4086         Objects.requireNonNull(annotationClass);
4087 
4088         AnnotationData annotationData = annotationData();
4089         return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,
4090                                                           this,
4091                                                           annotationClass);
4092     }
4093 
4094     /**
4095      * {@inheritDoc}
4096      * &lt;p&gt;Note that any annotations returned by this method are
4097      * declaration annotations.
4098      *
4099      * @since 1.5
4100      */
4101     @Override
4102     public Annotation[] getAnnotations() {
4103         return AnnotationParser.toArray(annotationData().annotations);
4104     }
4105 
4106     /**
4107      * {@inheritDoc}
4108      * &lt;p&gt;Note that any annotation returned by this method is a
4109      * declaration annotation.
4110      *
4111      * @throws NullPointerException {@inheritDoc}
4112      * @since 1.8
4113      */
4114     @Override
4115     @SuppressWarnings(&quot;unchecked&quot;)
4116     public &lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) {
4117         Objects.requireNonNull(annotationClass);
4118 
4119         return (A) annotationData().declaredAnnotations.get(annotationClass);
4120     }
4121 
4122     /**
4123      * {@inheritDoc}
4124      * &lt;p&gt;Note that any annotations returned by this method are
4125      * declaration annotations.
4126      *
4127      * @throws NullPointerException {@inheritDoc}
4128      * @since 1.8
4129      */
4130     @Override
4131     public &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
4132         Objects.requireNonNull(annotationClass);
4133 
4134         return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,
4135                                                                  annotationClass);
4136     }
4137 
4138     /**
4139      * {@inheritDoc}
4140      * &lt;p&gt;Note that any annotations returned by this method are
4141      * declaration annotations.
4142      *
4143      * @since 1.5
4144      */
4145     @Override
4146     public Annotation[] getDeclaredAnnotations()  {
4147         return AnnotationParser.toArray(annotationData().declaredAnnotations);
4148     }
4149 
4150     // annotation data that might get invalidated when JVM TI RedefineClasses() is called
4151     private static class AnnotationData {
4152         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;
4153         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
4154 
4155         // Value of classRedefinedCount when we created this AnnotationData instance
4156         final int redefinedCount;
4157 
4158         AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,
4159                        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,
4160                        int redefinedCount) {
4161             this.annotations = annotations;
4162             this.declaredAnnotations = declaredAnnotations;
4163             this.redefinedCount = redefinedCount;
4164         }
4165     }
4166 
4167     // Annotations cache
4168     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
4169     private transient volatile AnnotationData annotationData;
4170 
4171     private AnnotationData annotationData() {
4172         while (true) { // retry loop
4173             AnnotationData annotationData = this.annotationData;
4174             int classRedefinedCount = this.classRedefinedCount;
4175             if (annotationData != null &amp;&amp;
4176                 annotationData.redefinedCount == classRedefinedCount) {
4177                 return annotationData;
4178             }
4179             // null or stale annotationData -&gt; optimistically create new instance
4180             AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);
4181             // try to install it
4182             if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) {
4183                 // successfully installed new AnnotationData
4184                 return newAnnotationData;
4185             }
4186         }
4187     }
4188 
4189     private AnnotationData createAnnotationData(int classRedefinedCount) {
4190         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations =
4191             AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this);
4192         Class&lt;?&gt; superClass = getSuperclass();
4193         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations = null;
4194         if (superClass != null) {
4195             Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; superAnnotations =
4196                 superClass.annotationData().annotations;
4197             for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superAnnotations.entrySet()) {
4198                 Class&lt;? extends Annotation&gt; annotationClass = e.getKey();
4199                 if (AnnotationType.getInstance(annotationClass).isInherited()) {
4200                     if (annotations == null) { // lazy construction
4201                         annotations = new LinkedHashMap&lt;&gt;((Math.max(
4202                                 declaredAnnotations.size(),
4203                                 Math.min(12, declaredAnnotations.size() + superAnnotations.size())
4204                             ) * 4 + 2) / 3
4205                         );
4206                     }
4207                     annotations.put(annotationClass, e.getValue());
4208                 }
4209             }
4210         }
4211         if (annotations == null) {
4212             // no inherited annotations -&gt; share the Map with declaredAnnotations
4213             annotations = declaredAnnotations;
4214         } else {
4215             // at least one inherited annotation -&gt; declared may override inherited
4216             annotations.putAll(declaredAnnotations);
4217         }
4218         return new AnnotationData(annotations, declaredAnnotations, classRedefinedCount);
4219     }
4220 
4221     // Annotation types cache their internal (AnnotationType) form
4222 
4223     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
4224     private transient volatile AnnotationType annotationType;
4225 
4226     boolean casAnnotationType(AnnotationType oldType, AnnotationType newType) {
4227         return Atomic.casAnnotationType(this, oldType, newType);
4228     }
4229 
4230     AnnotationType getAnnotationType() {
4231         return annotationType;
4232     }
4233 
4234     Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap() {
4235         return annotationData().declaredAnnotations;
4236     }
4237 
4238     /* Backing store of user-defined values pertaining to this class.
4239      * Maintained by the ClassValue class.
4240      */
4241     transient ClassValue.ClassValueMap classValueMap;
4242 
4243     /**
4244      * Returns an {@code AnnotatedType} object that represents the use of a
4245      * type to specify the superclass of the entity represented by this {@code
4246      * Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify the superclass
4247      * in &#39;...  extends Foo&#39; is distinct from the &lt;em&gt;declaration&lt;/em&gt; of type
4248      * Foo.)
4249      *
4250      * &lt;p&gt; If this {@code Class} object represents a type whose declaration
4251      * does not explicitly indicate an annotated superclass, then the return
4252      * value is an {@code AnnotatedType} object representing an element with no
4253      * annotations.
4254      *
4255      * &lt;p&gt; If this {@code Class} represents either the {@code Object} class, an
4256      * interface type, an array type, a primitive type, or void, the return
4257      * value is {@code null}.
4258      *
4259      * @return an object representing the superclass
4260      * @since 1.8
4261      */
4262     public AnnotatedType getAnnotatedSuperclass() {
4263         if (this == Object.class ||
4264                 isInterface() ||
4265                 isArray() ||
4266                 isPrimitive() ||
4267                 this == Void.TYPE) {
4268             return null;
4269         }
4270 
4271         return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), this);
4272     }
4273 
4274     /**
4275      * Returns an array of {@code AnnotatedType} objects that represent the use
4276      * of types to specify superinterfaces of the entity represented by this
4277      * {@code Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify a
4278      * superinterface in &#39;... implements Foo&#39; is distinct from the
4279      * &lt;em&gt;declaration&lt;/em&gt; of type Foo.)
4280      *
4281      * &lt;p&gt; If this {@code Class} object represents a class, the return value is
4282      * an array containing objects representing the uses of interface types to
4283      * specify interfaces implemented by the class. The order of the objects in
4284      * the array corresponds to the order of the interface types used in the
4285      * &#39;implements&#39; clause of the declaration of this {@code Class} object.
4286      *
4287      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4288      * value is an array containing objects representing the uses of interface
4289      * types to specify interfaces directly extended by the interface. The
4290      * order of the objects in the array corresponds to the order of the
4291      * interface types used in the &#39;extends&#39; clause of the declaration of this
4292      * {@code Class} object.
4293      *
4294      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4295      * declaration does not explicitly indicate any annotated superinterfaces,
4296      * the return value is an array of length 0.
4297      *
4298      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4299      * class, an array type, a primitive type, or void, the return value is an
4300      * array of length 0.
4301      *
4302      * @return an array representing the superinterfaces
4303      * @since 1.8
4304      */
4305     public AnnotatedType[] getAnnotatedInterfaces() {
4306         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);
4307     }
4308 
4309     private native Class&lt;?&gt; getNestHost0();
4310 
4311     /**
4312      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4313      * or interface represented by this {@code Class} object belongs.
4314      * Every class and interface belongs to exactly one nest.
4315      *
4316      * If the nest host of this class or interface has previously
4317      * been determined, then this method returns the nest host.
4318      * If the nest host of this class or interface has
4319      * not previously been determined, then this method determines the nest
4320      * host using the algorithm of JVMS 5.4.4, and returns it.
4321      *
4322      * Often, a class or interface belongs to a nest consisting only of itself,
4323      * in which case this method returns {@code this} to indicate that the class
4324      * or interface is the nest host.
4325      *
4326      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,
4327      * or {@code void}, then this method returns {@code this},
4328      * indicating that the represented entity belongs to the nest consisting only of
4329      * itself, and is the nest host.
4330      *
4331      * @return the nest host of this class or interface
4332      *
4333      * @throws SecurityException
4334      *         If the returned class is not the current class, and
4335      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4336      *         class loader is not the same as or an ancestor of the class
4337      *         loader for the returned class and invocation of {@link
4338      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4339      *         denies access to the package of the returned class
4340      * @since 11
4341      * @jvms 4.7.28 The {@code NestHost} Attribute
4342      * @jvms 4.7.29 The {@code NestMembers} Attribute
4343      * @jvms 5.4.4 Access Control
4344      */
4345     @CallerSensitive
4346     public Class&lt;?&gt; getNestHost() {
4347         if (isPrimitive() || isArray()) {
4348             return this;
4349         }
4350 
4351         Class&lt;?&gt; host = getNestHost0();
4352         if (host == this) {
4353             return this;
4354         }
4355         // returning a different class requires a security check
4356         SecurityManager sm = System.getSecurityManager();
4357         if (sm != null) {
4358             checkPackageAccess(sm,
4359                                ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4360         }
4361         return host;
4362     }
4363 
4364     /**
4365      * Determines if the given {@code Class} is a nestmate of the
4366      * class or interface represented by this {@code Class} object.
4367      * Two classes or interfaces are nestmates
4368      * if they have the same {@linkplain #getNestHost() nest host}.
4369      *
4370      * @param c the class to check
4371      * @return {@code true} if this class and {@code c} are members of
4372      * the same nest; and {@code false} otherwise.
4373      *
4374      * @since 11
4375      */
4376     public boolean isNestmateOf(Class&lt;?&gt; c) {
4377         if (this == c) {
4378             return true;
4379         }
4380         if (isPrimitive() || isArray() ||
4381             c.isPrimitive() || c.isArray()) {
4382             return false;
4383         }
4384 
4385         return getNestHost() == c.getNestHost();
4386     }
4387 
4388     private native Class&lt;?&gt;[] getNestMembers0();
4389 
4390     /**
4391      * Returns an array containing {@code Class} objects representing all the
4392      * classes and interfaces that are members of the nest to which the class
4393      * or interface represented by this {@code Class} object belongs.
4394      *
4395      * First, this method obtains the {@linkplain #getNestHost() nest host},
4396      * {@code H}, of the nest to which the class or interface represented by
4397      * this {@code Class} object belongs. The zeroth element of the returned
4398      * array is {@code H}.
4399      *
4400      * Then, for each class or interface {@code C} which is recorded by {@code H}
4401      * as being a member of its nest, this method attempts to obtain the {@code Class}
4402      * object for {@code C} (using {@linkplain #getClassLoader() the defining class
4403      * loader} of the current {@code Class} object), and then obtains the
4404      * {@linkplain #getNestHost() nest host} of the nest to which {@code C} belongs.
4405      * The classes and interfaces which are recorded by {@code H} as being members
4406      * of its nest, and for which {@code H} can be determined as their nest host,
4407      * are indicated by subsequent elements of the returned array. The order of
4408      * such elements is unspecified. Duplicates are permitted.
4409      *
4410      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,
4411      * or {@code void}, then this method returns a single-element array containing
4412      * {@code this}.
4413      *
4414      * @apiNote
4415      * The returned array includes only the nest members recorded in the {@code NestMembers}
4416      * attribute, and not any hidden classes that were added to the nest via
4417      * {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
4418      * Lookup::defineHiddenClass}.
4419      *
4420      * @return an array of all classes and interfaces in the same nest as
4421      * this class or interface
4422      *
4423      * @throws SecurityException
4424      * If any returned class is not the current class, and
4425      * if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4426      * class loader is not the same as or an ancestor of the class
4427      * loader for that returned class and invocation of {@link
4428      * SecurityManager#checkPackageAccess s.checkPackageAccess()}
4429      * denies access to the package of that returned class
4430      *
4431      * @since 11
4432      * @see #getNestHost()
4433      * @jvms 4.7.28 The {@code NestHost} Attribute
4434      * @jvms 4.7.29 The {@code NestMembers} Attribute
4435      */
4436     @CallerSensitive
4437     public Class&lt;?&gt;[] getNestMembers() {
4438         if (isPrimitive() || isArray()) {
4439             return new Class&lt;?&gt;[] { this };
4440         }
4441         Class&lt;?&gt;[] members = getNestMembers0();
4442         // Can&#39;t actually enable this due to bootstrapping issues
4443         // assert(members.length != 1 || members[0] == this); // expected invariant from VM
4444 
4445         if (members.length &gt; 1) {
4446             // If we return anything other than the current class we need
4447             // a security check
4448             SecurityManager sm = System.getSecurityManager();
4449             if (sm != null) {
4450                 checkPackageAccess(sm,
4451                                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4452             }
4453         }
4454         return members;
4455     }
4456 
4457     /**
4458      * Returns the descriptor string of the entity (class, interface, array class,
4459      * primitive type, or {@code void}) represented by this {@code Class} object.
4460      *
4461      * &lt;p&gt; If this {@code Class} object represents a class or interface,
4462      * not an array class, then:
4463      * &lt;ul&gt;
4464      * &lt;li&gt; If the class or interface is not {@linkplain Class#isHidden() hidden},
4465      *      then the result is a field descriptor (JVMS {@jvms 4.3.2})
4466      *      for the class or interface. Calling
4467      *      {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}
4468      *      with the result descriptor string produces a {@link ClassDesc ClassDesc}
4469      *      describing this class or interface.
4470      * &lt;li&gt; If the class or interface is {@linkplain Class#isHidden() hidden},
4471      *      then the result is a string of the form:
4472      *      &lt;blockquote&gt;
4473      *      {@code &quot;L&quot; +} &lt;em&gt;N&lt;/em&gt; {@code + &quot;.&quot; + &lt;suffix&gt; + &quot;;&quot;}
4474      *      &lt;/blockquote&gt;
4475      *      where &lt;em&gt;N&lt;/em&gt; is the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
4476      *      encoded in internal form indicated by the {@code class} file passed to
4477      *      {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
4478      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.
4479      *      A hidden class or interface has no {@linkplain ClassDesc nominal descriptor}.
4480      *      The result string is not a type descriptor.
4481      * &lt;/ul&gt;
4482      *
4483      * &lt;p&gt; If this {@code Class} object represents an array class, then
4484      * the result is a string consisting of one or more &#39;{@code [}&#39; characters
4485      * representing the depth of the array nesting, followed by the
4486      * descriptor string of the element type.
4487      * &lt;ul&gt;
4488      * &lt;li&gt; If the element type is not a {@linkplain Class#isHidden() hidden} class
4489      * or interface, then this array class can be described nominally.
4490      * Calling {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}
4491      * with the result descriptor string produces a {@link ClassDesc ClassDesc}
4492      * describing this array class.
4493      * &lt;li&gt; If the element type is a {@linkplain Class#isHidden() hidden} class or
4494      * interface, then this array class cannot be described nominally.
4495      * The result string is not a type descriptor.
4496      * &lt;/ul&gt;
4497      *
4498      * &lt;p&gt; If this {@code Class} object represents a primitive type or
4499      * {@code void}, then the result is a field descriptor string which
4500      * is a one-letter code corresponding to a primitive type or {@code void}
4501      * ({@code &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;}) (JVMS {@jvms 4.3.2}).
4502      *
4503      * @apiNote
4504      * This is not a strict inverse of {@link #forName};
4505      * distinct classes which share a common name but have different class loaders
4506      * will have identical descriptor strings.
4507      *
4508      * @return the descriptor string for this {@code Class} object
4509      * @jvms 4.3.2 Field Descriptors
4510      * @since 12
4511      */
4512     @Override
4513     public String descriptorString() {
4514         if (isPrimitive())
4515             return Wrapper.forPrimitiveType(this).basicTypeString();
4516 
4517         if (isArray()) {
4518             return &quot;[&quot; + componentType.descriptorString();
4519         }
4520         String typeDesc = isInlineClass() ? &quot;Q&quot; : &quot;L&quot;;
4521         if (isHidden()) {
4522             String name = getName();
4523             int index = name.indexOf(&#39;/&#39;);
4524             return typeDesc + name.substring(0, index).replace(&#39;.&#39;, &#39;/&#39;)
4525                        + &quot;.&quot; + name.substring(index+1) + &quot;;&quot;;
4526         } else {
4527             return typeDesc + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;
4528         }
4529     }
4530 
4531     /**
4532      * Returns the component type of this {@code Class}, if it describes
4533      * an array type, or {@code null} otherwise.
4534      *
4535      * @implSpec
4536      * Equivalent to {@link Class#getComponentType()}.
4537      *
4538      * @return a {@code Class} describing the component type, or {@code null}
4539      * if this {@code Class} does not describe an array type
4540      * @since 12
4541      */
4542     @Override
4543     public Class&lt;?&gt; componentType() {
4544         return isArray() ? componentType : null;
4545     }
4546 
4547     /**
4548      * Returns a {@code Class} for an array type whose component type
4549      * is described by this {@linkplain Class}.
4550      *
4551      * @return a {@code Class} describing the array type
4552      * @since 12
4553      */
4554     @Override
4555     public Class&lt;?&gt; arrayType() {
4556         return Array.newInstance(this, 0).getClass();
4557     }
4558 
4559     /**
4560      * Returns a nominal descriptor for this instance, if one can be
4561      * constructed, or an empty {@link Optional} if one cannot be.
4562      *
4563      * @return An {@link Optional} containing the resulting nominal descriptor,
4564      * or an empty {@link Optional} if one cannot be constructed.
4565      * @since 12
4566      */
4567     @Override
4568     public Optional&lt;ClassDesc&gt; describeConstable() {
4569         Class&lt;?&gt; c = isArray() ? elementType() : this;
4570         return c.isHidden() ? Optional.empty()
4571                             : Optional.of(ClassDesc.ofDescriptor(descriptorString()));
4572    }
4573 
4574     /**
4575      * Returns {@code true} if and only if the underlying class is a hidden class.
4576      *
4577      * @return {@code true} if and only if this class is a hidden class.
4578      *
4579      * @since 15
4580      * @see MethodHandles.Lookup#defineHiddenClass
4581      */
4582     @HotSpotIntrinsicCandidate
4583     public native boolean isHidden();
4584 
4585     /**
4586      * {@preview Associated with sealed classes, a preview feature of the Java language.
4587      *
4588      *           This method is associated with &lt;i&gt;sealed classes&lt;/i&gt;, a preview
4589      *           feature of the Java language. Preview features
4590      *           may be removed in a future release, or upgraded to permanent
4591      *           features of the Java language.}
4592      *
4593      * Returns an array containing {@code ClassDesc} objects representing all the
4594      * direct subclasses or direct implementation classes permitted to extend or
4595      * implement this class or interface if it is sealed. The order of such elements
4596      * is unspecified. If this {@code Class} object represents a primitive type,
4597      * {@code void}, an array type, or a class or interface that is not sealed,
4598      * an empty array is returned.
4599      *
4600      * @return an array of class descriptors of all the permitted subclasses of this class or interface
4601      *
4602      * @jls 8.1 Class Declarations
4603      * @jls 9.1 Interface Declarations
4604      * @since 15
4605      */
4606     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.SEALED_CLASSES, essentialAPI=false)
4607     public ClassDesc[] permittedSubclasses() {
4608         String[] subclassNames;
4609         if (isArray() || isPrimitive() || (subclassNames = getPermittedSubclasses0()).length == 0) {
4610             return EMPTY_CLASS_DESC_ARRAY;
4611         }
4612         ClassDesc[] constants = new ClassDesc[subclassNames.length];
4613         int i = 0;
4614         for (String subclassName : subclassNames) {
4615             try {
4616                 constants[i++] = ClassDesc.of(subclassName.replace(&#39;/&#39;, &#39;.&#39;));
4617             } catch (IllegalArgumentException iae) {
4618                 throw new InternalError(&quot;Invalid type in permitted subclasses information: &quot; + subclassName, iae);
4619             }
4620         }
4621         return constants;
4622     }
4623 
4624     /**
4625      * * {@preview Associated with sealed classes, a preview feature of the Java language.
4626      *
4627      *           This method is associated with &lt;i&gt;sealed classes&lt;/i&gt;, a preview
4628      *           feature of the Java language. Preview features
4629      *           may be removed in a future release, or upgraded to permanent
4630      *           features of the Java language.}
4631      *
4632      * Returns {@code true} if and only if this {@code Class} object represents a sealed class or interface.
4633      * If this {@code Class} object represents a primitive type, {@code void}, or an array type, this method returns
4634      * {@code false}.
4635      *
4636      * @return {@code true} if and only if this {@code Class} object represents a sealed class or interface.
4637      *
4638      * @jls 8.1 Class Declarations
4639      * @jls 9.1 Interface Declarations
4640      * @since 15
4641      */
4642     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.SEALED_CLASSES, essentialAPI=false)
4643     @SuppressWarnings(&quot;preview&quot;)
4644     public boolean isSealed() {
4645         if (isArray() || isPrimitive()) {
4646             return false;
4647         }
4648         return permittedSubclasses().length != 0;
4649     }
4650 
4651     private native String[] getPermittedSubclasses0();
4652 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>