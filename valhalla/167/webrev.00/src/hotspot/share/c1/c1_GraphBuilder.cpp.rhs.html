<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_GraphBuilder.hpp&quot;
  30 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  31 #include &quot;ci/ciCallSite.hpp&quot;
  32 #include &quot;ci/ciField.hpp&quot;
  33 #include &quot;ci/ciFlatArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInlineKlass.hpp&quot;
  35 #include &quot;ci/ciKlass.hpp&quot;
  36 #include &quot;ci/ciMemberName.hpp&quot;
  37 #include &quot;ci/ciUtilities.inline.hpp&quot;
  38 #include &quot;compiler/compilationPolicy.hpp&quot;
  39 #include &quot;compiler/compileBroker.hpp&quot;
  40 #include &quot;compiler/compilerEvent.hpp&quot;
  41 #include &quot;interpreter/bytecode.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;oops/oop.inline.hpp&quot;
  45 #include &quot;runtime/sharedRuntime.hpp&quot;
  46 #include &quot;runtime/vm_version.hpp&quot;
  47 #include &quot;utilities/bitMap.inline.hpp&quot;
  48 #include &quot;utilities/powerOfTwo.hpp&quot;
  49 
  50 class BlockListBuilder {
  51  private:
  52   Compilation* _compilation;
  53   IRScope*     _scope;
  54 
  55   BlockList    _blocks;                // internal list of all blocks
  56   BlockList*   _bci2block;             // mapping from bci to blocks for GraphBuilder
  57 
  58   // fields used by mark_loops
  59   ResourceBitMap _active;              // for iteration of control flow graph
  60   ResourceBitMap _visited;             // for iteration of control flow graph
  61   intArray       _loop_map;            // caches the information if a block is contained in a loop
  62   int            _next_loop_index;     // next free loop number
  63   int            _next_block_number;   // for reverse postorder numbering of blocks
  64 
  65   // accessors
  66   Compilation*  compilation() const              { return _compilation; }
  67   IRScope*      scope() const                    { return _scope; }
  68   ciMethod*     method() const                   { return scope()-&gt;method(); }
  69   XHandlers*    xhandlers() const                { return scope()-&gt;xhandlers(); }
  70 
  71   // unified bailout support
  72   void          bailout(const char* msg) const   { compilation()-&gt;bailout(msg); }
  73   bool          bailed_out() const               { return compilation()-&gt;bailed_out(); }
  74 
  75   // helper functions
  76   BlockBegin* make_block_at(int bci, BlockBegin* predecessor);
  77   void handle_exceptions(BlockBegin* current, int cur_bci);
  78   void handle_jsr(BlockBegin* current, int sr_bci, int next_bci);
  79   void store_one(BlockBegin* current, int local);
  80   void store_two(BlockBegin* current, int local);
  81   void set_entries(int osr_bci);
  82   void set_leaders();
  83 
  84   void make_loop_header(BlockBegin* block);
  85   void mark_loops();
  86   int  mark_loops(BlockBegin* b, bool in_subroutine);
  87 
  88   // debugging
  89 #ifndef PRODUCT
  90   void print();
  91 #endif
  92 
  93  public:
  94   // creation
  95   BlockListBuilder(Compilation* compilation, IRScope* scope, int osr_bci);
  96 
  97   // accessors for GraphBuilder
  98   BlockList*    bci2block() const                { return _bci2block; }
  99 };
 100 
 101 
 102 // Implementation of BlockListBuilder
 103 
 104 BlockListBuilder::BlockListBuilder(Compilation* compilation, IRScope* scope, int osr_bci)
 105  : _compilation(compilation)
 106  , _scope(scope)
 107  , _blocks(16)
 108  , _bci2block(new BlockList(scope-&gt;method()-&gt;code_size(), NULL))
 109  , _active()         // size not known yet
 110  , _visited()        // size not known yet
 111  , _loop_map() // size not known yet
 112  , _next_loop_index(0)
 113  , _next_block_number(0)
 114 {
 115   set_entries(osr_bci);
 116   set_leaders();
 117   CHECK_BAILOUT();
 118 
 119   mark_loops();
 120   NOT_PRODUCT(if (PrintInitialBlockList) print());
 121 
 122 #ifndef PRODUCT
 123   if (PrintCFGToFile) {
 124     stringStream title;
 125     title.print(&quot;BlockListBuilder &quot;);
 126     scope-&gt;method()-&gt;print_name(&amp;title);
 127     CFGPrinter::print_cfg(_bci2block, title.as_string(), false, false);
 128   }
 129 #endif
 130 }
 131 
 132 
 133 void BlockListBuilder::set_entries(int osr_bci) {
 134   // generate start blocks
 135   BlockBegin* std_entry = make_block_at(0, NULL);
 136   if (scope()-&gt;caller() == NULL) {
 137     std_entry-&gt;set(BlockBegin::std_entry_flag);
 138   }
 139   if (osr_bci != -1) {
 140     BlockBegin* osr_entry = make_block_at(osr_bci, NULL);
 141     osr_entry-&gt;set(BlockBegin::osr_entry_flag);
 142   }
 143 
 144   // generate exception entry blocks
 145   XHandlers* list = xhandlers();
 146   const int n = list-&gt;length();
 147   for (int i = 0; i &lt; n; i++) {
 148     XHandler* h = list-&gt;handler_at(i);
 149     BlockBegin* entry = make_block_at(h-&gt;handler_bci(), NULL);
 150     entry-&gt;set(BlockBegin::exception_entry_flag);
 151     h-&gt;set_entry_block(entry);
 152   }
 153 }
 154 
 155 
 156 BlockBegin* BlockListBuilder::make_block_at(int cur_bci, BlockBegin* predecessor) {
 157   assert(method()-&gt;bci_block_start().at(cur_bci), &quot;wrong block starts of MethodLivenessAnalyzer&quot;);
 158 
 159   BlockBegin* block = _bci2block-&gt;at(cur_bci);
 160   if (block == NULL) {
 161     block = new BlockBegin(cur_bci);
 162     block-&gt;init_stores_to_locals(method()-&gt;max_locals());
 163     _bci2block-&gt;at_put(cur_bci, block);
 164     _blocks.append(block);
 165 
 166     assert(predecessor == NULL || predecessor-&gt;bci() &lt; cur_bci, &quot;targets for backward branches must already exist&quot;);
 167   }
 168 
 169   if (predecessor != NULL) {
 170     if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
 171       BAILOUT_(&quot;Exception handler can be reached by both normal and exceptional control flow&quot;, block);
 172     }
 173 
 174     predecessor-&gt;add_successor(block);
 175     block-&gt;increment_total_preds();
 176   }
 177 
 178   return block;
 179 }
 180 
 181 
 182 inline void BlockListBuilder::store_one(BlockBegin* current, int local) {
 183   current-&gt;stores_to_locals().set_bit(local);
 184 }
 185 inline void BlockListBuilder::store_two(BlockBegin* current, int local) {
 186   store_one(current, local);
 187   store_one(current, local + 1);
 188 }
 189 
 190 
 191 void BlockListBuilder::handle_exceptions(BlockBegin* current, int cur_bci) {
 192   // Draws edges from a block to its exception handlers
 193   XHandlers* list = xhandlers();
 194   const int n = list-&gt;length();
 195 
 196   for (int i = 0; i &lt; n; i++) {
 197     XHandler* h = list-&gt;handler_at(i);
 198 
 199     if (h-&gt;covers(cur_bci)) {
 200       BlockBegin* entry = h-&gt;entry_block();
 201       assert(entry != NULL &amp;&amp; entry == _bci2block-&gt;at(h-&gt;handler_bci()), &quot;entry must be set&quot;);
 202       assert(entry-&gt;is_set(BlockBegin::exception_entry_flag), &quot;flag must be set&quot;);
 203 
 204       // add each exception handler only once
 205       if (!current-&gt;is_successor(entry)) {
 206         current-&gt;add_successor(entry);
 207         entry-&gt;increment_total_preds();
 208       }
 209 
 210       // stop when reaching catchall
 211       if (h-&gt;catch_type() == 0) break;
 212     }
 213   }
 214 }
 215 
 216 void BlockListBuilder::handle_jsr(BlockBegin* current, int sr_bci, int next_bci) {
 217   // start a new block after jsr-bytecode and link this block into cfg
 218   make_block_at(next_bci, current);
 219 
 220   // start a new block at the subroutine entry at mark it with special flag
 221   BlockBegin* sr_block = make_block_at(sr_bci, current);
 222   if (!sr_block-&gt;is_set(BlockBegin::subroutine_entry_flag)) {
 223     sr_block-&gt;set(BlockBegin::subroutine_entry_flag);
 224   }
 225 }
 226 
 227 
 228 void BlockListBuilder::set_leaders() {
 229   bool has_xhandlers = xhandlers()-&gt;has_handlers();
 230   BlockBegin* current = NULL;
 231 
 232   // The information which bci starts a new block simplifies the analysis
 233   // Without it, backward branches could jump to a bci where no block was created
 234   // during bytecode iteration. This would require the creation of a new block at the
 235   // branch target and a modification of the successor lists.
 236   const BitMap&amp; bci_block_start = method()-&gt;bci_block_start();
 237 
 238   ciBytecodeStream s(method());
 239   while (s.next() != ciBytecodeStream::EOBC()) {
 240     int cur_bci = s.cur_bci();
 241 
 242     if (bci_block_start.at(cur_bci)) {
 243       current = make_block_at(cur_bci, current);
 244     }
 245     assert(current != NULL, &quot;must have current block&quot;);
 246 
 247     if (has_xhandlers &amp;&amp; GraphBuilder::can_trap(method(), s.cur_bc())) {
 248       handle_exceptions(current, cur_bci);
 249     }
 250 
 251     switch (s.cur_bc()) {
 252       // track stores to local variables for selective creation of phi functions
 253       case Bytecodes::_iinc:     store_one(current, s.get_index()); break;
 254       case Bytecodes::_istore:   store_one(current, s.get_index()); break;
 255       case Bytecodes::_lstore:   store_two(current, s.get_index()); break;
 256       case Bytecodes::_fstore:   store_one(current, s.get_index()); break;
 257       case Bytecodes::_dstore:   store_two(current, s.get_index()); break;
 258       case Bytecodes::_astore:   store_one(current, s.get_index()); break;
 259       case Bytecodes::_istore_0: store_one(current, 0); break;
 260       case Bytecodes::_istore_1: store_one(current, 1); break;
 261       case Bytecodes::_istore_2: store_one(current, 2); break;
 262       case Bytecodes::_istore_3: store_one(current, 3); break;
 263       case Bytecodes::_lstore_0: store_two(current, 0); break;
 264       case Bytecodes::_lstore_1: store_two(current, 1); break;
 265       case Bytecodes::_lstore_2: store_two(current, 2); break;
 266       case Bytecodes::_lstore_3: store_two(current, 3); break;
 267       case Bytecodes::_fstore_0: store_one(current, 0); break;
 268       case Bytecodes::_fstore_1: store_one(current, 1); break;
 269       case Bytecodes::_fstore_2: store_one(current, 2); break;
 270       case Bytecodes::_fstore_3: store_one(current, 3); break;
 271       case Bytecodes::_dstore_0: store_two(current, 0); break;
 272       case Bytecodes::_dstore_1: store_two(current, 1); break;
 273       case Bytecodes::_dstore_2: store_two(current, 2); break;
 274       case Bytecodes::_dstore_3: store_two(current, 3); break;
 275       case Bytecodes::_astore_0: store_one(current, 0); break;
 276       case Bytecodes::_astore_1: store_one(current, 1); break;
 277       case Bytecodes::_astore_2: store_one(current, 2); break;
 278       case Bytecodes::_astore_3: store_one(current, 3); break;
 279 
 280       // track bytecodes that affect the control flow
 281       case Bytecodes::_athrow:  // fall through
 282       case Bytecodes::_ret:     // fall through
 283       case Bytecodes::_ireturn: // fall through
 284       case Bytecodes::_lreturn: // fall through
 285       case Bytecodes::_freturn: // fall through
 286       case Bytecodes::_dreturn: // fall through
 287       case Bytecodes::_areturn: // fall through
 288       case Bytecodes::_return:
 289         current = NULL;
 290         break;
 291 
 292       case Bytecodes::_ifeq:      // fall through
 293       case Bytecodes::_ifne:      // fall through
 294       case Bytecodes::_iflt:      // fall through
 295       case Bytecodes::_ifge:      // fall through
 296       case Bytecodes::_ifgt:      // fall through
 297       case Bytecodes::_ifle:      // fall through
 298       case Bytecodes::_if_icmpeq: // fall through
 299       case Bytecodes::_if_icmpne: // fall through
 300       case Bytecodes::_if_icmplt: // fall through
 301       case Bytecodes::_if_icmpge: // fall through
 302       case Bytecodes::_if_icmpgt: // fall through
 303       case Bytecodes::_if_icmple: // fall through
 304       case Bytecodes::_if_acmpeq: // fall through
 305       case Bytecodes::_if_acmpne: // fall through
 306       case Bytecodes::_ifnull:    // fall through
 307       case Bytecodes::_ifnonnull:
 308         make_block_at(s.next_bci(), current);
 309         make_block_at(s.get_dest(), current);
 310         current = NULL;
 311         break;
 312 
 313       case Bytecodes::_goto:
 314         make_block_at(s.get_dest(), current);
 315         current = NULL;
 316         break;
 317 
 318       case Bytecodes::_goto_w:
 319         make_block_at(s.get_far_dest(), current);
 320         current = NULL;
 321         break;
 322 
 323       case Bytecodes::_jsr:
 324         handle_jsr(current, s.get_dest(), s.next_bci());
 325         current = NULL;
 326         break;
 327 
 328       case Bytecodes::_jsr_w:
 329         handle_jsr(current, s.get_far_dest(), s.next_bci());
 330         current = NULL;
 331         break;
 332 
 333       case Bytecodes::_tableswitch: {
 334         // set block for each case
 335         Bytecode_tableswitch sw(&amp;s);
 336         int l = sw.length();
 337         for (int i = 0; i &lt; l; i++) {
 338           make_block_at(cur_bci + sw.dest_offset_at(i), current);
 339         }
 340         make_block_at(cur_bci + sw.default_offset(), current);
 341         current = NULL;
 342         break;
 343       }
 344 
 345       case Bytecodes::_lookupswitch: {
 346         // set block for each case
 347         Bytecode_lookupswitch sw(&amp;s);
 348         int l = sw.number_of_pairs();
 349         for (int i = 0; i &lt; l; i++) {
 350           make_block_at(cur_bci + sw.pair_at(i).offset(), current);
 351         }
 352         make_block_at(cur_bci + sw.default_offset(), current);
 353         current = NULL;
 354         break;
 355       }
 356 
 357       default:
 358         break;
 359     }
 360   }
 361 }
 362 
 363 
 364 void BlockListBuilder::mark_loops() {
 365   ResourceMark rm;
 366 
 367   _active.initialize(BlockBegin::number_of_blocks());
 368   _visited.initialize(BlockBegin::number_of_blocks());
 369   _loop_map = intArray(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), 0);
 370   _next_loop_index = 0;
 371   _next_block_number = _blocks.length();
 372 
 373   // recursively iterate the control flow graph
 374   mark_loops(_bci2block-&gt;at(0), false);
 375   assert(_next_block_number &gt;= 0, &quot;invalid block numbers&quot;);
 376 
 377   // Remove dangling Resource pointers before the ResourceMark goes out-of-scope.
 378   _active.resize(0);
 379   _visited.resize(0);
 380 }
 381 
 382 void BlockListBuilder::make_loop_header(BlockBegin* block) {
 383   if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
 384     // exception edges may look like loops but don&#39;t mark them as such
 385     // since it screws up block ordering.
 386     return;
 387   }
 388   if (!block-&gt;is_set(BlockBegin::parser_loop_header_flag)) {
 389     block-&gt;set(BlockBegin::parser_loop_header_flag);
 390 
 391     assert(_loop_map.at(block-&gt;block_id()) == 0, &quot;must not be set yet&quot;);
 392     assert(0 &lt;= _next_loop_index &amp;&amp; _next_loop_index &lt; BitsPerInt, &quot;_next_loop_index is used as a bit-index in integer&quot;);
 393     _loop_map.at_put(block-&gt;block_id(), 1 &lt;&lt; _next_loop_index);
 394     if (_next_loop_index &lt; 31) _next_loop_index++;
 395   } else {
 396     // block already marked as loop header
 397     assert(is_power_of_2((unsigned int)_loop_map.at(block-&gt;block_id())), &quot;exactly one bit must be set&quot;);
 398   }
 399 }
 400 
 401 int BlockListBuilder::mark_loops(BlockBegin* block, bool in_subroutine) {
 402   int block_id = block-&gt;block_id();
 403 
 404   if (_visited.at(block_id)) {
 405     if (_active.at(block_id)) {
 406       // reached block via backward branch
 407       make_loop_header(block);
 408     }
 409     // return cached loop information for this block
 410     return _loop_map.at(block_id);
 411   }
 412 
 413   if (block-&gt;is_set(BlockBegin::subroutine_entry_flag)) {
 414     in_subroutine = true;
 415   }
 416 
 417   // set active and visited bits before successors are processed
 418   _visited.set_bit(block_id);
 419   _active.set_bit(block_id);
 420 
 421   intptr_t loop_state = 0;
 422   for (int i = block-&gt;number_of_sux() - 1; i &gt;= 0; i--) {
 423     // recursively process all successors
 424     loop_state |= mark_loops(block-&gt;sux_at(i), in_subroutine);
 425   }
 426 
 427   // clear active-bit after all successors are processed
 428   _active.clear_bit(block_id);
 429 
 430   // reverse-post-order numbering of all blocks
 431   block-&gt;set_depth_first_number(_next_block_number);
 432   _next_block_number--;
 433 
 434   if (loop_state != 0 || in_subroutine ) {
 435     // block is contained at least in one loop, so phi functions are necessary
 436     // phi functions are also necessary for all locals stored in a subroutine
 437     scope()-&gt;requires_phi_function().set_union(block-&gt;stores_to_locals());
 438   }
 439 
 440   if (block-&gt;is_set(BlockBegin::parser_loop_header_flag)) {
 441     int header_loop_state = _loop_map.at(block_id);
 442     assert(is_power_of_2((unsigned)header_loop_state), &quot;exactly one bit must be set&quot;);
 443 
 444     // If the highest bit is set (i.e. when integer value is negative), the method
 445     // has 32 or more loops. This bit is never cleared because it is used for multiple loops
 446     if (header_loop_state &gt;= 0) {
 447       clear_bits(loop_state, header_loop_state);
 448     }
 449   }
 450 
 451   // cache and return loop information for this block
 452   _loop_map.at_put(block_id, loop_state);
 453   return loop_state;
 454 }
 455 
 456 
 457 #ifndef PRODUCT
 458 
 459 int compare_depth_first(BlockBegin** a, BlockBegin** b) {
 460   return (*a)-&gt;depth_first_number() - (*b)-&gt;depth_first_number();
 461 }
 462 
 463 void BlockListBuilder::print() {
 464   tty-&gt;print(&quot;----- initial block list of BlockListBuilder for method &quot;);
 465   method()-&gt;print_short_name();
 466   tty-&gt;cr();
 467 
 468   // better readability if blocks are sorted in processing order
 469   _blocks.sort(compare_depth_first);
 470 
 471   for (int i = 0; i &lt; _blocks.length(); i++) {
 472     BlockBegin* cur = _blocks.at(i);
 473     tty-&gt;print(&quot;%4d: B%-4d bci: %-4d  preds: %-4d &quot;, cur-&gt;depth_first_number(), cur-&gt;block_id(), cur-&gt;bci(), cur-&gt;total_preds());
 474 
 475     tty-&gt;print(cur-&gt;is_set(BlockBegin::std_entry_flag)               ? &quot; std&quot; : &quot;    &quot;);
 476     tty-&gt;print(cur-&gt;is_set(BlockBegin::osr_entry_flag)               ? &quot; osr&quot; : &quot;    &quot;);
 477     tty-&gt;print(cur-&gt;is_set(BlockBegin::exception_entry_flag)         ? &quot; ex&quot; : &quot;   &quot;);
 478     tty-&gt;print(cur-&gt;is_set(BlockBegin::subroutine_entry_flag)        ? &quot; sr&quot; : &quot;   &quot;);
 479     tty-&gt;print(cur-&gt;is_set(BlockBegin::parser_loop_header_flag)      ? &quot; lh&quot; : &quot;   &quot;);
 480 
 481     if (cur-&gt;number_of_sux() &gt; 0) {
 482       tty-&gt;print(&quot;    sux: &quot;);
 483       for (int j = 0; j &lt; cur-&gt;number_of_sux(); j++) {
 484         BlockBegin* sux = cur-&gt;sux_at(j);
 485         tty-&gt;print(&quot;B%d &quot;, sux-&gt;block_id());
 486       }
 487     }
 488     tty-&gt;cr();
 489   }
 490 }
 491 
 492 #endif
 493 
 494 
 495 // A simple growable array of Values indexed by ciFields
 496 class FieldBuffer: public CompilationResourceObj {
 497  private:
 498   GrowableArray&lt;Value&gt; _values;
 499 
 500  public:
 501   FieldBuffer() {}
 502 
 503   void kill() {
 504     _values.trunc_to(0);
 505   }
 506 
 507   Value at(ciField* field) {
 508     assert(field-&gt;holder()-&gt;is_loaded(), &quot;must be a loaded field&quot;);
 509     int offset = field-&gt;offset();
 510     if (offset &lt; _values.length()) {
 511       return _values.at(offset);
 512     } else {
 513       return NULL;
 514     }
 515   }
 516 
 517   void at_put(ciField* field, Value value) {
 518     assert(field-&gt;holder()-&gt;is_loaded(), &quot;must be a loaded field&quot;);
 519     int offset = field-&gt;offset();
 520     _values.at_put_grow(offset, value, NULL);
 521   }
 522 
 523 };
 524 
 525 
 526 // MemoryBuffer is fairly simple model of the current state of memory.
 527 // It partitions memory into several pieces.  The first piece is
 528 // generic memory where little is known about the owner of the memory.
 529 // This is conceptually represented by the tuple &lt;O, F, V&gt; which says
 530 // that the field F of object O has value V.  This is flattened so
 531 // that F is represented by the offset of the field and the parallel
 532 // arrays _objects and _values are used for O and V.  Loads of O.F can
 533 // simply use V.  Newly allocated objects are kept in a separate list
 534 // along with a parallel array for each object which represents the
 535 // current value of its fields.  Stores of the default value to fields
 536 // which have never been stored to before are eliminated since they
 537 // are redundant.  Once newly allocated objects are stored into
 538 // another object or they are passed out of the current compile they
 539 // are treated like generic memory.
 540 
 541 class MemoryBuffer: public CompilationResourceObj {
 542  private:
 543   FieldBuffer                 _values;
 544   GrowableArray&lt;Value&gt;        _objects;
 545   GrowableArray&lt;Value&gt;        _newobjects;
 546   GrowableArray&lt;FieldBuffer*&gt; _fields;
 547 
 548  public:
 549   MemoryBuffer() {}
 550 
 551   StoreField* store(StoreField* st) {
 552     if (!EliminateFieldAccess) {
 553       return st;
 554     }
 555 
 556     Value object = st-&gt;obj();
 557     Value value = st-&gt;value();
 558     ciField* field = st-&gt;field();
 559     if (field-&gt;holder()-&gt;is_loaded()) {
 560       int offset = field-&gt;offset();
 561       int index = _newobjects.find(object);
 562       if (index != -1) {
 563         // newly allocated object with no other stores performed on this field
 564         FieldBuffer* buf = _fields.at(index);
 565         if (buf-&gt;at(field) == NULL &amp;&amp; is_default_value(value)) {
 566 #ifndef PRODUCT
 567           if (PrintIRDuringConstruction &amp;&amp; Verbose) {
 568             tty-&gt;print_cr(&quot;Eliminated store for object %d:&quot;, index);
 569             st-&gt;print_line();
 570           }
 571 #endif
 572           return NULL;
 573         } else {
 574           buf-&gt;at_put(field, value);
 575         }
 576       } else {
 577         _objects.at_put_grow(offset, object, NULL);
 578         _values.at_put(field, value);
 579       }
 580 
 581       store_value(value);
 582     } else {
 583       // if we held onto field names we could alias based on names but
 584       // we don&#39;t know what&#39;s being stored to so kill it all.
 585       kill();
 586     }
 587     return st;
 588   }
 589 
 590 
 591   // return true if this value correspond to the default value of a field.
 592   bool is_default_value(Value value) {
 593     Constant* con = value-&gt;as_Constant();
 594     if (con) {
 595       switch (con-&gt;type()-&gt;tag()) {
 596         case intTag:    return con-&gt;type()-&gt;as_IntConstant()-&gt;value() == 0;
 597         case longTag:   return con-&gt;type()-&gt;as_LongConstant()-&gt;value() == 0;
 598         case floatTag:  return jint_cast(con-&gt;type()-&gt;as_FloatConstant()-&gt;value()) == 0;
 599         case doubleTag: return jlong_cast(con-&gt;type()-&gt;as_DoubleConstant()-&gt;value()) == jlong_cast(0);
 600         case objectTag: return con-&gt;type() == objectNull;
 601         default:  ShouldNotReachHere();
 602       }
 603     }
 604     return false;
 605   }
 606 
 607 
 608   // return either the actual value of a load or the load itself
 609   Value load(LoadField* load) {
 610     if (!EliminateFieldAccess) {
 611       return load;
 612     }
 613 
 614     if (strict_fp_requires_explicit_rounding &amp;&amp; load-&gt;type()-&gt;is_float_kind()) {
 615 #ifdef IA32
 616       if (UseSSE &lt; 2) {
 617         // can&#39;t skip load since value might get rounded as a side effect
 618         return load;
 619       }
 620 #else
 621       Unimplemented();
 622 #endif // IA32
 623     }
 624 
 625     ciField* field = load-&gt;field();
 626     Value object   = load-&gt;obj();
 627     if (field-&gt;holder()-&gt;is_loaded() &amp;&amp; !field-&gt;is_volatile()) {
 628       int offset = field-&gt;offset();
 629       Value result = NULL;
 630       int index = _newobjects.find(object);
 631       if (index != -1) {
 632         result = _fields.at(index)-&gt;at(field);
 633       } else if (_objects.at_grow(offset, NULL) == object) {
 634         result = _values.at(field);
 635       }
 636       if (result != NULL) {
 637 #ifndef PRODUCT
 638         if (PrintIRDuringConstruction &amp;&amp; Verbose) {
 639           tty-&gt;print_cr(&quot;Eliminated load: &quot;);
 640           load-&gt;print_line();
 641         }
 642 #endif
 643         assert(result-&gt;type()-&gt;tag() == load-&gt;type()-&gt;tag(), &quot;wrong types&quot;);
 644         return result;
 645       }
 646     }
 647     return load;
 648   }
 649 
 650   // Record this newly allocated object
 651   void new_instance(NewInstance* object) {
 652     int index = _newobjects.length();
 653     _newobjects.append(object);
 654     if (_fields.at_grow(index, NULL) == NULL) {
 655       _fields.at_put(index, new FieldBuffer());
 656     } else {
 657       _fields.at(index)-&gt;kill();
 658     }
 659   }
 660 
 661   // Record this newly allocated object
 662   void new_instance(NewInlineTypeInstance* object) {
 663     int index = _newobjects.length();
 664     _newobjects.append(object);
 665     if (_fields.at_grow(index, NULL) == NULL) {
 666       _fields.at_put(index, new FieldBuffer());
 667     } else {
 668       _fields.at(index)-&gt;kill();
 669     }
 670   }
 671 
 672   void store_value(Value value) {
 673     int index = _newobjects.find(value);
 674     if (index != -1) {
 675       // stored a newly allocated object into another object.
 676       // Assume we&#39;ve lost track of it as separate slice of memory.
 677       // We could do better by keeping track of whether individual
 678       // fields could alias each other.
 679       _newobjects.remove_at(index);
 680       // pull out the field info and store it at the end up the list
 681       // of field info list to be reused later.
 682       _fields.append(_fields.at(index));
 683       _fields.remove_at(index);
 684     }
 685   }
 686 
 687   void kill() {
 688     _newobjects.trunc_to(0);
 689     _objects.trunc_to(0);
 690     _values.kill();
 691   }
 692 };
 693 
 694 
 695 // Implementation of GraphBuilder&#39;s ScopeData
 696 
 697 GraphBuilder::ScopeData::ScopeData(ScopeData* parent)
 698   : _parent(parent)
 699   , _bci2block(NULL)
 700   , _scope(NULL)
 701   , _has_handler(false)
 702   , _stream(NULL)
 703   , _work_list(NULL)
 704   , _caller_stack_size(-1)
 705   , _continuation(NULL)
 706   , _parsing_jsr(false)
 707   , _jsr_xhandlers(NULL)
 708   , _num_returns(0)
 709   , _cleanup_block(NULL)
 710   , _cleanup_return_prev(NULL)
 711   , _cleanup_state(NULL)
 712   , _ignore_return(false)
 713 {
 714   if (parent != NULL) {
 715     _max_inline_size = (intx) ((float) NestedInliningSizeRatio * (float) parent-&gt;max_inline_size() / 100.0f);
 716   } else {
 717     _max_inline_size = C1MaxInlineSize;
 718   }
 719   if (_max_inline_size &lt; C1MaxTrivialSize) {
 720     _max_inline_size = C1MaxTrivialSize;
 721   }
 722 }
 723 
 724 
 725 void GraphBuilder::kill_all() {
 726   if (UseLocalValueNumbering) {
 727     vmap()-&gt;kill_all();
 728   }
 729   _memory-&gt;kill();
 730 }
 731 
 732 
 733 BlockBegin* GraphBuilder::ScopeData::block_at(int bci) {
 734   if (parsing_jsr()) {
 735     // It is necessary to clone all blocks associated with a
 736     // subroutine, including those for exception handlers in the scope
 737     // of the method containing the jsr (because those exception
 738     // handlers may contain ret instructions in some cases).
 739     BlockBegin* block = bci2block()-&gt;at(bci);
 740     if (block != NULL &amp;&amp; block == parent()-&gt;bci2block()-&gt;at(bci)) {
 741       BlockBegin* new_block = new BlockBegin(block-&gt;bci());
 742       if (PrintInitialBlockList) {
 743         tty-&gt;print_cr(&quot;CFG: cloned block %d (bci %d) as block %d for jsr&quot;,
 744                       block-&gt;block_id(), block-&gt;bci(), new_block-&gt;block_id());
 745       }
 746       // copy data from cloned blocked
 747       new_block-&gt;set_depth_first_number(block-&gt;depth_first_number());
 748       if (block-&gt;is_set(BlockBegin::parser_loop_header_flag)) new_block-&gt;set(BlockBegin::parser_loop_header_flag);
 749       // Preserve certain flags for assertion checking
 750       if (block-&gt;is_set(BlockBegin::subroutine_entry_flag)) new_block-&gt;set(BlockBegin::subroutine_entry_flag);
 751       if (block-&gt;is_set(BlockBegin::exception_entry_flag))  new_block-&gt;set(BlockBegin::exception_entry_flag);
 752 
 753       // copy was_visited_flag to allow early detection of bailouts
 754       // if a block that is used in a jsr has already been visited before,
 755       // it is shared between the normal control flow and a subroutine
 756       // BlockBegin::try_merge returns false when the flag is set, this leads
 757       // to a compilation bailout
 758       if (block-&gt;is_set(BlockBegin::was_visited_flag))  new_block-&gt;set(BlockBegin::was_visited_flag);
 759 
 760       bci2block()-&gt;at_put(bci, new_block);
 761       block = new_block;
 762     }
 763     return block;
 764   } else {
 765     return bci2block()-&gt;at(bci);
 766   }
 767 }
 768 
 769 
 770 XHandlers* GraphBuilder::ScopeData::xhandlers() const {
 771   if (_jsr_xhandlers == NULL) {
 772     assert(!parsing_jsr(), &quot;&quot;);
 773     return scope()-&gt;xhandlers();
 774   }
 775   assert(parsing_jsr(), &quot;&quot;);
 776   return _jsr_xhandlers;
 777 }
 778 
 779 
 780 void GraphBuilder::ScopeData::set_scope(IRScope* scope) {
 781   _scope = scope;
 782   bool parent_has_handler = false;
 783   if (parent() != NULL) {
 784     parent_has_handler = parent()-&gt;has_handler();
 785   }
 786   _has_handler = parent_has_handler || scope-&gt;xhandlers()-&gt;has_handlers();
 787 }
 788 
 789 
 790 void GraphBuilder::ScopeData::set_inline_cleanup_info(BlockBegin* block,
 791                                                       Instruction* return_prev,
 792                                                       ValueStack* return_state) {
 793   _cleanup_block       = block;
 794   _cleanup_return_prev = return_prev;
 795   _cleanup_state       = return_state;
 796 }
 797 
 798 
 799 void GraphBuilder::ScopeData::add_to_work_list(BlockBegin* block) {
 800   if (_work_list == NULL) {
 801     _work_list = new BlockList();
 802   }
 803 
 804   if (!block-&gt;is_set(BlockBegin::is_on_work_list_flag)) {
 805     // Do not start parsing the continuation block while in a
 806     // sub-scope
 807     if (parsing_jsr()) {
 808       if (block == jsr_continuation()) {
 809         return;
 810       }
 811     } else {
 812       if (block == continuation()) {
 813         return;
 814       }
 815     }
 816     block-&gt;set(BlockBegin::is_on_work_list_flag);
 817     _work_list-&gt;push(block);
 818 
 819     sort_top_into_worklist(_work_list, block);
 820   }
 821 }
 822 
 823 
 824 void GraphBuilder::sort_top_into_worklist(BlockList* worklist, BlockBegin* top) {
 825   assert(worklist-&gt;top() == top, &quot;&quot;);
 826   // sort block descending into work list
 827   const int dfn = top-&gt;depth_first_number();
 828   assert(dfn != -1, &quot;unknown depth first number&quot;);
 829   int i = worklist-&gt;length()-2;
 830   while (i &gt;= 0) {
 831     BlockBegin* b = worklist-&gt;at(i);
 832     if (b-&gt;depth_first_number() &lt; dfn) {
 833       worklist-&gt;at_put(i+1, b);
 834     } else {
 835       break;
 836     }
 837     i --;
 838   }
 839   if (i &gt;= -1) worklist-&gt;at_put(i + 1, top);
 840 }
 841 
 842 
 843 BlockBegin* GraphBuilder::ScopeData::remove_from_work_list() {
 844   if (is_work_list_empty()) {
 845     return NULL;
 846   }
 847   return _work_list-&gt;pop();
 848 }
 849 
 850 
 851 bool GraphBuilder::ScopeData::is_work_list_empty() const {
 852   return (_work_list == NULL || _work_list-&gt;length() == 0);
 853 }
 854 
 855 
 856 void GraphBuilder::ScopeData::setup_jsr_xhandlers() {
 857   assert(parsing_jsr(), &quot;&quot;);
 858   // clone all the exception handlers from the scope
 859   XHandlers* handlers = new XHandlers(scope()-&gt;xhandlers());
 860   const int n = handlers-&gt;length();
 861   for (int i = 0; i &lt; n; i++) {
 862     // The XHandlers need to be adjusted to dispatch to the cloned
 863     // handler block instead of the default one but the synthetic
 864     // unlocker needs to be handled specially.  The synthetic unlocker
 865     // should be left alone since there can be only one and all code
 866     // should dispatch to the same one.
 867     XHandler* h = handlers-&gt;handler_at(i);
 868     assert(h-&gt;handler_bci() != SynchronizationEntryBCI, &quot;must be real&quot;);
 869     h-&gt;set_entry_block(block_at(h-&gt;handler_bci()));
 870   }
 871   _jsr_xhandlers = handlers;
 872 }
 873 
 874 
 875 int GraphBuilder::ScopeData::num_returns() {
 876   if (parsing_jsr()) {
 877     return parent()-&gt;num_returns();
 878   }
 879   return _num_returns;
 880 }
 881 
 882 
 883 void GraphBuilder::ScopeData::incr_num_returns() {
 884   if (parsing_jsr()) {
 885     parent()-&gt;incr_num_returns();
 886   } else {
 887     ++_num_returns;
 888   }
 889 }
 890 
 891 
 892 // Implementation of GraphBuilder
 893 
 894 #define INLINE_BAILOUT(msg)        { inline_bailout(msg); return false; }
 895 
 896 
 897 void GraphBuilder::load_constant() {
 898   ciConstant con = stream()-&gt;get_constant();
 899   if (con.basic_type() == T_ILLEGAL) {
 900     // FIXME: an unresolved Dynamic constant can get here,
 901     // and that should not terminate the whole compilation.
 902     BAILOUT(&quot;could not resolve a constant&quot;);
 903   } else {
 904     ValueType* t = illegalType;
 905     ValueStack* patch_state = NULL;
 906     switch (con.basic_type()) {
 907       case T_BOOLEAN: t = new IntConstant     (con.as_boolean()); break;
 908       case T_BYTE   : t = new IntConstant     (con.as_byte   ()); break;
 909       case T_CHAR   : t = new IntConstant     (con.as_char   ()); break;
 910       case T_SHORT  : t = new IntConstant     (con.as_short  ()); break;
 911       case T_INT    : t = new IntConstant     (con.as_int    ()); break;
 912       case T_LONG   : t = new LongConstant    (con.as_long   ()); break;
 913       case T_FLOAT  : t = new FloatConstant   (con.as_float  ()); break;
 914       case T_DOUBLE : t = new DoubleConstant  (con.as_double ()); break;
 915       case T_ARRAY  : t = new ArrayConstant   (con.as_object ()-&gt;as_array   ()); break;
 916       case T_OBJECT :
 917        {
 918         ciObject* obj = con.as_object();
 919         if (!obj-&gt;is_loaded()
 920             || (PatchALot &amp;&amp; obj-&gt;klass() != ciEnv::current()-&gt;String_klass())) {
 921           // A Class, MethodType, MethodHandle, or String.
 922           // Unloaded condy nodes show up as T_ILLEGAL, above.
 923           patch_state = copy_state_before();
 924           t = new ObjectConstant(obj);
 925         } else {
 926           // Might be a Class, MethodType, MethodHandle, or Dynamic constant
 927           // result, which might turn out to be an array.
 928           if (obj-&gt;is_null_object())
 929             t = objectNull;
 930           else if (obj-&gt;is_array())
 931             t = new ArrayConstant(obj-&gt;as_array());
 932           else
 933             t = new InstanceConstant(obj-&gt;as_instance());
 934         }
 935         break;
 936        }
 937       default       : ShouldNotReachHere();
 938     }
 939     Value x;
 940     if (patch_state != NULL) {
 941       x = new Constant(t, patch_state);
 942     } else {
 943       x = new Constant(t);
 944     }
 945     push(t, append(x));
 946   }
 947 }
 948 
 949 
 950 void GraphBuilder::load_local(ValueType* type, int index) {
 951   Value x = state()-&gt;local_at(index);
 952   assert(x != NULL &amp;&amp; !x-&gt;type()-&gt;is_illegal(), &quot;access of illegal local variable&quot;);
 953   push(type, x);
 954   if (x-&gt;as_NewInlineTypeInstance() != NULL &amp;&amp; x-&gt;as_NewInlineTypeInstance()-&gt;in_larval_state()) {
 955     if (x-&gt;as_NewInlineTypeInstance()-&gt;on_stack_count() == 1) {
 956       x-&gt;as_NewInlineTypeInstance()-&gt;set_not_larva_anymore();
 957     } else {
 958       x-&gt;as_NewInlineTypeInstance()-&gt;increment_on_stack_count();
 959     }
 960   }
 961 }
 962 
 963 
 964 void GraphBuilder::store_local(ValueType* type, int index) {
 965   Value x = pop(type);
 966   store_local(state(), x, index);
 967   if (x-&gt;as_NewInlineTypeInstance() != NULL) {
 968     x-&gt;as_NewInlineTypeInstance()-&gt;set_local_index(index);
 969     x-&gt;as_NewInlineTypeInstance()-&gt;decrement_on_stack_count();
 970   }
 971 }
 972 
 973 
 974 void GraphBuilder::store_local(ValueStack* state, Value x, int index) {
 975   if (parsing_jsr()) {
 976     // We need to do additional tracking of the location of the return
 977     // address for jsrs since we don&#39;t handle arbitrary jsr/ret
 978     // constructs. Here we are figuring out in which circumstances we
 979     // need to bail out.
 980     if (x-&gt;type()-&gt;is_address()) {
 981       scope_data()-&gt;set_jsr_return_address_local(index);
 982 
 983       // Also check parent jsrs (if any) at this time to see whether
 984       // they are using this local. We don&#39;t handle skipping over a
 985       // ret.
 986       for (ScopeData* cur_scope_data = scope_data()-&gt;parent();
 987            cur_scope_data != NULL &amp;&amp; cur_scope_data-&gt;parsing_jsr() &amp;&amp; cur_scope_data-&gt;scope() == scope();
 988            cur_scope_data = cur_scope_data-&gt;parent()) {
 989         if (cur_scope_data-&gt;jsr_return_address_local() == index) {
 990           BAILOUT(&quot;subroutine overwrites return address from previous subroutine&quot;);
 991         }
 992       }
 993     } else if (index == scope_data()-&gt;jsr_return_address_local()) {
 994       scope_data()-&gt;set_jsr_return_address_local(-1);
 995     }
 996   }
 997 
 998   x-&gt;set_local_index(index);
 999   state-&gt;store_local(index, round_fp(x));
1000   if (x-&gt;as_NewInlineTypeInstance() != NULL) {
1001     x-&gt;as_NewInlineTypeInstance()-&gt;set_local_index(index);
1002     x-&gt;as_NewInlineTypeInstance()-&gt;decrement_on_stack_count();
1003   }
1004 }
1005 
1006 
1007 void GraphBuilder::load_indexed(BasicType type) {
1008   // In case of in block code motion in range check elimination
1009   ValueStack* state_before = NULL;
1010   int array_idx = state()-&gt;stack_size() - 2;
1011   if (type == T_OBJECT &amp;&amp; state()-&gt;stack_at(array_idx)-&gt;maybe_flattened_array()) {
1012     // Save the entire state and re-execute on deopt when accessing flattened arrays
1013     state_before = copy_state_before();
1014     state_before-&gt;set_should_reexecute(true);
1015   } else {
1016     state_before = copy_state_indexed_access();
1017   }
1018   compilation()-&gt;set_has_access_indexed(true);
1019   Value index = ipop();
1020   Value array = apop();
1021   Value length = NULL;
1022   if (CSEArrayLength ||
1023       (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
1024       (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
1025     length = append(new ArrayLength(array, state_before));
1026   }
1027 
1028   LoadIndexed* load_indexed = NULL;
1029   Instruction* result = NULL;
1030   if (array-&gt;is_loaded_flattened_array()) {
1031     ciType* array_type = array-&gt;declared_type();
1032     ciInlineKlass* elem_klass = array_type-&gt;as_flat_array_klass()-&gt;element_klass()-&gt;as_inline_klass();
1033     NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(elem_klass, state_before, false);
1034     _memory-&gt;new_instance(new_instance);
1035     apush(append_split(new_instance));
1036     load_indexed = new LoadIndexed(array, index, length, type, state_before);
1037     load_indexed-&gt;set_vt(new_instance);
1038   } else {
1039     load_indexed = new LoadIndexed(array, index, length, type, state_before);
1040   }
1041   if (profile_array_accesses() &amp;&amp; is_reference_type(type)) {
1042     compilation()-&gt;set_would_profile(true);
1043     load_indexed-&gt;set_should_profile(true);
1044     load_indexed-&gt;set_profiled_method(method());
1045     load_indexed-&gt;set_profiled_bci(bci());
1046   }
1047   result = append(load_indexed);
1048   assert(!(profile_array_accesses() &amp;&amp; is_reference_type(type)) || load_indexed == result, &quot;should not be optimized out&quot;);
1049   if (!array-&gt;is_loaded_flattened_array()) {
1050     push(as_ValueType(type), result);
1051   }
1052 }
1053 
1054 
1055 void GraphBuilder::store_indexed(BasicType type) {
1056   // In case of in block code motion in range check elimination
1057   ValueStack* state_before = NULL;
1058   int array_idx = state()-&gt;stack_size() - 3;
1059   if (type == T_OBJECT &amp;&amp; state()-&gt;stack_at(array_idx)-&gt;maybe_flattened_array()) {
1060     // Save the entire state and re-execute on deopt when accessing flattened arrays
1061     state_before = copy_state_before();
1062     state_before-&gt;set_should_reexecute(true);
1063   } else {
1064     state_before = copy_state_indexed_access();
1065   }
1066   compilation()-&gt;set_has_access_indexed(true);
1067   Value value = pop(as_ValueType(type));
1068   Value index = ipop();
1069   Value array = apop();
1070   Value length = NULL;
1071   value-&gt;set_escaped();
1072   if (CSEArrayLength ||
1073       (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
1074       (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
1075     length = append(new ArrayLength(array, state_before));
1076   }
1077   ciType* array_type = array-&gt;declared_type();
1078   bool check_boolean = false;
1079   if (array_type != NULL) {
1080     if (array_type-&gt;is_loaded() &amp;&amp;
1081       array_type-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type() == T_BOOLEAN) {
1082       assert(type == T_BYTE, &quot;boolean store uses bastore&quot;);
1083       Value mask = append(new Constant(new IntConstant(1)));
1084       value = append(new LogicOp(Bytecodes::_iand, value, mask));
1085     }
1086   } else if (type == T_BYTE) {
1087     check_boolean = true;
1088   }
1089 
1090   StoreIndexed* store_indexed = new StoreIndexed(array, index, length, type, value, state_before, check_boolean);
1091   if (profile_array_accesses() &amp;&amp; is_reference_type(type)) {
1092     compilation()-&gt;set_would_profile(true);
1093     store_indexed-&gt;set_should_profile(true);
1094     store_indexed-&gt;set_profiled_method(method());
1095     store_indexed-&gt;set_profiled_bci(bci());
1096   }
1097   Instruction* result = append(store_indexed);
1098   assert(!store_indexed-&gt;should_profile() || store_indexed == result, &quot;should not be optimized out&quot;);
1099   _memory-&gt;store_value(value);
1100 
1101 }
1102 
1103 void GraphBuilder::stack_op(Bytecodes::Code code) {
1104   switch (code) {
1105     case Bytecodes::_pop:
1106       { Value w = state()-&gt;raw_pop();
1107         update_larva_stack_count(w);
1108       }
1109       break;
1110     case Bytecodes::_pop2:
1111       { Value w1 = state()-&gt;raw_pop();
1112         Value w2 = state()-&gt;raw_pop();
1113         update_larva_stack_count(w1);
1114         update_larva_stack_count(w2);
1115       }
1116       break;
1117     case Bytecodes::_dup:
1118       { Value w = state()-&gt;raw_pop();
1119         update_larval_state(w);
1120         state()-&gt;raw_push(w);
1121         state()-&gt;raw_push(w);
1122       }
1123       break;
1124     case Bytecodes::_dup_x1:
1125       { Value w1 = state()-&gt;raw_pop();
1126         Value w2 = state()-&gt;raw_pop();
1127         update_larval_state(w1);
1128         state()-&gt;raw_push(w1);
1129         state()-&gt;raw_push(w2);
1130         state()-&gt;raw_push(w1);
1131       }
1132       break;
1133     case Bytecodes::_dup_x2:
1134       { Value w1 = state()-&gt;raw_pop();
1135         Value w2 = state()-&gt;raw_pop();
1136         Value w3 = state()-&gt;raw_pop();
1137         // special handling for the dup_x2/pop sequence (see JDK-8251046)
1138         if (w1 != NULL &amp;&amp; w1-&gt;as_NewInlineTypeInstance() != NULL) {
1139           ciBytecodeStream s(method());
1140           s.force_bci(bci());
1141           s.next();
1142           if (s.cur_bc() != Bytecodes::_pop) {
1143             w1-&gt;as_NewInlineTypeInstance()-&gt;set_not_larva_anymore();
1144           }  else {
1145             w1-&gt;as_NewInlineTypeInstance()-&gt;increment_on_stack_count();
1146            }
1147         }
1148         state()-&gt;raw_push(w1);
1149         state()-&gt;raw_push(w3);
1150         state()-&gt;raw_push(w2);
1151         state()-&gt;raw_push(w1);
1152       }
1153       break;
1154     case Bytecodes::_dup2:
1155       { Value w1 = state()-&gt;raw_pop();
1156         Value w2 = state()-&gt;raw_pop();
1157         update_larval_state(w1);
1158         update_larval_state(w2);
1159         state()-&gt;raw_push(w2);
1160         state()-&gt;raw_push(w1);
1161         state()-&gt;raw_push(w2);
1162         state()-&gt;raw_push(w1);
1163       }
1164       break;
1165     case Bytecodes::_dup2_x1:
1166       { Value w1 = state()-&gt;raw_pop();
1167         Value w2 = state()-&gt;raw_pop();
1168         Value w3 = state()-&gt;raw_pop();
1169         update_larval_state(w1);
1170         update_larval_state(w2);
1171         state()-&gt;raw_push(w2);
1172         state()-&gt;raw_push(w1);
1173         state()-&gt;raw_push(w3);
1174         state()-&gt;raw_push(w2);
1175         state()-&gt;raw_push(w1);
1176       }
1177       break;
1178     case Bytecodes::_dup2_x2:
1179       { Value w1 = state()-&gt;raw_pop();
1180         Value w2 = state()-&gt;raw_pop();
1181         Value w3 = state()-&gt;raw_pop();
1182         Value w4 = state()-&gt;raw_pop();
1183         update_larval_state(w1);
1184         update_larval_state(w2);
1185         state()-&gt;raw_push(w2);
1186         state()-&gt;raw_push(w1);
1187         state()-&gt;raw_push(w4);
1188         state()-&gt;raw_push(w3);
1189         state()-&gt;raw_push(w2);
1190         state()-&gt;raw_push(w1);
1191       }
1192       break;
1193     case Bytecodes::_swap:
1194       { Value w1 = state()-&gt;raw_pop();
1195         Value w2 = state()-&gt;raw_pop();
1196         state()-&gt;raw_push(w1);
1197         state()-&gt;raw_push(w2);
1198       }
1199       break;
1200     default:
1201       ShouldNotReachHere();
1202       break;
1203   }
1204 }
1205 
1206 
1207 void GraphBuilder::arithmetic_op(ValueType* type, Bytecodes::Code code, ValueStack* state_before) {
1208   Value y = pop(type);
1209   Value x = pop(type);
1210   // NOTE: strictfp can be queried from current method since we don&#39;t
1211   // inline methods with differing strictfp bits
1212   Value res = new ArithmeticOp(code, x, y, method()-&gt;is_strict(), state_before);
1213   // Note: currently single-precision floating-point rounding on Intel is handled at the LIRGenerator level
1214   res = append(res);
1215   if (method()-&gt;is_strict()) {
1216     res = round_fp(res);
1217   }
1218   push(type, res);
1219 }
1220 
1221 
1222 void GraphBuilder::negate_op(ValueType* type) {
1223   push(type, append(new NegateOp(pop(type))));
1224 }
1225 
1226 
1227 void GraphBuilder::shift_op(ValueType* type, Bytecodes::Code code) {
1228   Value s = ipop();
1229   Value x = pop(type);
1230   // try to simplify
1231   // Note: This code should go into the canonicalizer as soon as it can
1232   //       can handle canonicalized forms that contain more than one node.
1233   if (CanonicalizeNodes &amp;&amp; code == Bytecodes::_iushr) {
1234     // pattern: x &gt;&gt;&gt; s
1235     IntConstant* s1 = s-&gt;type()-&gt;as_IntConstant();
1236     if (s1 != NULL) {
1237       // pattern: x &gt;&gt;&gt; s1, with s1 constant
1238       ShiftOp* l = x-&gt;as_ShiftOp();
1239       if (l != NULL &amp;&amp; l-&gt;op() == Bytecodes::_ishl) {
1240         // pattern: (a &lt;&lt; b) &gt;&gt;&gt; s1
1241         IntConstant* s0 = l-&gt;y()-&gt;type()-&gt;as_IntConstant();
1242         if (s0 != NULL) {
1243           // pattern: (a &lt;&lt; s0) &gt;&gt;&gt; s1
1244           const int s0c = s0-&gt;value() &amp; 0x1F; // only the low 5 bits are significant for shifts
1245           const int s1c = s1-&gt;value() &amp; 0x1F; // only the low 5 bits are significant for shifts
1246           if (s0c == s1c) {
1247             if (s0c == 0) {
1248               // pattern: (a &lt;&lt; 0) &gt;&gt;&gt; 0 =&gt; simplify to: a
1249               ipush(l-&gt;x());
1250             } else {
1251               // pattern: (a &lt;&lt; s0c) &gt;&gt;&gt; s0c =&gt; simplify to: a &amp; m, with m constant
1252               assert(0 &lt; s0c &amp;&amp; s0c &lt; BitsPerInt, &quot;adjust code below to handle corner cases&quot;);
1253               const int m = (1 &lt;&lt; (BitsPerInt - s0c)) - 1;
1254               Value s = append(new Constant(new IntConstant(m)));
1255               ipush(append(new LogicOp(Bytecodes::_iand, l-&gt;x(), s)));
1256             }
1257             return;
1258           }
1259         }
1260       }
1261     }
1262   }
1263   // could not simplify
1264   push(type, append(new ShiftOp(code, x, s)));
1265 }
1266 
1267 
1268 void GraphBuilder::logic_op(ValueType* type, Bytecodes::Code code) {
1269   Value y = pop(type);
1270   Value x = pop(type);
1271   push(type, append(new LogicOp(code, x, y)));
1272 }
1273 
1274 
1275 void GraphBuilder::compare_op(ValueType* type, Bytecodes::Code code) {
1276   ValueStack* state_before = copy_state_before();
1277   Value y = pop(type);
1278   Value x = pop(type);
1279   ipush(append(new CompareOp(code, x, y, state_before)));
1280 }
1281 
1282 
1283 void GraphBuilder::convert(Bytecodes::Code op, BasicType from, BasicType to) {
1284   push(as_ValueType(to), append(new Convert(op, pop(as_ValueType(from)), as_ValueType(to))));
1285 }
1286 
1287 
1288 void GraphBuilder::increment() {
1289   int index = stream()-&gt;get_index();
1290   int delta = stream()-&gt;is_wide() ? (signed short)Bytes::get_Java_u2(stream()-&gt;cur_bcp() + 4) : (signed char)(stream()-&gt;cur_bcp()[2]);
1291   load_local(intType, index);
1292   ipush(append(new Constant(new IntConstant(delta))));
1293   arithmetic_op(intType, Bytecodes::_iadd);
1294   store_local(intType, index);
1295 }
1296 
1297 
1298 void GraphBuilder::_goto(int from_bci, int to_bci) {
1299   Goto *x = new Goto(block_at(to_bci), to_bci &lt;= from_bci);
1300   if (is_profiling()) {
1301     compilation()-&gt;set_would_profile(true);
1302     x-&gt;set_profiled_bci(bci());
1303     if (profile_branches()) {
1304       x-&gt;set_profiled_method(method());
1305       x-&gt;set_should_profile(true);
1306     }
1307   }
1308   append(x);
1309 }
1310 
1311 
1312 void GraphBuilder::if_node(Value x, If::Condition cond, Value y, ValueStack* state_before) {
1313   BlockBegin* tsux = block_at(stream()-&gt;get_dest());
1314   BlockBegin* fsux = block_at(stream()-&gt;next_bci());
1315   bool is_bb = tsux-&gt;bci() &lt; stream()-&gt;cur_bci() || fsux-&gt;bci() &lt; stream()-&gt;cur_bci();
1316 
1317   bool subst_check = false;
1318   if (EnableValhalla &amp;&amp; (stream()-&gt;cur_bc() == Bytecodes::_if_acmpeq || stream()-&gt;cur_bc() == Bytecodes::_if_acmpne)) {
1319     ValueType* left_vt = x-&gt;type();
1320     ValueType* right_vt = y-&gt;type();
1321     if (left_vt-&gt;is_object()) {
1322       assert(right_vt-&gt;is_object(), &quot;must be&quot;);
1323       ciKlass* left_klass = x-&gt;as_loaded_klass_or_null();
1324       ciKlass* right_klass = y-&gt;as_loaded_klass_or_null();
1325 
1326       if (left_klass == NULL || right_klass == NULL) {
1327         // The klass is still unloaded, or came from a Phi node. Go slow case;
1328         subst_check = true;
1329       } else if (left_klass-&gt;can_be_inline_klass() || right_klass-&gt;can_be_inline_klass()) {
1330         // Either operand may be a value object, but we&#39;re not sure. Go slow case;
1331         subst_check = true;
1332       } else {
1333         // No need to do substitutability check
1334       }
1335     }
1336   }
1337 
1338   // In case of loop invariant code motion or predicate insertion
1339   // before the body of a loop the state is needed
1340   Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()-&gt;is_optimistic() || subst_check) ? state_before : NULL, is_bb, subst_check));
1341 
1342   assert(i-&gt;as_Goto() == NULL ||
1343          (i-&gt;as_Goto()-&gt;sux_at(0) == tsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == tsux-&gt;bci() &lt; stream()-&gt;cur_bci()) ||
1344          (i-&gt;as_Goto()-&gt;sux_at(0) == fsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == fsux-&gt;bci() &lt; stream()-&gt;cur_bci()),
1345          &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1346 
1347   if (is_profiling()) {
1348     If* if_node = i-&gt;as_If();
1349     if (if_node != NULL) {
1350       // Note that we&#39;d collect profile data in this method if we wanted it.
1351       compilation()-&gt;set_would_profile(true);
1352       // At level 2 we need the proper bci to count backedges
1353       if_node-&gt;set_profiled_bci(bci());
1354       if (profile_branches()) {
1355         // Successors can be rotated by the canonicalizer, check for this case.
1356         if_node-&gt;set_profiled_method(method());
1357         if_node-&gt;set_should_profile(true);
1358         if (if_node-&gt;tsux() == fsux) {
1359           if_node-&gt;set_swapped(true);
1360         }
1361       }
1362       return;
1363     }
1364 
1365     // Check if this If was reduced to Goto.
1366     Goto *goto_node = i-&gt;as_Goto();
1367     if (goto_node != NULL) {
1368       compilation()-&gt;set_would_profile(true);
1369       goto_node-&gt;set_profiled_bci(bci());
1370       if (profile_branches()) {
1371         goto_node-&gt;set_profiled_method(method());
1372         goto_node-&gt;set_should_profile(true);
1373         // Find out which successor is used.
1374         if (goto_node-&gt;default_sux() == tsux) {
1375           goto_node-&gt;set_direction(Goto::taken);
1376         } else if (goto_node-&gt;default_sux() == fsux) {
1377           goto_node-&gt;set_direction(Goto::not_taken);
1378         } else {
1379           ShouldNotReachHere();
1380         }
1381       }
1382       return;
1383     }
1384   }
1385 }
1386 
1387 
1388 void GraphBuilder::if_zero(ValueType* type, If::Condition cond) {
1389   Value y = append(new Constant(intZero));
1390   ValueStack* state_before = copy_state_before();
1391   Value x = ipop();
1392   if_node(x, cond, y, state_before);
1393 }
1394 
1395 
1396 void GraphBuilder::if_null(ValueType* type, If::Condition cond) {
1397   Value y = append(new Constant(objectNull));
1398   ValueStack* state_before = copy_state_before();
1399   Value x = apop();
1400   if_node(x, cond, y, state_before);
1401 }
1402 
1403 
1404 void GraphBuilder::if_same(ValueType* type, If::Condition cond) {
1405   ValueStack* state_before = copy_state_before();
1406   Value y = pop(type);
1407   Value x = pop(type);
1408   if_node(x, cond, y, state_before);
1409 }
1410 
1411 
1412 void GraphBuilder::jsr(int dest) {
1413   // We only handle well-formed jsrs (those which are &quot;block-structured&quot;).
1414   // If the bytecodes are strange (jumping out of a jsr block) then we
1415   // might end up trying to re-parse a block containing a jsr which
1416   // has already been activated. Watch for this case and bail out.
1417   for (ScopeData* cur_scope_data = scope_data();
1418        cur_scope_data != NULL &amp;&amp; cur_scope_data-&gt;parsing_jsr() &amp;&amp; cur_scope_data-&gt;scope() == scope();
1419        cur_scope_data = cur_scope_data-&gt;parent()) {
1420     if (cur_scope_data-&gt;jsr_entry_bci() == dest) {
1421       BAILOUT(&quot;too-complicated jsr/ret structure&quot;);
1422     }
1423   }
1424 
1425   push(addressType, append(new Constant(new AddressConstant(next_bci()))));
1426   if (!try_inline_jsr(dest)) {
1427     return; // bailed out while parsing and inlining subroutine
1428   }
1429 }
1430 
1431 
1432 void GraphBuilder::ret(int local_index) {
1433   if (!parsing_jsr()) BAILOUT(&quot;ret encountered while not parsing subroutine&quot;);
1434 
1435   if (local_index != scope_data()-&gt;jsr_return_address_local()) {
1436     BAILOUT(&quot;can not handle complicated jsr/ret constructs&quot;);
1437   }
1438 
1439   // Rets simply become (NON-SAFEPOINT) gotos to the jsr continuation
1440   append(new Goto(scope_data()-&gt;jsr_continuation(), false));
1441 }
1442 
1443 
1444 void GraphBuilder::table_switch() {
1445   Bytecode_tableswitch sw(stream());
1446   const int l = sw.length();
1447   if (CanonicalizeNodes &amp;&amp; l == 1 &amp;&amp; compilation()-&gt;env()-&gt;comp_level() != CompLevel_full_profile) {
1448     // total of 2 successors =&gt; use If instead of switch
1449     // Note: This code should go into the canonicalizer as soon as it can
1450     //       can handle canonicalized forms that contain more than one node.
1451     Value key = append(new Constant(new IntConstant(sw.low_key())));
1452     BlockBegin* tsux = block_at(bci() + sw.dest_offset_at(0));
1453     BlockBegin* fsux = block_at(bci() + sw.default_offset());
1454     bool is_bb = tsux-&gt;bci() &lt; bci() || fsux-&gt;bci() &lt; bci();
1455     // In case of loop invariant code motion or predicate insertion
1456     // before the body of a loop the state is needed
1457     ValueStack* state_before = copy_state_if_bb(is_bb);
1458     append(new If(ipop(), If::eql, true, key, tsux, fsux, state_before, is_bb));
1459   } else {
1460     // collect successors
1461     BlockList* sux = new BlockList(l + 1, NULL);
1462     int i;
1463     bool has_bb = false;
1464     for (i = 0; i &lt; l; i++) {
1465       sux-&gt;at_put(i, block_at(bci() + sw.dest_offset_at(i)));
1466       if (sw.dest_offset_at(i) &lt; 0) has_bb = true;
1467     }
1468     // add default successor
1469     if (sw.default_offset() &lt; 0) has_bb = true;
1470     sux-&gt;at_put(i, block_at(bci() + sw.default_offset()));
1471     // In case of loop invariant code motion or predicate insertion
1472     // before the body of a loop the state is needed
1473     ValueStack* state_before = copy_state_if_bb(has_bb);
1474     Instruction* res = append(new TableSwitch(ipop(), sux, sw.low_key(), state_before, has_bb));
1475 #ifdef ASSERT
1476     if (res-&gt;as_Goto()) {
1477       for (i = 0; i &lt; l; i++) {
1478         if (sux-&gt;at(i) == res-&gt;as_Goto()-&gt;sux_at(0)) {
1479           assert(res-&gt;as_Goto()-&gt;is_safepoint() == sw.dest_offset_at(i) &lt; 0, &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1480         }
1481       }
1482     }
1483 #endif
1484   }
1485 }
1486 
1487 
1488 void GraphBuilder::lookup_switch() {
1489   Bytecode_lookupswitch sw(stream());
1490   const int l = sw.number_of_pairs();
1491   if (CanonicalizeNodes &amp;&amp; l == 1 &amp;&amp; compilation()-&gt;env()-&gt;comp_level() != CompLevel_full_profile) {
1492     // total of 2 successors =&gt; use If instead of switch
1493     // Note: This code should go into the canonicalizer as soon as it can
1494     //       can handle canonicalized forms that contain more than one node.
1495     // simplify to If
1496     LookupswitchPair pair = sw.pair_at(0);
1497     Value key = append(new Constant(new IntConstant(pair.match())));
1498     BlockBegin* tsux = block_at(bci() + pair.offset());
1499     BlockBegin* fsux = block_at(bci() + sw.default_offset());
1500     bool is_bb = tsux-&gt;bci() &lt; bci() || fsux-&gt;bci() &lt; bci();
1501     // In case of loop invariant code motion or predicate insertion
1502     // before the body of a loop the state is needed
1503     ValueStack* state_before = copy_state_if_bb(is_bb);;
1504     append(new If(ipop(), If::eql, true, key, tsux, fsux, state_before, is_bb));
1505   } else {
1506     // collect successors &amp; keys
1507     BlockList* sux = new BlockList(l + 1, NULL);
1508     intArray* keys = new intArray(l, l, 0);
1509     int i;
1510     bool has_bb = false;
1511     for (i = 0; i &lt; l; i++) {
1512       LookupswitchPair pair = sw.pair_at(i);
1513       if (pair.offset() &lt; 0) has_bb = true;
1514       sux-&gt;at_put(i, block_at(bci() + pair.offset()));
1515       keys-&gt;at_put(i, pair.match());
1516     }
1517     // add default successor
1518     if (sw.default_offset() &lt; 0) has_bb = true;
1519     sux-&gt;at_put(i, block_at(bci() + sw.default_offset()));
1520     // In case of loop invariant code motion or predicate insertion
1521     // before the body of a loop the state is needed
1522     ValueStack* state_before = copy_state_if_bb(has_bb);
1523     Instruction* res = append(new LookupSwitch(ipop(), sux, keys, state_before, has_bb));
1524 #ifdef ASSERT
1525     if (res-&gt;as_Goto()) {
1526       for (i = 0; i &lt; l; i++) {
1527         if (sux-&gt;at(i) == res-&gt;as_Goto()-&gt;sux_at(0)) {
1528           assert(res-&gt;as_Goto()-&gt;is_safepoint() == sw.pair_at(i).offset() &lt; 0, &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1529         }
1530       }
1531     }
1532 #endif
1533   }
1534 }
1535 
1536 void GraphBuilder::call_register_finalizer() {
1537   // If the receiver requires finalization then emit code to perform
1538   // the registration on return.
1539 
1540   // Gather some type information about the receiver
1541   Value receiver = state()-&gt;local_at(0);
1542   assert(receiver != NULL, &quot;must have a receiver&quot;);
1543   ciType* declared_type = receiver-&gt;declared_type();
1544   ciType* exact_type = receiver-&gt;exact_type();
1545   if (exact_type == NULL &amp;&amp;
1546       receiver-&gt;as_Local() &amp;&amp;
1547       receiver-&gt;as_Local()-&gt;java_index() == 0) {
1548     ciInstanceKlass* ik = compilation()-&gt;method()-&gt;holder();
1549     if (ik-&gt;is_final()) {
1550       exact_type = ik;
1551     } else if (UseCHA &amp;&amp; !(ik-&gt;has_subklass() || ik-&gt;is_interface())) {
1552       // test class is leaf class
1553       compilation()-&gt;dependency_recorder()-&gt;assert_leaf_type(ik);
1554       exact_type = ik;
1555     } else {
1556       declared_type = ik;
1557     }
1558   }
1559 
1560   // see if we know statically that registration isn&#39;t required
1561   bool needs_check = true;
1562   if (exact_type != NULL) {
1563     needs_check = exact_type-&gt;as_instance_klass()-&gt;has_finalizer();
1564   } else if (declared_type != NULL) {
1565     ciInstanceKlass* ik = declared_type-&gt;as_instance_klass();
1566     if (!Dependencies::has_finalizable_subclass(ik)) {
1567       compilation()-&gt;dependency_recorder()-&gt;assert_has_no_finalizable_subclasses(ik);
1568       needs_check = false;
1569     }
1570   }
1571 
1572   if (needs_check) {
1573     // Perform the registration of finalizable objects.
1574     ValueStack* state_before = copy_state_for_exception();
1575     load_local(objectType, 0);
1576     append_split(new Intrinsic(voidType, vmIntrinsics::_Object_init,
1577                                state()-&gt;pop_arguments(1),
1578                                true, state_before, true));
1579   }
1580 }
1581 
1582 
1583 void GraphBuilder::method_return(Value x, bool ignore_return) {
1584   if (RegisterFinalizersAtInit &amp;&amp;
1585       method()-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
1586     call_register_finalizer();
1587   }
1588 
1589   // The conditions for a memory barrier are described in Parse::do_exits().
1590   bool need_mem_bar = false;
1591   if (method()-&gt;is_object_constructor() &amp;&amp;
1592        (scope()-&gt;wrote_final() ||
1593          (AlwaysSafeConstructors &amp;&amp; scope()-&gt;wrote_fields()) ||
1594          (support_IRIW_for_not_multiple_copy_atomic_cpu &amp;&amp; scope()-&gt;wrote_volatile()))) {
1595     need_mem_bar = true;
1596   }
1597 
1598   BasicType bt = method()-&gt;return_type()-&gt;basic_type();
1599   switch (bt) {
1600     case T_BYTE:
1601     {
1602       Value shift = append(new Constant(new IntConstant(24)));
1603       x = append(new ShiftOp(Bytecodes::_ishl, x, shift));
1604       x = append(new ShiftOp(Bytecodes::_ishr, x, shift));
1605       break;
1606     }
1607     case T_SHORT:
1608     {
1609       Value shift = append(new Constant(new IntConstant(16)));
1610       x = append(new ShiftOp(Bytecodes::_ishl, x, shift));
1611       x = append(new ShiftOp(Bytecodes::_ishr, x, shift));
1612       break;
1613     }
1614     case T_CHAR:
1615     {
1616       Value mask = append(new Constant(new IntConstant(0xFFFF)));
1617       x = append(new LogicOp(Bytecodes::_iand, x, mask));
1618       break;
1619     }
1620     case T_BOOLEAN:
1621     {
1622       Value mask = append(new Constant(new IntConstant(1)));
1623       x = append(new LogicOp(Bytecodes::_iand, x, mask));
1624       break;
1625     }
1626     default:
1627       break;
1628   }
1629 
1630   // Check to see whether we are inlining. If so, Return
1631   // instructions become Gotos to the continuation point.
1632   if (continuation() != NULL) {
1633 
1634     int invoke_bci = state()-&gt;caller_state()-&gt;bci();
1635 
1636     if (x != NULL  &amp;&amp; !ignore_return) {
1637       ciMethod* caller = state()-&gt;scope()-&gt;caller()-&gt;method();
1638       Bytecodes::Code invoke_raw_bc = caller-&gt;raw_code_at_bci(invoke_bci);
1639       if (invoke_raw_bc == Bytecodes::_invokehandle || invoke_raw_bc == Bytecodes::_invokedynamic) {
1640         ciType* declared_ret_type = caller-&gt;get_declared_signature_at_bci(invoke_bci)-&gt;return_type();
1641         if (declared_ret_type-&gt;is_klass() &amp;&amp; x-&gt;exact_type() == NULL &amp;&amp;
1642             x-&gt;declared_type() != declared_ret_type &amp;&amp; declared_ret_type != compilation()-&gt;env()-&gt;Object_klass()) {
1643           x = append(new TypeCast(declared_ret_type-&gt;as_klass(), x, copy_state_before()));
1644         }
1645       }
1646     }
1647 
1648     assert(!method()-&gt;is_synchronized() || InlineSynchronizedMethods, &quot;can not inline synchronized methods yet&quot;);
1649 
1650     if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
1651       // Report exit from inline methods
1652       Values* args = new Values(1);
1653       args-&gt;push(append(new Constant(new MethodConstant(method()))));
1654       append(new RuntimeCall(voidType, &quot;dtrace_method_exit&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), args));
1655     }
1656 
1657     // If the inlined method is synchronized, the monitor must be
1658     // released before we jump to the continuation block.
1659     if (method()-&gt;is_synchronized()) {
1660       assert(state()-&gt;locks_size() == 1, &quot;receiver must be locked here&quot;);
1661       monitorexit(state()-&gt;lock_at(0), SynchronizationEntryBCI);
1662     }
1663 
1664     if (need_mem_bar) {
1665       append(new MemBar(lir_membar_storestore));
1666     }
1667 
1668     // State at end of inlined method is the state of the caller
1669     // without the method parameters on stack, including the
1670     // return value, if any, of the inlined method on operand stack.
1671     set_state(state()-&gt;caller_state()-&gt;copy_for_parsing());
1672     if (x != NULL) {
1673       if (!ignore_return) {
1674         state()-&gt;push(x-&gt;type(), x);
1675       }
1676       if (profile_return() &amp;&amp; x-&gt;type()-&gt;is_object_kind()) {
1677         ciMethod* caller = state()-&gt;scope()-&gt;method();
1678         profile_return_type(x, method(), caller, invoke_bci);
1679       }
1680     }
1681     Goto* goto_callee = new Goto(continuation(), false);
1682 
1683     // See whether this is the first return; if so, store off some
1684     // of the state for later examination
1685     if (num_returns() == 0) {
1686       set_inline_cleanup_info();
1687     }
1688 
1689     // The current bci() is in the wrong scope, so use the bci() of
1690     // the continuation point.
1691     append_with_bci(goto_callee, scope_data()-&gt;continuation()-&gt;bci());
1692     incr_num_returns();
1693     return;
1694   }
1695 
1696   state()-&gt;truncate_stack(0);
1697   if (method()-&gt;is_synchronized()) {
1698     // perform the unlocking before exiting the method
1699     Value receiver;
1700     if (!method()-&gt;is_static()) {
1701       receiver = _initial_state-&gt;local_at(0);
1702     } else {
1703       receiver = append(new Constant(new ClassConstant(method()-&gt;holder())));
1704     }
1705     append_split(new MonitorExit(receiver, state()-&gt;unlock()));
1706   }
1707 
1708   if (need_mem_bar) {
1709       append(new MemBar(lir_membar_storestore));
1710   }
1711 
1712   assert(!ignore_return, &quot;Ignoring return value works only for inlining&quot;);
1713   append(new Return(x));
1714 }
1715 
1716 Value GraphBuilder::make_constant(ciConstant field_value, ciField* field) {
1717   if (!field_value.is_valid())  return NULL;
1718 
1719   BasicType field_type = field_value.basic_type();
1720   ValueType* value = as_ValueType(field_value);
1721 
1722   // Attach dimension info to stable arrays.
1723   if (FoldStableValues &amp;&amp;
1724       field-&gt;is_stable() &amp;&amp; field_type == T_ARRAY &amp;&amp; !field_value.is_null_or_zero()) {
1725     ciArray* array = field_value.as_object()-&gt;as_array();
1726     jint dimension = field-&gt;type()-&gt;as_array_klass()-&gt;dimension();
1727     value = new StableArrayConstant(array, dimension);
1728   }
1729 
1730   switch (field_type) {
1731     case T_ARRAY:
1732     case T_OBJECT:
1733       if (field_value.as_object()-&gt;should_be_constant()) {
1734         return new Constant(value);
1735       }
1736       return NULL; // Not a constant.
1737     default:
1738       return new Constant(value);
1739   }
1740 }
1741 
1742 void GraphBuilder::copy_inline_content(ciInlineKlass* vk, Value src, int src_off, Value dest, int dest_off,
1743                                        ValueStack* state_before, bool needs_patching) {
1744   src-&gt;set_escaped();
1745   for (int i = 0; i &lt; vk-&gt;nof_nonstatic_fields(); i++) {
1746     ciField* inner_field = vk-&gt;nonstatic_field_at(i);
1747     assert(!inner_field-&gt;is_flattened(), &quot;the iteration over nested fields is handled by the loop itself&quot;);
1748     int off = inner_field-&gt;offset() - vk-&gt;first_field_offset();
1749     LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, needs_patching);
1750     Value replacement = append(load);
1751     StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, needs_patching);
1752     append(store);
1753   }
1754 }
1755 
1756 void GraphBuilder::access_field(Bytecodes::Code code) {
1757   bool will_link;
1758   ciField* field = stream()-&gt;get_field(will_link);
1759   ciInstanceKlass* holder = field-&gt;holder();
1760   BasicType field_type = field-&gt;type()-&gt;basic_type();
1761   ValueType* type = as_ValueType(field_type);
1762 
1763   // call will_link again to determine if the field is valid.
1764   const bool needs_patching = !holder-&gt;is_loaded() ||
1765                               !field-&gt;will_link(method(), code) ||
1766                               PatchALot;
1767 
1768   ValueStack* state_before = NULL;
1769   if (!holder-&gt;is_initialized() || needs_patching) {
1770     // save state before instruction for debug info when
1771     // deoptimization happens during patching
1772     state_before = copy_state_before();
1773   }
1774 
1775   Value obj = NULL;
1776   if (code == Bytecodes::_getstatic || code == Bytecodes::_putstatic) {
1777     if (state_before != NULL) {
1778       // build a patching constant
1779       obj = new Constant(new InstanceConstant(holder-&gt;java_mirror()), state_before);
1780     } else {
1781       obj = new Constant(new InstanceConstant(holder-&gt;java_mirror()));
1782     }
1783   }
1784 
1785   if (field-&gt;is_final() &amp;&amp; (code == Bytecodes::_putfield || code == Bytecodes::_withfield)) {
1786     scope()-&gt;set_wrote_final();
1787   }
1788 
1789   if (code == Bytecodes::_putfield || code == Bytecodes::_withfield) {
1790     scope()-&gt;set_wrote_fields();
1791     if (field-&gt;is_volatile()) {
1792       scope()-&gt;set_wrote_volatile();
1793     }
1794   }
1795 
1796   const int offset = !needs_patching ? field-&gt;offset() : -1;
1797   switch (code) {
1798     case Bytecodes::_getstatic: {
1799       // check for compile-time constants, i.e., initialized static final fields
1800       Value constant = NULL;
1801       if (field-&gt;is_static_constant() &amp;&amp; !PatchALot) {
1802         ciConstant field_value = field-&gt;constant_value();
1803         assert(!field-&gt;is_stable() || !field_value.is_null_or_zero(),
1804                &quot;stable static w/ default value shouldn&#39;t be a constant&quot;);
1805         constant = make_constant(field_value, field);
1806       }
1807       if (constant != NULL) {
1808         push(type, append(constant));
1809       } else {
1810         if (state_before == NULL) {
1811           state_before = copy_state_for_exception();
1812         }
1813         LoadField* load_field = new LoadField(append(obj), offset, field, true,
1814                                         state_before, needs_patching);
1815         push(type, append(load_field));
1816       }
1817       break;
1818     }
1819     case Bytecodes::_putstatic: {
1820       Value val = pop(type);
1821       val-&gt;set_escaped();
1822       if (state_before == NULL) {
1823         state_before = copy_state_for_exception();
1824       }
1825       if (field_type == T_BOOLEAN) {
1826         Value mask = append(new Constant(new IntConstant(1)));
1827         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1828       }
1829       append(new StoreField(append(obj), offset, field, val, true, state_before, needs_patching));
1830       break;
1831     }
1832     case Bytecodes::_getfield: {
1833       // Check for compile-time constants, i.e., trusted final non-static fields.
1834       Value constant = NULL;
1835       if (state_before == NULL &amp;&amp; field-&gt;is_flattened()) {
1836         // Save the entire state and re-execute on deopt when accessing flattened fields
1837         assert(Interpreter::bytecode_should_reexecute(code), &quot;should reexecute&quot;);
1838         state_before = copy_state_before();
1839       }
<a name="1" id="anc1"></a><span class="line-modified">1840       if (!has_delayed_flattened_field_access()) {</span>
<span class="line-modified">1841         obj = apop();</span>
<span class="line-modified">1842         ObjectType* obj_type = obj-&gt;type()-&gt;as_ObjectType();</span>
<span class="line-modified">1843         if (field-&gt;is_constant() &amp;&amp; !field-&gt;is_flattened() &amp;&amp; obj_type-&gt;is_constant() &amp;&amp; !PatchALot) {</span>
<span class="line-modified">1844           ciObject* const_oop = obj_type-&gt;constant_value();</span>
<span class="line-modified">1845           if (!const_oop-&gt;is_null_object() &amp;&amp; const_oop-&gt;is_loaded()) {</span>
<span class="line-modified">1846             ciConstant field_value = field-&gt;constant_value_of(const_oop);</span>
<span class="line-modified">1847             if (field_value.is_valid()) {</span>
<span class="line-modified">1848               if (field-&gt;signature()-&gt;is_Q_signature() &amp;&amp; field_value.is_null_or_zero()) {</span>
<span class="line-modified">1849                 // Non-flattened inline type field. Replace null by the default value.</span>
<span class="line-modified">1850                 constant = new Constant(new InstanceConstant(field-&gt;type()-&gt;as_inline_klass()-&gt;default_instance()));</span>
<span class="line-modified">1851               } else {</span>
<span class="line-modified">1852                 constant = make_constant(field_value, field);</span>
<span class="line-modified">1853               }</span>
<span class="line-modified">1854               // For CallSite objects add a dependency for invalidation of the optimization.</span>
<span class="line-modified">1855               if (field-&gt;is_call_site_target()) {</span>
<span class="line-modified">1856                 ciCallSite* call_site = const_oop-&gt;as_call_site();</span>
<span class="line-modified">1857                 if (!call_site-&gt;is_fully_initialized_constant_call_site()) {</span>
<span class="line-modified">1858                   ciMethodHandle* target = field_value.as_object()-&gt;as_method_handle();</span>
<span class="line-added">1859                   dependency_recorder()-&gt;assert_call_site_target_value(call_site, target);</span>
<span class="line-added">1860                 }</span>
1861               }
1862             }
1863           }
1864         }
1865       }
1866       if (constant != NULL) {
1867         push(type, append(constant));
1868       } else {
1869         if (state_before == NULL) {
1870           state_before = copy_state_for_exception();
1871         }
1872         if (!field-&gt;is_flattened()) {
<a name="2" id="anc2"></a><span class="line-modified">1873           LoadField* load;</span>
<span class="line-added">1874           if (!has_delayed_flattened_field_access()) {</span>
<span class="line-added">1875             load = new LoadField(obj, offset, field, false, state_before, needs_patching);</span>
<span class="line-added">1876           } else {</span>
<span class="line-added">1877             load = new LoadField(_delayed_flattened_field_access-&gt;obj(),</span>
<span class="line-added">1878                                  _delayed_flattened_field_access-&gt;offset() + offset - field-&gt;holder()-&gt;as_inline_klass()-&gt;first_field_offset(),</span>
<span class="line-added">1879                                  field, false, state_before, needs_patching);</span>
<span class="line-added">1880             _delayed_flattened_field_access = NULL;</span>
<span class="line-added">1881           }</span>
1882           Value replacement = !needs_patching ? _memory-&gt;load(load) : load;
1883           if (replacement != load) {
1884             assert(replacement-&gt;is_linked() || !replacement-&gt;can_be_linked(), &quot;should already by linked&quot;);
1885             // Writing an (integer) value to a boolean, byte, char or short field includes an implicit narrowing
1886             // conversion. Emit an explicit conversion here to get the correct field value after the write.
1887             BasicType bt = field-&gt;type()-&gt;basic_type();
1888             switch (bt) {
1889             case T_BOOLEAN:
1890             case T_BYTE:
1891               replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));
1892               break;
1893             case T_CHAR:
1894               replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));
1895               break;
1896             case T_SHORT:
1897               replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));
1898               break;
1899             default:
1900               break;
1901             }
1902             push(type, replacement);
1903           } else {
1904             push(type, append(load));
1905           }
<a name="3" id="anc3"></a><span class="line-modified">1906         } else {</span>
<span class="line-modified">1907           ciBytecodeStream s(method());</span>
<span class="line-modified">1908           s.force_bci(bci());</span>
<span class="line-modified">1909           s.next();</span>
<span class="line-modified">1910           if (s.cur_bc() == Bytecodes::_getfield &amp;&amp; !needs_patching) {</span>
<span class="line-modified">1911             if (!has_delayed_flattened_field_access()) {</span>
<span class="line-modified">1912               null_check(obj);</span>
<span class="line-modified">1913               DelayedFlattenedFieldAccess* dffa = new DelayedFlattenedFieldAccess(obj, field, field-&gt;offset());</span>
<span class="line-modified">1914               _delayed_flattened_field_access = dffa;</span>
<span class="line-modified">1915             } else {</span>
<span class="line-modified">1916               _delayed_flattened_field_access-&gt;update(field, offset - field-&gt;holder()-&gt;as_inline_klass()-&gt;first_field_offset());</span>
<span class="line-modified">1917             }</span>
<span class="line-added">1918           } else {</span>
<span class="line-added">1919             assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Sanity check&quot;);</span>
<span class="line-added">1920             ciInlineKlass* inline_klass = field-&gt;type()-&gt;as_inline_klass();</span>
<span class="line-added">1921             assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Sanity check&quot;);</span>
<span class="line-added">1922             scope()-&gt;set_wrote_final();</span>
<span class="line-added">1923             scope()-&gt;set_wrote_fields();</span>
<span class="line-added">1924             NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(inline_klass, state_before, false);</span>
<span class="line-added">1925             _memory-&gt;new_instance(new_instance);</span>
<span class="line-added">1926             apush(append_split(new_instance));</span>
<span class="line-added">1927             if (!has_delayed_flattened_field_access()) {</span>
<span class="line-added">1928               copy_inline_content(inline_klass, obj, field-&gt;offset(), new_instance, inline_klass-&gt;first_field_offset(),</span>
<span class="line-added">1929                           state_before, needs_patching);</span>
<span class="line-added">1930             } else {</span>
<span class="line-added">1931               copy_inline_content(inline_klass, _delayed_flattened_field_access-&gt;obj(),</span>
<span class="line-added">1932                                   _delayed_flattened_field_access-&gt;offset() + field-&gt;offset() - field-&gt;holder()-&gt;as_inline_klass()-&gt;first_field_offset(),</span>
<span class="line-added">1933                                   new_instance, inline_klass-&gt;first_field_offset(),</span>
<span class="line-added">1934                                   state_before, needs_patching);</span>
<span class="line-added">1935               _delayed_flattened_field_access = NULL;</span>
<span class="line-added">1936             }</span>
<span class="line-added">1937           }</span>
1938         }
1939       }
1940       break;
1941     }
1942     case Bytecodes::_withfield:
1943     case Bytecodes::_putfield: {
1944       Value val = pop(type);
1945       val-&gt;set_escaped();
1946       obj = apop();
1947       if (state_before == NULL) {
1948         state_before = copy_state_for_exception();
1949       }
1950       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1951         Value mask = append(new Constant(new IntConstant(1)));
1952         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1953       }
1954 
1955       if (!field-&gt;is_flattened()) {
1956         StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);
1957         if (!needs_patching) store = _memory-&gt;store(store);
1958         if (store != NULL) {
1959           append(store);
1960         }
1961       } else {
1962         assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Sanity check&quot;);
1963         ciInlineKlass* inline_klass = field-&gt;type()-&gt;as_inline_klass();
1964         int flattening_offset = field-&gt;offset() - inline_klass-&gt;first_field_offset();
1965         copy_inline_content(inline_klass, val, inline_klass-&gt;first_field_offset(), obj, field-&gt;offset(),
1966                    state_before, needs_patching);
1967       }
1968       break;
1969     }
1970     default:
1971       ShouldNotReachHere();
1972       break;
1973   }
1974 }
1975 
1976 // Baseline version of withfield, allocate every time
1977 void GraphBuilder::withfield(int field_index)
1978 {
1979   bool will_link;
1980   ciField* field_modify = stream()-&gt;get_field(will_link);
1981   ciInstanceKlass* holder = field_modify-&gt;holder();
1982   BasicType field_type = field_modify-&gt;type()-&gt;basic_type();
1983   ValueType* type = as_ValueType(field_type);
1984 
1985   // call will_link again to determine if the field is valid.
1986   const bool needs_patching = !holder-&gt;is_loaded() ||
1987                               !field_modify-&gt;will_link(method(), Bytecodes::_withfield) ||
1988                               PatchALot;
1989 
1990 
1991   scope()-&gt;set_wrote_final();
1992   scope()-&gt;set_wrote_fields();
1993 
1994   const int offset = !needs_patching ? field_modify-&gt;offset() : -1;
1995 
1996   if (!holder-&gt;is_loaded()
1997       || needs_patching /* FIXME: 8228634 - field_modify-&gt;will_link() may incorrectly return false */
1998       ) {
1999     ValueStack* state_before = copy_state_before();
2000     Value val = pop(type);
2001     Value obj = apop();
2002     apush(append_split(new WithField(state_before)));
2003     return;
2004   }
2005   ValueStack* state_before = copy_state_before();
2006 
2007   Value val = pop(type);
2008   Value obj = apop();
2009 
2010   assert(holder-&gt;is_inlinetype(), &quot;must be a value klass&quot;);
2011   // Save the entire state and re-execute on deopt when executing withfield
2012   state_before-&gt;set_should_reexecute(true);
2013   NewInlineTypeInstance* new_instance;
2014   if (obj-&gt;as_NewInlineTypeInstance() != NULL &amp;&amp; obj-&gt;as_NewInlineTypeInstance()-&gt;in_larval_state()) {
2015     new_instance = obj-&gt;as_NewInlineTypeInstance();
2016     apush(append_split(new_instance));
2017   } else {
2018     new_instance = new NewInlineTypeInstance(holder-&gt;as_inline_klass(), state_before, false);
2019     _memory-&gt;new_instance(new_instance);
2020     apush(append_split(new_instance));
2021 
2022     for (int i = 0; i &lt; holder-&gt;nof_nonstatic_fields(); i++) {
2023       ciField* field = holder-&gt;nonstatic_field_at(i);
2024       int off = field-&gt;offset();
2025 
2026       if (field-&gt;offset() != offset) {
2027         if (field-&gt;is_flattened()) {
2028           assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Sanity check&quot;);
2029           assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Only inline types can be flattened&quot;);
2030           ciInlineKlass* vk = field-&gt;type()-&gt;as_inline_klass();
2031           copy_inline_content(vk, obj, off, new_instance, vk-&gt;first_field_offset(), state_before, needs_patching);
2032         } else {
2033           // Only load those fields who are not modified
2034           LoadField* load = new LoadField(obj, off, field, false, state_before, needs_patching);
2035           Value replacement = append(load);
2036           StoreField* store = new StoreField(new_instance, off, field, replacement, false, state_before, needs_patching);
2037           append(store);
2038         }
2039       }
2040     }
2041   }
2042 
2043   // Field to modify
2044   if (field_modify-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
2045     Value mask = append(new Constant(new IntConstant(1)));
2046     val = append(new LogicOp(Bytecodes::_iand, val, mask));
2047   }
2048   if (field_modify-&gt;is_flattened()) {
2049     assert(field_modify-&gt;type()-&gt;is_inlinetype(), &quot;Only inline types can be flattened&quot;);
2050     ciInlineKlass* vk = field_modify-&gt;type()-&gt;as_inline_klass();
2051     copy_inline_content(vk, val, vk-&gt;first_field_offset(), new_instance, field_modify-&gt;offset(), state_before, needs_patching);
2052   } else {
2053     StoreField* store = new StoreField(new_instance, offset, field_modify, val, false, state_before, needs_patching);
2054     append(store);
2055   }
2056 }
2057 
2058 Dependencies* GraphBuilder::dependency_recorder() const {
2059   assert(DeoptC1, &quot;need debug information&quot;);
2060   return compilation()-&gt;dependency_recorder();
2061 }
2062 
2063 // How many arguments do we want to profile?
2064 Values* GraphBuilder::args_list_for_profiling(ciMethod* target, int&amp; start, bool may_have_receiver) {
2065   int n = 0;
2066   bool has_receiver = may_have_receiver &amp;&amp; Bytecodes::has_receiver(method()-&gt;java_code_at_bci(bci()));
2067   start = has_receiver ? 1 : 0;
2068   if (profile_arguments()) {
2069     ciProfileData* data = method()-&gt;method_data()-&gt;bci_to_data(bci());
2070     if (data != NULL &amp;&amp; (data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData())) {
2071       n = data-&gt;is_CallTypeData() ? data-&gt;as_CallTypeData()-&gt;number_of_arguments() : data-&gt;as_VirtualCallTypeData()-&gt;number_of_arguments();
2072     }
2073   }
2074   // If we are inlining then we need to collect arguments to profile parameters for the target
2075   if (profile_parameters() &amp;&amp; target != NULL) {
2076     if (target-&gt;method_data() != NULL &amp;&amp; target-&gt;method_data()-&gt;parameters_type_data() != NULL) {
2077       // The receiver is profiled on method entry so it&#39;s included in
2078       // the number of parameters but here we&#39;re only interested in
2079       // actual arguments.
2080       n = MAX2(n, target-&gt;method_data()-&gt;parameters_type_data()-&gt;number_of_parameters() - start);
2081     }
2082   }
2083   if (n &gt; 0) {
2084     return new Values(n);
2085   }
2086   return NULL;
2087 }
2088 
2089 void GraphBuilder::check_args_for_profiling(Values* obj_args, int expected) {
2090 #ifdef ASSERT
2091   bool ignored_will_link;
2092   ciSignature* declared_signature = NULL;
2093   ciMethod* real_target = method()-&gt;get_method_at_bci(bci(), ignored_will_link, &amp;declared_signature);
2094   assert(expected == obj_args-&gt;max_length() || real_target-&gt;is_method_handle_intrinsic(), &quot;missed on arg?&quot;);
2095 #endif
2096 }
2097 
2098 // Collect arguments that we want to profile in a list
2099 Values* GraphBuilder::collect_args_for_profiling(Values* args, ciMethod* target, bool may_have_receiver) {
2100   int start = 0;
2101   Values* obj_args = args_list_for_profiling(target, start, may_have_receiver);
2102   if (obj_args == NULL) {
2103     return NULL;
2104   }
2105   int s = obj_args-&gt;max_length();
2106   // if called through method handle invoke, some arguments may have been popped
2107   for (int i = start, j = 0; j &lt; s &amp;&amp; i &lt; args-&gt;length(); i++) {
2108     if (args-&gt;at(i)-&gt;type()-&gt;is_object_kind()) {
2109       obj_args-&gt;push(args-&gt;at(i));
2110       j++;
2111     }
2112   }
2113   check_args_for_profiling(obj_args, s);
2114   return obj_args;
2115 }
2116 
2117 
2118 void GraphBuilder::invoke(Bytecodes::Code code) {
2119   bool will_link;
2120   ciSignature* declared_signature = NULL;
2121   ciMethod*             target = stream()-&gt;get_method(will_link, &amp;declared_signature);
2122   ciKlass*              holder = stream()-&gt;get_declared_method_holder();
2123   const Bytecodes::Code bc_raw = stream()-&gt;cur_bc_raw();
2124   assert(declared_signature != NULL, &quot;cannot be null&quot;);
2125   assert(will_link == target-&gt;is_loaded(), &quot;&quot;);
2126 
2127   ciInstanceKlass* klass = target-&gt;holder();
2128   assert(!target-&gt;is_loaded() || klass-&gt;is_loaded(), &quot;loaded target must imply loaded klass&quot;);
2129 
2130   // check if CHA possible: if so, change the code to invoke_special
2131   ciInstanceKlass* calling_klass = method()-&gt;holder();
2132   ciInstanceKlass* callee_holder = ciEnv::get_instance_klass_for_declared_method_holder(holder);
2133   ciInstanceKlass* actual_recv = callee_holder;
2134 
2135   CompileLog* log = compilation()-&gt;log();
2136   if (log != NULL)
2137       log-&gt;elem(&quot;call method=&#39;%d&#39; instr=&#39;%s&#39;&quot;,
2138                 log-&gt;identify(target),
2139                 Bytecodes::name(code));
2140 
2141   // invoke-special-super
2142   if (bc_raw == Bytecodes::_invokespecial &amp;&amp; !target-&gt;is_object_constructor()) {
2143     ciInstanceKlass* sender_klass =
2144           calling_klass-&gt;is_unsafe_anonymous() ? calling_klass-&gt;unsafe_anonymous_host() :
2145                                                  calling_klass;
2146     if (sender_klass-&gt;is_interface()) {
2147       int index = state()-&gt;stack_size() - (target-&gt;arg_size_no_receiver() + 1);
2148       Value receiver = state()-&gt;stack_at(index);
2149       CheckCast* c = new CheckCast(sender_klass, receiver, copy_state_before());
2150       c-&gt;set_invokespecial_receiver_check();
2151       state()-&gt;stack_at_put(index, append_split(c));
2152     }
2153   }
2154 
2155   // Some methods are obviously bindable without any type checks so
2156   // convert them directly to an invokespecial or invokestatic.
2157   if (target-&gt;is_loaded() &amp;&amp; !target-&gt;is_abstract() &amp;&amp; target-&gt;can_be_statically_bound()) {
2158     switch (bc_raw) {
2159     case Bytecodes::_invokevirtual:
2160       code = Bytecodes::_invokespecial;
2161       break;
2162     case Bytecodes::_invokehandle:
2163       code = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokespecial;
2164       break;
2165     default:
2166       break;
2167     }
2168   } else {
2169     if (bc_raw == Bytecodes::_invokehandle) {
2170       assert(!will_link, &quot;should come here only for unlinked call&quot;);
2171       code = Bytecodes::_invokespecial;
2172     }
2173   }
2174 
2175   // Push appendix argument (MethodType, CallSite, etc.), if one.
2176   bool patch_for_appendix = false;
2177   int patching_appendix_arg = 0;
2178   if (Bytecodes::has_optional_appendix(bc_raw) &amp;&amp; (!will_link || PatchALot)) {
2179     Value arg = append(new Constant(new ObjectConstant(compilation()-&gt;env()-&gt;unloaded_ciinstance()), copy_state_before()));
2180     apush(arg);
2181     patch_for_appendix = true;
2182     patching_appendix_arg = (will_link &amp;&amp; stream()-&gt;has_appendix()) ? 0 : 1;
2183   } else if (stream()-&gt;has_appendix()) {
2184     ciObject* appendix = stream()-&gt;get_appendix();
2185     Value arg = append(new Constant(new ObjectConstant(appendix)));
2186     apush(arg);
2187   }
2188 
2189   ciMethod* cha_monomorphic_target = NULL;
2190   ciMethod* exact_target = NULL;
2191   Value better_receiver = NULL;
2192   if (UseCHA &amp;&amp; DeoptC1 &amp;&amp; target-&gt;is_loaded() &amp;&amp;
2193       !(// %%% FIXME: Are both of these relevant?
2194         target-&gt;is_method_handle_intrinsic() ||
2195         target-&gt;is_compiled_lambda_form()) &amp;&amp;
2196       !patch_for_appendix) {
2197     Value receiver = NULL;
2198     ciInstanceKlass* receiver_klass = NULL;
2199     bool type_is_exact = false;
2200     // try to find a precise receiver type
2201     if (will_link &amp;&amp; !target-&gt;is_static()) {
2202       int index = state()-&gt;stack_size() - (target-&gt;arg_size_no_receiver() + 1);
2203       receiver = state()-&gt;stack_at(index);
2204       ciType* type = receiver-&gt;exact_type();
2205       if (type != NULL &amp;&amp; type-&gt;is_loaded() &amp;&amp;
2206           type-&gt;is_instance_klass() &amp;&amp; !type-&gt;as_instance_klass()-&gt;is_interface()) {
2207         receiver_klass = (ciInstanceKlass*) type;
2208         type_is_exact = true;
2209       }
2210       if (type == NULL) {
2211         type = receiver-&gt;declared_type();
2212         if (type != NULL &amp;&amp; type-&gt;is_loaded() &amp;&amp;
2213             type-&gt;is_instance_klass() &amp;&amp; !type-&gt;as_instance_klass()-&gt;is_interface()) {
2214           receiver_klass = (ciInstanceKlass*) type;
2215           if (receiver_klass-&gt;is_leaf_type() &amp;&amp; !receiver_klass-&gt;is_final()) {
2216             // Insert a dependency on this type since
2217             // find_monomorphic_target may assume it&#39;s already done.
2218             dependency_recorder()-&gt;assert_leaf_type(receiver_klass);
2219             type_is_exact = true;
2220           }
2221         }
2222       }
2223     }
2224     if (receiver_klass != NULL &amp;&amp; type_is_exact &amp;&amp;
2225         receiver_klass-&gt;is_loaded() &amp;&amp; code != Bytecodes::_invokespecial) {
2226       // If we have the exact receiver type we can bind directly to
2227       // the method to call.
2228       exact_target = target-&gt;resolve_invoke(calling_klass, receiver_klass);
2229       if (exact_target != NULL) {
2230         target = exact_target;
2231         code = Bytecodes::_invokespecial;
2232       }
2233     }
2234     if (receiver_klass != NULL &amp;&amp;
2235         receiver_klass-&gt;is_subtype_of(actual_recv) &amp;&amp;
2236         actual_recv-&gt;is_initialized()) {
2237       actual_recv = receiver_klass;
2238     }
2239 
2240     if ((code == Bytecodes::_invokevirtual &amp;&amp; callee_holder-&gt;is_initialized()) ||
2241         (code == Bytecodes::_invokeinterface &amp;&amp; callee_holder-&gt;is_initialized() &amp;&amp; !actual_recv-&gt;is_interface())) {
2242       // Use CHA on the receiver to select a more precise method.
2243       cha_monomorphic_target = target-&gt;find_monomorphic_target(calling_klass, callee_holder, actual_recv);
2244     } else if (code == Bytecodes::_invokeinterface &amp;&amp; callee_holder-&gt;is_loaded() &amp;&amp; receiver != NULL) {
2245       assert(callee_holder-&gt;is_interface(), &quot;invokeinterface to non interface?&quot;);
2246       // If there is only one implementor of this interface then we
2247       // may be able bind this invoke directly to the implementing
2248       // klass but we need both a dependence on the single interface
2249       // and on the method we bind to.  Additionally since all we know
2250       // about the receiver type is the it&#39;s supposed to implement the
2251       // interface we have to insert a check that it&#39;s the class we
2252       // expect.  Interface types are not checked by the verifier so
2253       // they are roughly equivalent to Object.
2254       // The number of implementors for declared_interface is less or
2255       // equal to the number of implementors for target-&gt;holder() so
2256       // if number of implementors of target-&gt;holder() == 1 then
2257       // number of implementors for decl_interface is 0 or 1. If
2258       // it&#39;s 0 then no class implements decl_interface and there&#39;s
2259       // no point in inlining.
2260       ciInstanceKlass* declared_interface = callee_holder;
2261       ciInstanceKlass* singleton = declared_interface-&gt;unique_implementor();
2262       if (singleton != NULL &amp;&amp;
2263           (!target-&gt;is_default_method() || target-&gt;is_overpass()) /* CHA doesn&#39;t support default methods yet. */ ) {
2264         assert(singleton != declared_interface, &quot;not a unique implementor&quot;);
2265         cha_monomorphic_target = target-&gt;find_monomorphic_target(calling_klass, declared_interface, singleton);
2266         if (cha_monomorphic_target != NULL) {
2267           if (cha_monomorphic_target-&gt;holder() != compilation()-&gt;env()-&gt;Object_klass()) {
2268             // If CHA is able to bind this invoke then update the class
2269             // to match that class, otherwise klass will refer to the
2270             // interface.
2271             klass = cha_monomorphic_target-&gt;holder();
2272             actual_recv = declared_interface;
2273 
2274             // insert a check it&#39;s really the expected class.
2275             CheckCast* c = new CheckCast(klass, receiver, copy_state_for_exception());
2276             c-&gt;set_incompatible_class_change_check();
2277             c-&gt;set_direct_compare(klass-&gt;is_final());
2278             // pass the result of the checkcast so that the compiler has
2279             // more accurate type info in the inlinee
2280             better_receiver = append_split(c);
2281           } else {
2282             cha_monomorphic_target = NULL; // subtype check against Object is useless
2283           }
2284         }
2285       }
2286     }
2287   }
2288 
2289   if (cha_monomorphic_target != NULL) {
2290     assert(!target-&gt;can_be_statically_bound() || target == cha_monomorphic_target, &quot;&quot;);
2291     assert(!cha_monomorphic_target-&gt;is_abstract(), &quot;&quot;);
2292     if (!cha_monomorphic_target-&gt;can_be_statically_bound(actual_recv)) {
2293       // If we inlined because CHA revealed only a single target method,
2294       // then we are dependent on that target method not getting overridden
2295       // by dynamic class loading.  Be sure to test the &quot;static&quot; receiver
2296       // dest_method here, as opposed to the actual receiver, which may
2297       // falsely lead us to believe that the receiver is final or private.
2298       dependency_recorder()-&gt;assert_unique_concrete_method(actual_recv, cha_monomorphic_target);
2299     }
2300     code = Bytecodes::_invokespecial;
2301   }
2302 
2303   // check if we could do inlining
2304   if (!PatchALot &amp;&amp; Inline &amp;&amp; target-&gt;is_loaded() &amp;&amp;
2305       (klass-&gt;is_initialized() || (klass-&gt;is_interface() &amp;&amp; target-&gt;holder()-&gt;is_initialized()))
2306       &amp;&amp; !patch_for_appendix) {
2307     // callee is known =&gt; check if we have static binding
2308     if (code == Bytecodes::_invokestatic  ||
2309         code == Bytecodes::_invokespecial ||
2310         (code == Bytecodes::_invokevirtual &amp;&amp; target-&gt;is_final_method()) ||
2311         code == Bytecodes::_invokedynamic) {
2312       ciMethod* inline_target = (cha_monomorphic_target != NULL) ? cha_monomorphic_target : target;
2313       // static binding =&gt; check if callee is ok
2314       bool success = try_inline(inline_target, (cha_monomorphic_target != NULL) || (exact_target != NULL), false, code, better_receiver);
2315 
2316       CHECK_BAILOUT();
2317       clear_inline_bailout();
2318 
2319       if (success) {
2320         // Register dependence if JVMTI has either breakpoint
2321         // setting or hotswapping of methods capabilities since they may
2322         // cause deoptimization.
2323         if (compilation()-&gt;env()-&gt;jvmti_can_hotswap_or_post_breakpoint()) {
2324           dependency_recorder()-&gt;assert_evol_method(inline_target);
2325         }
2326         return;
2327       }
2328     } else {
2329       print_inlining(target, &quot;no static binding&quot;, /*success*/ false);
2330     }
2331   } else {
2332     print_inlining(target, &quot;not inlineable&quot;, /*success*/ false);
2333   }
2334 
2335   // If we attempted an inline which did not succeed because of a
2336   // bailout during construction of the callee graph, the entire
2337   // compilation has to be aborted. This is fairly rare and currently
2338   // seems to only occur for jasm-generated classes which contain
2339   // jsr/ret pairs which are not associated with finally clauses and
2340   // do not have exception handlers in the containing method, and are
2341   // therefore not caught early enough to abort the inlining without
2342   // corrupting the graph. (We currently bail out with a non-empty
2343   // stack at a ret in these situations.)
2344   CHECK_BAILOUT();
2345 
2346   // inlining not successful =&gt; standard invoke
2347   ValueType* result_type = as_ValueType(declared_signature-&gt;return_type());
2348   ValueStack* state_before = copy_state_exhandling();
2349 
2350   // The bytecode (code) might change in this method so we are checking this very late.
2351   const bool has_receiver =
2352     code == Bytecodes::_invokespecial   ||
2353     code == Bytecodes::_invokevirtual   ||
2354     code == Bytecodes::_invokeinterface;
2355   Values* args = state()-&gt;pop_arguments(target-&gt;arg_size_no_receiver() + patching_appendix_arg);
2356   Value recv = has_receiver ? apop() : NULL;
2357   int vtable_index = Method::invalid_vtable_index;
2358 
2359   // A null check is required here (when there is a receiver) for any of the following cases
2360   // - invokespecial, always need a null check.
2361   // - invokevirtual, when the target is final and loaded. Calls to final targets will become optimized
2362   //   and require null checking. If the target is loaded a null check is emitted here.
2363   //   If the target isn&#39;t loaded the null check must happen after the call resolution. We achieve that
2364   //   by using the target methods unverified entry point (see CompiledIC::compute_monomorphic_entry).
2365   //   (The JVM specification requires that LinkageError must be thrown before a NPE. An unloaded target may
2366   //   potentially fail, and can&#39;t have the null check before the resolution.)
2367   // - A call that will be profiled. (But we can&#39;t add a null check when the target is unloaded, by the same
2368   //   reason as above, so calls with a receiver to unloaded targets can&#39;t be profiled.)
2369   //
2370   // Normal invokevirtual will perform the null check during lookup
2371 
2372   bool need_null_check = (code == Bytecodes::_invokespecial) ||
2373       (target-&gt;is_loaded() &amp;&amp; (target-&gt;is_final_method() || (is_profiling() &amp;&amp; profile_calls())));
2374 
2375   if (need_null_check) {
2376     if (recv != NULL) {
2377       null_check(recv);
2378     }
2379 
2380     if (is_profiling()) {
2381       // Note that we&#39;d collect profile data in this method if we wanted it.
2382       compilation()-&gt;set_would_profile(true);
2383 
2384       if (profile_calls()) {
2385         assert(cha_monomorphic_target == NULL || exact_target == NULL, &quot;both can not be set&quot;);
2386         ciKlass* target_klass = NULL;
2387         if (cha_monomorphic_target != NULL) {
2388           target_klass = cha_monomorphic_target-&gt;holder();
2389         } else if (exact_target != NULL) {
2390           target_klass = exact_target-&gt;holder();
2391         }
2392         profile_call(target, recv, target_klass, collect_args_for_profiling(args, NULL, false), false);
2393       }
2394     }
2395   }
2396 
2397   if (recv != NULL) {
2398     recv-&gt;set_escaped();
2399   }
2400   for (int i=0; i&lt;args-&gt;length(); i++) {
2401     args-&gt;at(0)-&gt;set_escaped();
2402   }
2403 
2404   Invoke* result = new Invoke(code, result_type, recv, args, vtable_index, target, state_before,
2405                               declared_signature-&gt;return_type()-&gt;is_inlinetype());
2406   // push result
2407   append_split(result);
2408 
2409   if (result_type != voidType) {
2410     if (method()-&gt;is_strict()) {
2411       push(result_type, round_fp(result));
2412     } else {
2413       push(result_type, result);
2414     }
2415   }
2416   if (profile_return() &amp;&amp; result_type-&gt;is_object_kind()) {
2417     profile_return_type(result, target);
2418   }
2419 }
2420 
2421 
2422 void GraphBuilder::new_instance(int klass_index) {
2423   ValueStack* state_before = copy_state_exhandling();
2424   bool will_link;
2425   ciKlass* klass = stream()-&gt;get_klass(will_link);
2426   assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2427   assert(!klass-&gt;is_inlinetype(), &quot;must not be an inline klass&quot;);
2428   NewInstance* new_instance = new NewInstance(klass-&gt;as_instance_klass(), state_before, stream()-&gt;is_unresolved_klass());
2429   _memory-&gt;new_instance(new_instance);
2430   apush(append_split(new_instance));
2431 }
2432 
2433 void GraphBuilder::default_value(int klass_index) {
2434   bool will_link;
2435   if (!stream()-&gt;is_unresolved_klass()) {
2436     ciInlineKlass* vk = stream()-&gt;get_klass(will_link)-&gt;as_inline_klass();
2437     apush(append(new Constant(new InstanceConstant(vk-&gt;default_instance()))));
2438   } else {
2439     ValueStack* state_before = copy_state_before();
2440     apush(append_split(new DefaultValue(state_before)));
2441   }
2442 }
2443 
2444 void GraphBuilder::new_type_array() {
2445   ValueStack* state_before = copy_state_exhandling();
2446   apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()-&gt;get_index(), state_before)));
2447 }
2448 
2449 
2450 void GraphBuilder::new_object_array() {
2451   bool will_link;
2452   ciKlass* klass = stream()-&gt;get_klass(will_link);
2453   bool null_free = stream()-&gt;is_inline_klass();
2454   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2455   NewArray* n = new NewObjectArray(klass, ipop(), state_before, null_free);
2456   apush(append_split(n));
2457 }
2458 
2459 
2460 bool GraphBuilder::direct_compare(ciKlass* k) {
2461   if (k-&gt;is_loaded() &amp;&amp; k-&gt;is_instance_klass() &amp;&amp; !UseSlowPath) {
2462     ciInstanceKlass* ik = k-&gt;as_instance_klass();
2463     if (ik-&gt;is_final()) {
2464       return true;
2465     } else {
2466       if (DeoptC1 &amp;&amp; UseCHA &amp;&amp; !(ik-&gt;has_subklass() || ik-&gt;is_interface())) {
2467         // test class is leaf class
2468         dependency_recorder()-&gt;assert_leaf_type(ik);
2469         return true;
2470       }
2471     }
2472   }
2473   return false;
2474 }
2475 
2476 
2477 void GraphBuilder::check_cast(int klass_index) {
2478   bool will_link;
2479   ciKlass* klass = stream()-&gt;get_klass(will_link);
2480   bool null_free = stream()-&gt;is_inline_klass();
2481   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_for_exception();
2482   CheckCast* c = new CheckCast(klass, apop(), state_before, null_free);
2483   apush(append_split(c));
2484   c-&gt;set_direct_compare(direct_compare(klass));
2485 
2486   if (is_profiling()) {
2487     // Note that we&#39;d collect profile data in this method if we wanted it.
2488     compilation()-&gt;set_would_profile(true);
2489 
2490     if (profile_checkcasts()) {
2491       c-&gt;set_profiled_method(method());
2492       c-&gt;set_profiled_bci(bci());
2493       c-&gt;set_should_profile(true);
2494     }
2495   }
2496 }
2497 
2498 
2499 void GraphBuilder::instance_of(int klass_index) {
2500   bool will_link;
2501   ciKlass* klass = stream()-&gt;get_klass(will_link);
2502   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2503   InstanceOf* i = new InstanceOf(klass, apop(), state_before);
2504   ipush(append_split(i));
2505   i-&gt;set_direct_compare(direct_compare(klass));
2506 
2507   if (is_profiling()) {
2508     // Note that we&#39;d collect profile data in this method if we wanted it.
2509     compilation()-&gt;set_would_profile(true);
2510 
2511     if (profile_checkcasts()) {
2512       i-&gt;set_profiled_method(method());
2513       i-&gt;set_profiled_bci(bci());
2514       i-&gt;set_should_profile(true);
2515     }
2516   }
2517 }
2518 
2519 
2520 void GraphBuilder::monitorenter(Value x, int bci) {
2521   bool maybe_inlinetype = false;
2522   if (bci == InvocationEntryBci) {
2523     // Called by GraphBuilder::inline_sync_entry.
2524 #ifdef ASSERT
2525     ciType* obj_type = x-&gt;declared_type();
2526     assert(obj_type == NULL || !obj_type-&gt;is_inlinetype(), &quot;inline types cannot have synchronized methods&quot;);
2527 #endif
2528   } else {
2529     // We are compiling a monitorenter bytecode
2530     if (EnableValhalla) {
2531       ciType* obj_type = x-&gt;declared_type();
2532       if (obj_type == NULL || obj_type-&gt;as_klass()-&gt;can_be_inline_klass()) {
2533         // If we&#39;re (possibly) locking on an inline type, check for markWord::always_locked_pattern
2534         // and throw IMSE. (obj_type is null for Phi nodes, so let&#39;s just be conservative).
2535         maybe_inlinetype = true;
2536       }
2537     }
2538   }
2539 
2540   // save state before locking in case of deoptimization after a NullPointerException
2541   ValueStack* state_before = copy_state_for_exception_with_bci(bci);
2542   append_with_bci(new MonitorEnter(x, state()-&gt;lock(x), state_before, maybe_inlinetype), bci);
2543   kill_all();
2544 }
2545 
2546 
2547 void GraphBuilder::monitorexit(Value x, int bci) {
2548   append_with_bci(new MonitorExit(x, state()-&gt;unlock()), bci);
2549   kill_all();
2550 }
2551 
2552 
2553 void GraphBuilder::new_multi_array(int dimensions) {
2554   bool will_link;
2555   ciKlass* klass = stream()-&gt;get_klass(will_link);
2556   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2557 
2558   Values* dims = new Values(dimensions, dimensions, NULL);
2559   // fill in all dimensions
2560   int i = dimensions;
2561   while (i-- &gt; 0) dims-&gt;at_put(i, ipop());
2562   // create array
2563   NewArray* n = new NewMultiArray(klass, dims, state_before);
2564   apush(append_split(n));
2565 }
2566 
2567 
2568 void GraphBuilder::throw_op(int bci) {
2569   // We require that the debug info for a Throw be the &quot;state before&quot;
2570   // the Throw (i.e., exception oop is still on TOS)
2571   ValueStack* state_before = copy_state_before_with_bci(bci);
2572   Throw* t = new Throw(apop(), state_before);
2573   // operand stack not needed after a throw
2574   state()-&gt;truncate_stack(0);
2575   append_with_bci(t, bci);
2576 }
2577 
2578 
2579 Value GraphBuilder::round_fp(Value fp_value) {
2580   if (strict_fp_requires_explicit_rounding) {
2581 #ifdef IA32
2582     // no rounding needed if SSE2 is used
2583     if (UseSSE &lt; 2) {
2584       // Must currently insert rounding node for doubleword values that
2585       // are results of expressions (i.e., not loads from memory or
2586       // constants)
2587       if (fp_value-&gt;type()-&gt;tag() == doubleTag &amp;&amp;
2588           fp_value-&gt;as_Constant() == NULL &amp;&amp;
2589           fp_value-&gt;as_Local() == NULL &amp;&amp;       // method parameters need no rounding
2590           fp_value-&gt;as_RoundFP() == NULL) {
2591         return append(new RoundFP(fp_value));
2592       }
2593     }
2594 #else
2595     Unimplemented();
2596 #endif // IA32
2597   }
2598   return fp_value;
2599 }
2600 
2601 
2602 Instruction* GraphBuilder::append_with_bci(Instruction* instr, int bci) {
2603   Canonicalizer canon(compilation(), instr, bci);
2604   Instruction* i1 = canon.canonical();
2605   if (i1-&gt;is_linked() || !i1-&gt;can_be_linked()) {
2606     // Canonicalizer returned an instruction which was already
2607     // appended so simply return it.
2608     return i1;
2609   }
2610 
2611   if (UseLocalValueNumbering) {
2612     // Lookup the instruction in the ValueMap and add it to the map if
2613     // it&#39;s not found.
2614     Instruction* i2 = vmap()-&gt;find_insert(i1);
2615     if (i2 != i1) {
2616       // found an entry in the value map, so just return it.
2617       assert(i2-&gt;is_linked(), &quot;should already be linked&quot;);
2618       return i2;
2619     }
2620     ValueNumberingEffects vne(vmap());
2621     i1-&gt;visit(&amp;vne);
2622   }
2623 
2624   // i1 was not eliminated =&gt; append it
2625   assert(i1-&gt;next() == NULL, &quot;shouldn&#39;t already be linked&quot;);
2626   _last = _last-&gt;set_next(i1, canon.bci());
2627 
2628   if (++_instruction_count &gt;= InstructionCountCutoff &amp;&amp; !bailed_out()) {
2629     // set the bailout state but complete normal processing.  We
2630     // might do a little more work before noticing the bailout so we
2631     // want processing to continue normally until it&#39;s noticed.
2632     bailout(&quot;Method and/or inlining is too large&quot;);
2633   }
2634 
2635 #ifndef PRODUCT
2636   if (PrintIRDuringConstruction) {
2637     InstructionPrinter ip;
2638     ip.print_line(i1);
2639     if (Verbose) {
2640       state()-&gt;print();
2641     }
2642   }
2643 #endif
2644 
2645   // save state after modification of operand stack for StateSplit instructions
2646   StateSplit* s = i1-&gt;as_StateSplit();
2647   if (s != NULL) {
2648     if (EliminateFieldAccess) {
2649       Intrinsic* intrinsic = s-&gt;as_Intrinsic();
2650       if (s-&gt;as_Invoke() != NULL || (intrinsic &amp;&amp; !intrinsic-&gt;preserves_state())) {
2651         _memory-&gt;kill();
2652       }
2653     }
2654     s-&gt;set_state(state()-&gt;copy(ValueStack::StateAfter, canon.bci()));
2655   }
2656 
2657   // set up exception handlers for this instruction if necessary
2658   if (i1-&gt;can_trap()) {
2659     i1-&gt;set_exception_handlers(handle_exception(i1));
2660     assert(i1-&gt;exception_state() != NULL || !i1-&gt;needs_exception_state() || bailed_out(), &quot;handle_exception must set exception state&quot;);
2661   }
2662   return i1;
2663 }
2664 
2665 
2666 Instruction* GraphBuilder::append(Instruction* instr) {
2667   assert(instr-&gt;as_StateSplit() == NULL || instr-&gt;as_BlockEnd() != NULL, &quot;wrong append used&quot;);
2668   return append_with_bci(instr, bci());
2669 }
2670 
2671 
2672 Instruction* GraphBuilder::append_split(StateSplit* instr) {
2673   return append_with_bci(instr, bci());
2674 }
2675 
2676 
2677 void GraphBuilder::null_check(Value value) {
2678   if (value-&gt;as_NewArray() != NULL || value-&gt;as_NewInstance() != NULL) {
2679     return;
2680   } else {
2681     Constant* con = value-&gt;as_Constant();
2682     if (con) {
2683       ObjectType* c = con-&gt;type()-&gt;as_ObjectType();
2684       if (c &amp;&amp; c-&gt;is_loaded()) {
2685         ObjectConstant* oc = c-&gt;as_ObjectConstant();
2686         if (!oc || !oc-&gt;value()-&gt;is_null_object()) {
2687           return;
2688         }
2689       }
2690     }
2691   }
2692   append(new NullCheck(value, copy_state_for_exception()));
2693 }
2694 
2695 
2696 
2697 XHandlers* GraphBuilder::handle_exception(Instruction* instruction) {
2698   if (!has_handler() &amp;&amp; (!instruction-&gt;needs_exception_state() || instruction-&gt;exception_state() != NULL)) {
2699     assert(instruction-&gt;exception_state() == NULL
2700            || instruction-&gt;exception_state()-&gt;kind() == ValueStack::EmptyExceptionState
2701            || (instruction-&gt;exception_state()-&gt;kind() == ValueStack::ExceptionState &amp;&amp; _compilation-&gt;env()-&gt;should_retain_local_variables()),
2702            &quot;exception_state should be of exception kind&quot;);
2703     return new XHandlers();
2704   }
2705 
2706   XHandlers*  exception_handlers = new XHandlers();
2707   ScopeData*  cur_scope_data = scope_data();
2708   ValueStack* cur_state = instruction-&gt;state_before();
2709   ValueStack* prev_state = NULL;
2710   int scope_count = 0;
2711 
2712   assert(cur_state != NULL, &quot;state_before must be set&quot;);
2713   do {
2714     int cur_bci = cur_state-&gt;bci();
2715     assert(cur_scope_data-&gt;scope() == cur_state-&gt;scope(), &quot;scopes do not match&quot;);
2716     assert(cur_bci == SynchronizationEntryBCI || cur_bci == cur_scope_data-&gt;stream()-&gt;cur_bci(), &quot;invalid bci&quot;);
2717 
2718     // join with all potential exception handlers
2719     XHandlers* list = cur_scope_data-&gt;xhandlers();
2720     const int n = list-&gt;length();
2721     for (int i = 0; i &lt; n; i++) {
2722       XHandler* h = list-&gt;handler_at(i);
2723       if (h-&gt;covers(cur_bci)) {
2724         // h is a potential exception handler =&gt; join it
2725         compilation()-&gt;set_has_exception_handlers(true);
2726 
2727         BlockBegin* entry = h-&gt;entry_block();
2728         if (entry == block()) {
2729           // It&#39;s acceptable for an exception handler to cover itself
2730           // but we don&#39;t handle that in the parser currently.  It&#39;s
2731           // very rare so we bailout instead of trying to handle it.
2732           BAILOUT_(&quot;exception handler covers itself&quot;, exception_handlers);
2733         }
2734         assert(entry-&gt;bci() == h-&gt;handler_bci(), &quot;must match&quot;);
2735         assert(entry-&gt;bci() == -1 || entry == cur_scope_data-&gt;block_at(entry-&gt;bci()), &quot;blocks must correspond&quot;);
2736 
2737         // previously this was a BAILOUT, but this is not necessary
2738         // now because asynchronous exceptions are not handled this way.
2739         assert(entry-&gt;state() == NULL || cur_state-&gt;total_locks_size() == entry-&gt;state()-&gt;total_locks_size(), &quot;locks do not match&quot;);
2740 
2741         // xhandler start with an empty expression stack
2742         if (cur_state-&gt;stack_size() != 0) {
2743           cur_state = cur_state-&gt;copy(ValueStack::ExceptionState, cur_state-&gt;bci());
2744         }
2745         if (instruction-&gt;exception_state() == NULL) {
2746           instruction-&gt;set_exception_state(cur_state);
2747         }
2748 
2749         // Note: Usually this join must work. However, very
2750         // complicated jsr-ret structures where we don&#39;t ret from
2751         // the subroutine can cause the objects on the monitor
2752         // stacks to not match because blocks can be parsed twice.
2753         // The only test case we&#39;ve seen so far which exhibits this
2754         // problem is caught by the infinite recursion test in
2755         // GraphBuilder::jsr() if the join doesn&#39;t work.
2756         if (!entry-&gt;try_merge(cur_state)) {
2757           BAILOUT_(&quot;error while joining with exception handler, prob. due to complicated jsr/rets&quot;, exception_handlers);
2758         }
2759 
2760         // add current state for correct handling of phi functions at begin of xhandler
2761         int phi_operand = entry-&gt;add_exception_state(cur_state);
2762 
2763         // add entry to the list of xhandlers of this block
2764         _block-&gt;add_exception_handler(entry);
2765 
2766         // add back-edge from xhandler entry to this block
2767         if (!entry-&gt;is_predecessor(_block)) {
2768           entry-&gt;add_predecessor(_block);
2769         }
2770 
2771         // clone XHandler because phi_operand and scope_count can not be shared
2772         XHandler* new_xhandler = new XHandler(h);
2773         new_xhandler-&gt;set_phi_operand(phi_operand);
2774         new_xhandler-&gt;set_scope_count(scope_count);
2775         exception_handlers-&gt;append(new_xhandler);
2776 
2777         // fill in exception handler subgraph lazily
2778         assert(!entry-&gt;is_set(BlockBegin::was_visited_flag), &quot;entry must not be visited yet&quot;);
2779         cur_scope_data-&gt;add_to_work_list(entry);
2780 
2781         // stop when reaching catchall
2782         if (h-&gt;catch_type() == 0) {
2783           return exception_handlers;
2784         }
2785       }
2786     }
2787 
2788     if (exception_handlers-&gt;length() == 0) {
2789       // This scope and all callees do not handle exceptions, so the local
2790       // variables of this scope are not needed. However, the scope itself is
2791       // required for a correct exception stack trace -&gt; clear out the locals.
2792       if (_compilation-&gt;env()-&gt;should_retain_local_variables()) {
2793         cur_state = cur_state-&gt;copy(ValueStack::ExceptionState, cur_state-&gt;bci());
2794       } else {
2795         cur_state = cur_state-&gt;copy(ValueStack::EmptyExceptionState, cur_state-&gt;bci());
2796       }
2797       if (prev_state != NULL) {
2798         prev_state-&gt;set_caller_state(cur_state);
2799       }
2800       if (instruction-&gt;exception_state() == NULL) {
2801         instruction-&gt;set_exception_state(cur_state);
2802       }
2803     }
2804 
2805     // Set up iteration for next time.
2806     // If parsing a jsr, do not grab exception handlers from the
2807     // parent scopes for this method (already got them, and they
2808     // needed to be cloned)
2809 
2810     while (cur_scope_data-&gt;parsing_jsr()) {
2811       cur_scope_data = cur_scope_data-&gt;parent();
2812     }
2813 
2814     assert(cur_scope_data-&gt;scope() == cur_state-&gt;scope(), &quot;scopes do not match&quot;);
2815     assert(cur_state-&gt;locks_size() == 0 || cur_state-&gt;locks_size() == 1, &quot;unlocking must be done in a catchall exception handler&quot;);
2816 
2817     prev_state = cur_state;
2818     cur_state = cur_state-&gt;caller_state();
2819     cur_scope_data = cur_scope_data-&gt;parent();
2820     scope_count++;
2821   } while (cur_scope_data != NULL);
2822 
2823   return exception_handlers;
2824 }
2825 
2826 
2827 // Helper class for simplifying Phis.
2828 class PhiSimplifier : public BlockClosure {
2829  private:
2830   bool _has_substitutions;
2831   Value simplify(Value v);
2832 
2833  public:
2834   PhiSimplifier(BlockBegin* start) : _has_substitutions(false) {
2835     start-&gt;iterate_preorder(this);
2836     if (_has_substitutions) {
2837       SubstitutionResolver sr(start);
2838     }
2839   }
2840   void block_do(BlockBegin* b);
2841   bool has_substitutions() const { return _has_substitutions; }
2842 };
2843 
2844 
2845 Value PhiSimplifier::simplify(Value v) {
2846   Phi* phi = v-&gt;as_Phi();
2847 
2848   if (phi == NULL) {
2849     // no phi function
2850     return v;
2851   } else if (v-&gt;has_subst()) {
2852     // already substituted; subst can be phi itself -&gt; simplify
2853     return simplify(v-&gt;subst());
2854   } else if (phi-&gt;is_set(Phi::cannot_simplify)) {
2855     // already tried to simplify phi before
2856     return phi;
2857   } else if (phi-&gt;is_set(Phi::visited)) {
2858     // break cycles in phi functions
2859     return phi;
2860   } else if (phi-&gt;type()-&gt;is_illegal()) {
2861     // illegal phi functions are ignored anyway
2862     return phi;
2863 
2864   } else {
2865     // mark phi function as processed to break cycles in phi functions
2866     phi-&gt;set(Phi::visited);
2867 
2868     // simplify x = [y, x] and x = [y, y] to y
2869     Value subst = NULL;
2870     int opd_count = phi-&gt;operand_count();
2871     for (int i = 0; i &lt; opd_count; i++) {
2872       Value opd = phi-&gt;operand_at(i);
2873       assert(opd != NULL, &quot;Operand must exist!&quot;);
2874 
2875       if (opd-&gt;type()-&gt;is_illegal()) {
2876         // if one operand is illegal, the entire phi function is illegal
2877         phi-&gt;make_illegal();
2878         phi-&gt;clear(Phi::visited);
2879         return phi;
2880       }
2881 
2882       Value new_opd = simplify(opd);
2883       assert(new_opd != NULL, &quot;Simplified operand must exist!&quot;);
2884 
2885       if (new_opd != phi &amp;&amp; new_opd != subst) {
2886         if (subst == NULL) {
2887           subst = new_opd;
2888         } else {
2889           // no simplification possible
2890           phi-&gt;set(Phi::cannot_simplify);
2891           phi-&gt;clear(Phi::visited);
2892           return phi;
2893         }
2894       }
2895     }
2896 
2897     // sucessfully simplified phi function
2898     assert(subst != NULL, &quot;illegal phi function&quot;);
2899     _has_substitutions = true;
2900     phi-&gt;clear(Phi::visited);
2901     phi-&gt;set_subst(subst);
2902 
2903 #ifndef PRODUCT
2904     if (PrintPhiFunctions) {
2905       tty-&gt;print_cr(&quot;simplified phi function %c%d to %c%d (Block B%d)&quot;, phi-&gt;type()-&gt;tchar(), phi-&gt;id(), subst-&gt;type()-&gt;tchar(), subst-&gt;id(), phi-&gt;block()-&gt;block_id());
2906     }
2907 #endif
2908 
2909     return subst;
2910   }
2911 }
2912 
2913 
2914 void PhiSimplifier::block_do(BlockBegin* b) {
2915   for_each_phi_fun(b, phi,
2916     simplify(phi);
2917   );
2918 
2919 #ifdef ASSERT
2920   for_each_phi_fun(b, phi,
2921                    assert(phi-&gt;operand_count() != 1 || phi-&gt;subst() != phi || phi-&gt;is_illegal(), &quot;missed trivial simplification&quot;);
2922   );
2923 
2924   ValueStack* state = b-&gt;state()-&gt;caller_state();
2925   for_each_state_value(state, value,
2926     Phi* phi = value-&gt;as_Phi();
2927     assert(phi == NULL || phi-&gt;block() != b, &quot;must not have phi function to simplify in caller state&quot;);
2928   );
2929 #endif
2930 }
2931 
2932 // This method is called after all blocks are filled with HIR instructions
2933 // It eliminates all Phi functions of the form x = [y, y] and x = [y, x]
2934 void GraphBuilder::eliminate_redundant_phis(BlockBegin* start) {
2935   PhiSimplifier simplifier(start);
2936 }
2937 
2938 
2939 void GraphBuilder::connect_to_end(BlockBegin* beg) {
2940   // setup iteration
2941   kill_all();
2942   _block = beg;
2943   _state = beg-&gt;state()-&gt;copy_for_parsing();
2944   _last  = beg;
2945   iterate_bytecodes_for_block(beg-&gt;bci());
2946 }
2947 
2948 
2949 BlockEnd* GraphBuilder::iterate_bytecodes_for_block(int bci) {
2950 #ifndef PRODUCT
2951   if (PrintIRDuringConstruction) {
2952     tty-&gt;cr();
2953     InstructionPrinter ip;
2954     ip.print_instr(_block); tty-&gt;cr();
2955     ip.print_stack(_block-&gt;state()); tty-&gt;cr();
2956     ip.print_inline_level(_block);
2957     ip.print_head();
2958     tty-&gt;print_cr(&quot;locals size: %d stack size: %d&quot;, state()-&gt;locals_size(), state()-&gt;stack_size());
2959   }
2960 #endif
2961   _skip_block = false;
2962   assert(state() != NULL, &quot;ValueStack missing!&quot;);
2963   CompileLog* log = compilation()-&gt;log();
2964   ciBytecodeStream s(method());
2965   s.reset_to_bci(bci);
2966   int prev_bci = bci;
2967   scope_data()-&gt;set_stream(&amp;s);
2968   // iterate
2969   Bytecodes::Code code = Bytecodes::_illegal;
2970   bool push_exception = false;
2971 
2972   if (block()-&gt;is_set(BlockBegin::exception_entry_flag) &amp;&amp; block()-&gt;next() == NULL) {
2973     // first thing in the exception entry block should be the exception object.
2974     push_exception = true;
2975   }
2976 
2977   bool ignore_return = scope_data()-&gt;ignore_return();
2978 
2979   while (!bailed_out() &amp;&amp; last()-&gt;as_BlockEnd() == NULL &amp;&amp;
2980          (code = stream()-&gt;next()) != ciBytecodeStream::EOBC() &amp;&amp;
2981          (block_at(s.cur_bci()) == NULL || block_at(s.cur_bci()) == block())) {
2982     assert(state()-&gt;kind() == ValueStack::Parsing, &quot;invalid state kind&quot;);
2983 
2984     if (log != NULL)
2985       log-&gt;set_context(&quot;bc code=&#39;%d&#39; bci=&#39;%d&#39;&quot;, (int)code, s.cur_bci());
2986 
2987     // Check for active jsr during OSR compilation
2988     if (compilation()-&gt;is_osr_compile()
2989         &amp;&amp; scope()-&gt;is_top_scope()
2990         &amp;&amp; parsing_jsr()
2991         &amp;&amp; s.cur_bci() == compilation()-&gt;osr_bci()) {
2992       bailout(&quot;OSR not supported while a jsr is active&quot;);
2993     }
2994 
2995     if (push_exception) {
2996       apush(append(new ExceptionObject()));
2997       push_exception = false;
2998     }
2999 
3000     // handle bytecode
3001     switch (code) {
3002       case Bytecodes::_nop            : /* nothing to do */ break;
3003       case Bytecodes::_aconst_null    : apush(append(new Constant(objectNull            ))); break;
3004       case Bytecodes::_iconst_m1      : ipush(append(new Constant(new IntConstant   (-1)))); break;
3005       case Bytecodes::_iconst_0       : ipush(append(new Constant(intZero               ))); break;
3006       case Bytecodes::_iconst_1       : ipush(append(new Constant(intOne                ))); break;
3007       case Bytecodes::_iconst_2       : ipush(append(new Constant(new IntConstant   ( 2)))); break;
3008       case Bytecodes::_iconst_3       : ipush(append(new Constant(new IntConstant   ( 3)))); break;
3009       case Bytecodes::_iconst_4       : ipush(append(new Constant(new IntConstant   ( 4)))); break;
3010       case Bytecodes::_iconst_5       : ipush(append(new Constant(new IntConstant   ( 5)))); break;
3011       case Bytecodes::_lconst_0       : lpush(append(new Constant(new LongConstant  ( 0)))); break;
3012       case Bytecodes::_lconst_1       : lpush(append(new Constant(new LongConstant  ( 1)))); break;
3013       case Bytecodes::_fconst_0       : fpush(append(new Constant(new FloatConstant ( 0)))); break;
3014       case Bytecodes::_fconst_1       : fpush(append(new Constant(new FloatConstant ( 1)))); break;
3015       case Bytecodes::_fconst_2       : fpush(append(new Constant(new FloatConstant ( 2)))); break;
3016       case Bytecodes::_dconst_0       : dpush(append(new Constant(new DoubleConstant( 0)))); break;
3017       case Bytecodes::_dconst_1       : dpush(append(new Constant(new DoubleConstant( 1)))); break;
3018       case Bytecodes::_bipush         : ipush(append(new Constant(new IntConstant(((signed char*)s.cur_bcp())[1])))); break;
3019       case Bytecodes::_sipush         : ipush(append(new Constant(new IntConstant((short)Bytes::get_Java_u2(s.cur_bcp()+1))))); break;
3020       case Bytecodes::_ldc            : // fall through
3021       case Bytecodes::_ldc_w          : // fall through
3022       case Bytecodes::_ldc2_w         : load_constant(); break;
3023       case Bytecodes::_iload          : load_local(intType     , s.get_index()); break;
3024       case Bytecodes::_lload          : load_local(longType    , s.get_index()); break;
3025       case Bytecodes::_fload          : load_local(floatType   , s.get_index()); break;
3026       case Bytecodes::_dload          : load_local(doubleType  , s.get_index()); break;
3027       case Bytecodes::_aload          : load_local(instanceType, s.get_index()); break;
3028       case Bytecodes::_iload_0        : load_local(intType   , 0); break;
3029       case Bytecodes::_iload_1        : load_local(intType   , 1); break;
3030       case Bytecodes::_iload_2        : load_local(intType   , 2); break;
3031       case Bytecodes::_iload_3        : load_local(intType   , 3); break;
3032       case Bytecodes::_lload_0        : load_local(longType  , 0); break;
3033       case Bytecodes::_lload_1        : load_local(longType  , 1); break;
3034       case Bytecodes::_lload_2        : load_local(longType  , 2); break;
3035       case Bytecodes::_lload_3        : load_local(longType  , 3); break;
3036       case Bytecodes::_fload_0        : load_local(floatType , 0); break;
3037       case Bytecodes::_fload_1        : load_local(floatType , 1); break;
3038       case Bytecodes::_fload_2        : load_local(floatType , 2); break;
3039       case Bytecodes::_fload_3        : load_local(floatType , 3); break;
3040       case Bytecodes::_dload_0        : load_local(doubleType, 0); break;
3041       case Bytecodes::_dload_1        : load_local(doubleType, 1); break;
3042       case Bytecodes::_dload_2        : load_local(doubleType, 2); break;
3043       case Bytecodes::_dload_3        : load_local(doubleType, 3); break;
3044       case Bytecodes::_aload_0        : load_local(objectType, 0); break;
3045       case Bytecodes::_aload_1        : load_local(objectType, 1); break;
3046       case Bytecodes::_aload_2        : load_local(objectType, 2); break;
3047       case Bytecodes::_aload_3        : load_local(objectType, 3); break;
3048       case Bytecodes::_iaload         : load_indexed(T_INT   ); break;
3049       case Bytecodes::_laload         : load_indexed(T_LONG  ); break;
3050       case Bytecodes::_faload         : load_indexed(T_FLOAT ); break;
3051       case Bytecodes::_daload         : load_indexed(T_DOUBLE); break;
3052       case Bytecodes::_aaload         : load_indexed(T_OBJECT); break;
3053       case Bytecodes::_baload         : load_indexed(T_BYTE  ); break;
3054       case Bytecodes::_caload         : load_indexed(T_CHAR  ); break;
3055       case Bytecodes::_saload         : load_indexed(T_SHORT ); break;
3056       case Bytecodes::_istore         : store_local(intType   , s.get_index()); break;
3057       case Bytecodes::_lstore         : store_local(longType  , s.get_index()); break;
3058       case Bytecodes::_fstore         : store_local(floatType , s.get_index()); break;
3059       case Bytecodes::_dstore         : store_local(doubleType, s.get_index()); break;
3060       case Bytecodes::_astore         : store_local(objectType, s.get_index()); break;
3061       case Bytecodes::_istore_0       : store_local(intType   , 0); break;
3062       case Bytecodes::_istore_1       : store_local(intType   , 1); break;
3063       case Bytecodes::_istore_2       : store_local(intType   , 2); break;
3064       case Bytecodes::_istore_3       : store_local(intType   , 3); break;
3065       case Bytecodes::_lstore_0       : store_local(longType  , 0); break;
3066       case Bytecodes::_lstore_1       : store_local(longType  , 1); break;
3067       case Bytecodes::_lstore_2       : store_local(longType  , 2); break;
3068       case Bytecodes::_lstore_3       : store_local(longType  , 3); break;
3069       case Bytecodes::_fstore_0       : store_local(floatType , 0); break;
3070       case Bytecodes::_fstore_1       : store_local(floatType , 1); break;
3071       case Bytecodes::_fstore_2       : store_local(floatType , 2); break;
3072       case Bytecodes::_fstore_3       : store_local(floatType , 3); break;
3073       case Bytecodes::_dstore_0       : store_local(doubleType, 0); break;
3074       case Bytecodes::_dstore_1       : store_local(doubleType, 1); break;
3075       case Bytecodes::_dstore_2       : store_local(doubleType, 2); break;
3076       case Bytecodes::_dstore_3       : store_local(doubleType, 3); break;
3077       case Bytecodes::_astore_0       : store_local(objectType, 0); break;
3078       case Bytecodes::_astore_1       : store_local(objectType, 1); break;
3079       case Bytecodes::_astore_2       : store_local(objectType, 2); break;
3080       case Bytecodes::_astore_3       : store_local(objectType, 3); break;
3081       case Bytecodes::_iastore        : store_indexed(T_INT   ); break;
3082       case Bytecodes::_lastore        : store_indexed(T_LONG  ); break;
3083       case Bytecodes::_fastore        : store_indexed(T_FLOAT ); break;
3084       case Bytecodes::_dastore        : store_indexed(T_DOUBLE); break;
3085       case Bytecodes::_aastore        : store_indexed(T_OBJECT); break;
3086       case Bytecodes::_bastore        : store_indexed(T_BYTE  ); break;
3087       case Bytecodes::_castore        : store_indexed(T_CHAR  ); break;
3088       case Bytecodes::_sastore        : store_indexed(T_SHORT ); break;
3089       case Bytecodes::_pop            : // fall through
3090       case Bytecodes::_pop2           : // fall through
3091       case Bytecodes::_dup            : // fall through
3092       case Bytecodes::_dup_x1         : // fall through
3093       case Bytecodes::_dup_x2         : // fall through
3094       case Bytecodes::_dup2           : // fall through
3095       case Bytecodes::_dup2_x1        : // fall through
3096       case Bytecodes::_dup2_x2        : // fall through
3097       case Bytecodes::_swap           : stack_op(code); break;
3098       case Bytecodes::_iadd           : arithmetic_op(intType   , code); break;
3099       case Bytecodes::_ladd           : arithmetic_op(longType  , code); break;
3100       case Bytecodes::_fadd           : arithmetic_op(floatType , code); break;
3101       case Bytecodes::_dadd           : arithmetic_op(doubleType, code); break;
3102       case Bytecodes::_isub           : arithmetic_op(intType   , code); break;
3103       case Bytecodes::_lsub           : arithmetic_op(longType  , code); break;
3104       case Bytecodes::_fsub           : arithmetic_op(floatType , code); break;
3105       case Bytecodes::_dsub           : arithmetic_op(doubleType, code); break;
3106       case Bytecodes::_imul           : arithmetic_op(intType   , code); break;
3107       case Bytecodes::_lmul           : arithmetic_op(longType  , code); break;
3108       case Bytecodes::_fmul           : arithmetic_op(floatType , code); break;
3109       case Bytecodes::_dmul           : arithmetic_op(doubleType, code); break;
3110       case Bytecodes::_idiv           : arithmetic_op(intType   , code, copy_state_for_exception()); break;
3111       case Bytecodes::_ldiv           : arithmetic_op(longType  , code, copy_state_for_exception()); break;
3112       case Bytecodes::_fdiv           : arithmetic_op(floatType , code); break;
3113       case Bytecodes::_ddiv           : arithmetic_op(doubleType, code); break;
3114       case Bytecodes::_irem           : arithmetic_op(intType   , code, copy_state_for_exception()); break;
3115       case Bytecodes::_lrem           : arithmetic_op(longType  , code, copy_state_for_exception()); break;
3116       case Bytecodes::_frem           : arithmetic_op(floatType , code); break;
3117       case Bytecodes::_drem           : arithmetic_op(doubleType, code); break;
3118       case Bytecodes::_ineg           : negate_op(intType   ); break;
3119       case Bytecodes::_lneg           : negate_op(longType  ); break;
3120       case Bytecodes::_fneg           : negate_op(floatType ); break;
3121       case Bytecodes::_dneg           : negate_op(doubleType); break;
3122       case Bytecodes::_ishl           : shift_op(intType , code); break;
3123       case Bytecodes::_lshl           : shift_op(longType, code); break;
3124       case Bytecodes::_ishr           : shift_op(intType , code); break;
3125       case Bytecodes::_lshr           : shift_op(longType, code); break;
3126       case Bytecodes::_iushr          : shift_op(intType , code); break;
3127       case Bytecodes::_lushr          : shift_op(longType, code); break;
3128       case Bytecodes::_iand           : logic_op(intType , code); break;
3129       case Bytecodes::_land           : logic_op(longType, code); break;
3130       case Bytecodes::_ior            : logic_op(intType , code); break;
3131       case Bytecodes::_lor            : logic_op(longType, code); break;
3132       case Bytecodes::_ixor           : logic_op(intType , code); break;
3133       case Bytecodes::_lxor           : logic_op(longType, code); break;
3134       case Bytecodes::_iinc           : increment(); break;
3135       case Bytecodes::_i2l            : convert(code, T_INT   , T_LONG  ); break;
3136       case Bytecodes::_i2f            : convert(code, T_INT   , T_FLOAT ); break;
3137       case Bytecodes::_i2d            : convert(code, T_INT   , T_DOUBLE); break;
3138       case Bytecodes::_l2i            : convert(code, T_LONG  , T_INT   ); break;
3139       case Bytecodes::_l2f            : convert(code, T_LONG  , T_FLOAT ); break;
3140       case Bytecodes::_l2d            : convert(code, T_LONG  , T_DOUBLE); break;
3141       case Bytecodes::_f2i            : convert(code, T_FLOAT , T_INT   ); break;
3142       case Bytecodes::_f2l            : convert(code, T_FLOAT , T_LONG  ); break;
3143       case Bytecodes::_f2d            : convert(code, T_FLOAT , T_DOUBLE); break;
3144       case Bytecodes::_d2i            : convert(code, T_DOUBLE, T_INT   ); break;
3145       case Bytecodes::_d2l            : convert(code, T_DOUBLE, T_LONG  ); break;
3146       case Bytecodes::_d2f            : convert(code, T_DOUBLE, T_FLOAT ); break;
3147       case Bytecodes::_i2b            : convert(code, T_INT   , T_BYTE  ); break;
3148       case Bytecodes::_i2c            : convert(code, T_INT   , T_CHAR  ); break;
3149       case Bytecodes::_i2s            : convert(code, T_INT   , T_SHORT ); break;
3150       case Bytecodes::_lcmp           : compare_op(longType  , code); break;
3151       case Bytecodes::_fcmpl          : compare_op(floatType , code); break;
3152       case Bytecodes::_fcmpg          : compare_op(floatType , code); break;
3153       case Bytecodes::_dcmpl          : compare_op(doubleType, code); break;
3154       case Bytecodes::_dcmpg          : compare_op(doubleType, code); break;
3155       case Bytecodes::_ifeq           : if_zero(intType   , If::eql); break;
3156       case Bytecodes::_ifne           : if_zero(intType   , If::neq); break;
3157       case Bytecodes::_iflt           : if_zero(intType   , If::lss); break;
3158       case Bytecodes::_ifge           : if_zero(intType   , If::geq); break;
3159       case Bytecodes::_ifgt           : if_zero(intType   , If::gtr); break;
3160       case Bytecodes::_ifle           : if_zero(intType   , If::leq); break;
3161       case Bytecodes::_if_icmpeq      : if_same(intType   , If::eql); break;
3162       case Bytecodes::_if_icmpne      : if_same(intType   , If::neq); break;
3163       case Bytecodes::_if_icmplt      : if_same(intType   , If::lss); break;
3164       case Bytecodes::_if_icmpge      : if_same(intType   , If::geq); break;
3165       case Bytecodes::_if_icmpgt      : if_same(intType   , If::gtr); break;
3166       case Bytecodes::_if_icmple      : if_same(intType   , If::leq); break;
3167       case Bytecodes::_if_acmpeq      : if_same(objectType, If::eql); break;
3168       case Bytecodes::_if_acmpne      : if_same(objectType, If::neq); break;
3169       case Bytecodes::_goto           : _goto(s.cur_bci(), s.get_dest()); break;
3170       case Bytecodes::_jsr            : jsr(s.get_dest()); break;
3171       case Bytecodes::_ret            : ret(s.get_index()); break;
3172       case Bytecodes::_tableswitch    : table_switch(); break;
3173       case Bytecodes::_lookupswitch   : lookup_switch(); break;
3174       case Bytecodes::_ireturn        : method_return(ipop(), ignore_return); break;
3175       case Bytecodes::_lreturn        : method_return(lpop(), ignore_return); break;
3176       case Bytecodes::_freturn        : method_return(fpop(), ignore_return); break;
3177       case Bytecodes::_dreturn        : method_return(dpop(), ignore_return); break;
3178       case Bytecodes::_areturn        : method_return(apop(), ignore_return); break;
3179       case Bytecodes::_return         : method_return(NULL  , ignore_return); break;
3180       case Bytecodes::_getstatic      : // fall through
3181       case Bytecodes::_putstatic      : // fall through
3182       case Bytecodes::_getfield       : // fall through
3183       case Bytecodes::_putfield       : access_field(code); break;
3184       case Bytecodes::_invokevirtual  : // fall through
3185       case Bytecodes::_invokespecial  : // fall through
3186       case Bytecodes::_invokestatic   : // fall through
3187       case Bytecodes::_invokedynamic  : // fall through
3188       case Bytecodes::_invokeinterface: invoke(code); break;
3189       case Bytecodes::_new            : new_instance(s.get_index_u2()); break;
3190       case Bytecodes::_newarray       : new_type_array(); break;
3191       case Bytecodes::_anewarray      : new_object_array(); break;
3192       case Bytecodes::_arraylength    : { ValueStack* state_before = copy_state_for_exception(); ipush(append(new ArrayLength(apop(), state_before))); break; }
3193       case Bytecodes::_athrow         : throw_op(s.cur_bci()); break;
3194       case Bytecodes::_checkcast      : check_cast(s.get_index_u2()); break;
3195       case Bytecodes::_instanceof     : instance_of(s.get_index_u2()); break;
3196       case Bytecodes::_monitorenter   : monitorenter(apop(), s.cur_bci()); break;
3197       case Bytecodes::_monitorexit    : monitorexit (apop(), s.cur_bci()); break;
3198       case Bytecodes::_wide           : ShouldNotReachHere(); break;
3199       case Bytecodes::_multianewarray : new_multi_array(s.cur_bcp()[3]); break;
3200       case Bytecodes::_ifnull         : if_null(objectType, If::eql); break;
3201       case Bytecodes::_ifnonnull      : if_null(objectType, If::neq); break;
3202       case Bytecodes::_goto_w         : _goto(s.cur_bci(), s.get_far_dest()); break;
3203       case Bytecodes::_jsr_w          : jsr(s.get_far_dest()); break;
3204       case Bytecodes::_defaultvalue   : default_value(s.get_index_u2()); break;
3205       case Bytecodes::_withfield      : withfield(s.get_index_u2()); break;
3206       case Bytecodes::_breakpoint     : BAILOUT_(&quot;concurrent setting of breakpoint&quot;, NULL);
3207       default                         : ShouldNotReachHere(); break;
3208     }
3209 
3210     if (log != NULL)
3211       log-&gt;clear_context(); // skip marker if nothing was printed
3212 
3213     // save current bci to setup Goto at the end
3214     prev_bci = s.cur_bci();
3215 
3216   }
3217   CHECK_BAILOUT_(NULL);
3218   // stop processing of this block (see try_inline_full)
3219   if (_skip_block) {
3220     _skip_block = false;
3221     assert(_last &amp;&amp; _last-&gt;as_BlockEnd(), &quot;&quot;);
3222     return _last-&gt;as_BlockEnd();
3223   }
3224   // if there are any, check if last instruction is a BlockEnd instruction
3225   BlockEnd* end = last()-&gt;as_BlockEnd();
3226   if (end == NULL) {
3227     // all blocks must end with a BlockEnd instruction =&gt; add a Goto
3228     end = new Goto(block_at(s.cur_bci()), false);
3229     append(end);
3230   }
3231   assert(end == last()-&gt;as_BlockEnd(), &quot;inconsistency&quot;);
3232 
3233   assert(end-&gt;state() != NULL, &quot;state must already be present&quot;);
3234   assert(end-&gt;as_Return() == NULL || end-&gt;as_Throw() == NULL || end-&gt;state()-&gt;stack_size() == 0, &quot;stack not needed for return and throw&quot;);
3235 
3236   // connect to begin &amp; set state
3237   // NOTE that inlining may have changed the block we are parsing
3238   block()-&gt;set_end(end);
3239   // propagate state
3240   for (int i = end-&gt;number_of_sux() - 1; i &gt;= 0; i--) {
3241     BlockBegin* sux = end-&gt;sux_at(i);
3242     assert(sux-&gt;is_predecessor(block()), &quot;predecessor missing&quot;);
3243     // be careful, bailout if bytecodes are strange
3244     if (!sux-&gt;try_merge(end-&gt;state())) BAILOUT_(&quot;block join failed&quot;, NULL);
3245     scope_data()-&gt;add_to_work_list(end-&gt;sux_at(i));
3246   }
3247 
3248   scope_data()-&gt;set_stream(NULL);
3249 
3250   // done
3251   return end;
3252 }
3253 
3254 
3255 void GraphBuilder::iterate_all_blocks(bool start_in_current_block_for_inlining) {
3256   do {
3257     if (start_in_current_block_for_inlining &amp;&amp; !bailed_out()) {
3258       iterate_bytecodes_for_block(0);
3259       start_in_current_block_for_inlining = false;
3260     } else {
3261       BlockBegin* b;
3262       while ((b = scope_data()-&gt;remove_from_work_list()) != NULL) {
3263         if (!b-&gt;is_set(BlockBegin::was_visited_flag)) {
3264           if (b-&gt;is_set(BlockBegin::osr_entry_flag)) {
3265             // we&#39;re about to parse the osr entry block, so make sure
3266             // we setup the OSR edge leading into this block so that
3267             // Phis get setup correctly.
3268             setup_osr_entry_block();
3269             // this is no longer the osr entry block, so clear it.
3270             b-&gt;clear(BlockBegin::osr_entry_flag);
3271           }
3272           b-&gt;set(BlockBegin::was_visited_flag);
3273           connect_to_end(b);
3274         }
3275       }
3276     }
3277   } while (!bailed_out() &amp;&amp; !scope_data()-&gt;is_work_list_empty());
3278 }
3279 
3280 
3281 bool GraphBuilder::_can_trap      [Bytecodes::number_of_java_codes];
3282 
3283 void GraphBuilder::initialize() {
3284   // the following bytecodes are assumed to potentially
3285   // throw exceptions in compiled code - note that e.g.
3286   // monitorexit &amp; the return bytecodes do not throw
3287   // exceptions since monitor pairing proved that they
3288   // succeed (if monitor pairing succeeded)
3289   Bytecodes::Code can_trap_list[] =
3290     { Bytecodes::_ldc
3291     , Bytecodes::_ldc_w
3292     , Bytecodes::_ldc2_w
3293     , Bytecodes::_iaload
3294     , Bytecodes::_laload
3295     , Bytecodes::_faload
3296     , Bytecodes::_daload
3297     , Bytecodes::_aaload
3298     , Bytecodes::_baload
3299     , Bytecodes::_caload
3300     , Bytecodes::_saload
3301     , Bytecodes::_iastore
3302     , Bytecodes::_lastore
3303     , Bytecodes::_fastore
3304     , Bytecodes::_dastore
3305     , Bytecodes::_aastore
3306     , Bytecodes::_bastore
3307     , Bytecodes::_castore
3308     , Bytecodes::_sastore
3309     , Bytecodes::_idiv
3310     , Bytecodes::_ldiv
3311     , Bytecodes::_irem
3312     , Bytecodes::_lrem
3313     , Bytecodes::_getstatic
3314     , Bytecodes::_putstatic
3315     , Bytecodes::_getfield
3316     , Bytecodes::_putfield
3317     , Bytecodes::_invokevirtual
3318     , Bytecodes::_invokespecial
3319     , Bytecodes::_invokestatic
3320     , Bytecodes::_invokedynamic
3321     , Bytecodes::_invokeinterface
3322     , Bytecodes::_new
3323     , Bytecodes::_newarray
3324     , Bytecodes::_anewarray
3325     , Bytecodes::_arraylength
3326     , Bytecodes::_athrow
3327     , Bytecodes::_checkcast
3328     , Bytecodes::_instanceof
3329     , Bytecodes::_monitorenter
3330     , Bytecodes::_multianewarray
3331     };
3332 
3333   // inititialize trap tables
3334   for (int i = 0; i &lt; Bytecodes::number_of_java_codes; i++) {
3335     _can_trap[i] = false;
3336   }
3337   // set standard trap info
3338   for (uint j = 0; j &lt; ARRAY_SIZE(can_trap_list); j++) {
3339     _can_trap[can_trap_list[j]] = true;
3340   }
3341 }
3342 
3343 
3344 BlockBegin* GraphBuilder::header_block(BlockBegin* entry, BlockBegin::Flag f, ValueStack* state) {
3345   assert(entry-&gt;is_set(f), &quot;entry/flag mismatch&quot;);
3346   // create header block
3347   BlockBegin* h = new BlockBegin(entry-&gt;bci());
3348   h-&gt;set_depth_first_number(0);
3349 
3350   Value l = h;
3351   BlockEnd* g = new Goto(entry, false);
3352   l-&gt;set_next(g, entry-&gt;bci());
3353   h-&gt;set_end(g);
3354   h-&gt;set(f);
3355   // setup header block end state
3356   ValueStack* s = state-&gt;copy(ValueStack::StateAfter, entry-&gt;bci()); // can use copy since stack is empty (=&gt; no phis)
3357   assert(s-&gt;stack_is_empty(), &quot;must have empty stack at entry point&quot;);
3358   g-&gt;set_state(s);
3359   return h;
3360 }
3361 
3362 
3363 
3364 BlockBegin* GraphBuilder::setup_start_block(int osr_bci, BlockBegin* std_entry, BlockBegin* osr_entry, ValueStack* state) {
3365   BlockBegin* start = new BlockBegin(0);
3366 
3367   // This code eliminates the empty start block at the beginning of
3368   // each method.  Previously, each method started with the
3369   // start-block created below, and this block was followed by the
3370   // header block that was always empty.  This header block is only
3371   // necesary if std_entry is also a backward branch target because
3372   // then phi functions may be necessary in the header block.  It&#39;s
3373   // also necessary when profiling so that there&#39;s a single block that
3374   // can increment the interpreter_invocation_count.
3375   BlockBegin* new_header_block;
3376   if (std_entry-&gt;number_of_preds() &gt; 0 || count_invocations() || count_backedges()) {
3377     new_header_block = header_block(std_entry, BlockBegin::std_entry_flag, state);
3378   } else {
3379     new_header_block = std_entry;
3380   }
3381 
3382   // setup start block (root for the IR graph)
3383   Base* base =
3384     new Base(
3385       new_header_block,
3386       osr_entry
3387     );
3388   start-&gt;set_next(base, 0);
3389   start-&gt;set_end(base);
3390   // create &amp; setup state for start block
3391   start-&gt;set_state(state-&gt;copy(ValueStack::StateAfter, std_entry-&gt;bci()));
3392   base-&gt;set_state(state-&gt;copy(ValueStack::StateAfter, std_entry-&gt;bci()));
3393 
3394   if (base-&gt;std_entry()-&gt;state() == NULL) {
3395     // setup states for header blocks
3396     base-&gt;std_entry()-&gt;merge(state);
3397   }
3398 
3399   assert(base-&gt;std_entry()-&gt;state() != NULL, &quot;&quot;);
3400   return start;
3401 }
3402 
3403 
3404 void GraphBuilder::setup_osr_entry_block() {
3405   assert(compilation()-&gt;is_osr_compile(), &quot;only for osrs&quot;);
3406 
3407   int osr_bci = compilation()-&gt;osr_bci();
3408   ciBytecodeStream s(method());
3409   s.reset_to_bci(osr_bci);
3410   s.next();
3411   scope_data()-&gt;set_stream(&amp;s);
3412 
3413   // create a new block to be the osr setup code
3414   _osr_entry = new BlockBegin(osr_bci);
3415   _osr_entry-&gt;set(BlockBegin::osr_entry_flag);
3416   _osr_entry-&gt;set_depth_first_number(0);
3417   BlockBegin* target = bci2block()-&gt;at(osr_bci);
3418   assert(target != NULL &amp;&amp; target-&gt;is_set(BlockBegin::osr_entry_flag), &quot;must be there&quot;);
3419   // the osr entry has no values for locals
3420   ValueStack* state = target-&gt;state()-&gt;copy();
3421   _osr_entry-&gt;set_state(state);
3422 
3423   kill_all();
3424   _block = _osr_entry;
3425   _state = _osr_entry-&gt;state()-&gt;copy();
3426   assert(_state-&gt;bci() == osr_bci, &quot;mismatch&quot;);
3427   _last  = _osr_entry;
3428   Value e = append(new OsrEntry());
3429   e-&gt;set_needs_null_check(false);
3430 
3431   // OSR buffer is
3432   //
3433   // locals[nlocals-1..0]
3434   // monitors[number_of_locks-1..0]
3435   //
3436   // locals is a direct copy of the interpreter frame so in the osr buffer
3437   // so first slot in the local array is the last local from the interpreter
3438   // and last slot is local[0] (receiver) from the interpreter
3439   //
3440   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
3441   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
3442   // in the interpreter frame (the method lock if a sync method)
3443 
3444   // Initialize monitors in the compiled activation.
3445 
3446   int index;
3447   Value local;
3448 
3449   // find all the locals that the interpreter thinks contain live oops
3450   const ResourceBitMap live_oops = method()-&gt;live_local_oops_at_bci(osr_bci);
3451 
3452   // compute the offset into the locals so that we can treat the buffer
3453   // as if the locals were still in the interpreter frame
3454   int locals_offset = BytesPerWord * (method()-&gt;max_locals() - 1);
3455   for_each_local_value(state, index, local) {
3456     int offset = locals_offset - (index + local-&gt;type()-&gt;size() - 1) * BytesPerWord;
3457     Value get;
3458     if (local-&gt;type()-&gt;is_object_kind() &amp;&amp; !live_oops.at(index)) {
3459       // The interpreter thinks this local is dead but the compiler
3460       // doesn&#39;t so pretend that the interpreter passed in null.
3461       get = append(new Constant(objectNull));
3462     } else {
3463       get = append(new UnsafeGetRaw(as_BasicType(local-&gt;type()), e,
3464                                     append(new Constant(new IntConstant(offset))),
3465                                     0,
3466                                     true /*unaligned*/, true /*wide*/));
3467     }
3468     _state-&gt;store_local(index, get);
3469   }
3470 
3471   // the storage for the OSR buffer is freed manually in the LIRGenerator.
3472 
3473   assert(state-&gt;caller_state() == NULL, &quot;should be top scope&quot;);
3474   state-&gt;clear_locals();
3475   Goto* g = new Goto(target, false);
3476   append(g);
3477   _osr_entry-&gt;set_end(g);
3478   target-&gt;merge(_osr_entry-&gt;end()-&gt;state());
3479 
3480   scope_data()-&gt;set_stream(NULL);
3481 }
3482 
3483 
3484 ValueStack* GraphBuilder::state_at_entry() {
3485   ValueStack* state = new ValueStack(scope(), NULL);
3486 
3487   // Set up locals for receiver
3488   int idx = 0;
3489   if (!method()-&gt;is_static()) {
3490     // we should always see the receiver
3491     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx,
3492              /*receiver*/ true, /*null_free*/ method()-&gt;holder()-&gt;is_flat_array_klass()));
3493     idx = 1;
3494   }
3495 
3496   // Set up locals for incoming arguments
3497   ciSignature* sig = method()-&gt;signature();
3498   for (int i = 0; i &lt; sig-&gt;count(); i++) {
3499     ciType* type = sig-&gt;type_at(i);
3500     BasicType basic_type = type-&gt;basic_type();
3501     // don&#39;t allow T_ARRAY to propagate into locals types
3502     if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3503     ValueType* vt = as_ValueType(basic_type);
3504     state-&gt;store_local(idx, new Local(type, vt, idx, false, type-&gt;is_inlinetype()));
3505     idx += type-&gt;size();
3506   }
3507 
3508   // lock synchronized method
3509   if (method()-&gt;is_synchronized()) {
3510     state-&gt;lock(NULL);
3511   }
3512 
3513   return state;
3514 }
3515 
3516 
3517 GraphBuilder::GraphBuilder(Compilation* compilation, IRScope* scope)
3518   : _scope_data(NULL)
3519   , _compilation(compilation)
3520   , _memory(new MemoryBuffer())
3521   , _inline_bailout_msg(NULL)
3522   , _instruction_count(0)
3523   , _osr_entry(NULL)
<a name="4" id="anc4"></a><span class="line-added">3524   , _delayed_flattened_field_access(NULL)</span>
3525 {
3526   int osr_bci = compilation-&gt;osr_bci();
3527 
3528   // determine entry points and bci2block mapping
3529   BlockListBuilder blm(compilation, scope, osr_bci);
3530   CHECK_BAILOUT();
3531 
3532   BlockList* bci2block = blm.bci2block();
3533   BlockBegin* start_block = bci2block-&gt;at(0);
3534 
3535   push_root_scope(scope, bci2block, start_block);
3536 
3537   // setup state for std entry
3538   _initial_state = state_at_entry();
3539   start_block-&gt;merge(_initial_state);
3540 
3541   // complete graph
3542   _vmap        = new ValueMap();
3543   switch (scope-&gt;method()-&gt;intrinsic_id()) {
3544   case vmIntrinsics::_dabs          : // fall through
3545   case vmIntrinsics::_dsqrt         : // fall through
3546   case vmIntrinsics::_dsin          : // fall through
3547   case vmIntrinsics::_dcos          : // fall through
3548   case vmIntrinsics::_dtan          : // fall through
3549   case vmIntrinsics::_dlog          : // fall through
3550   case vmIntrinsics::_dlog10        : // fall through
3551   case vmIntrinsics::_dexp          : // fall through
3552   case vmIntrinsics::_dpow          : // fall through
3553     {
3554       // Compiles where the root method is an intrinsic need a special
3555       // compilation environment because the bytecodes for the method
3556       // shouldn&#39;t be parsed during the compilation, only the special
3557       // Intrinsic node should be emitted.  If this isn&#39;t done the the
3558       // code for the inlined version will be different than the root
3559       // compiled version which could lead to monotonicity problems on
3560       // intel.
3561       if (CheckIntrinsics &amp;&amp; !scope-&gt;method()-&gt;intrinsic_candidate()) {
3562         BAILOUT(&quot;failed to inline intrinsic, method not annotated&quot;);
3563       }
3564 
3565       // Set up a stream so that appending instructions works properly.
3566       ciBytecodeStream s(scope-&gt;method());
3567       s.reset_to_bci(0);
3568       scope_data()-&gt;set_stream(&amp;s);
3569       s.next();
3570 
3571       // setup the initial block state
3572       _block = start_block;
3573       _state = start_block-&gt;state()-&gt;copy_for_parsing();
3574       _last  = start_block;
3575       load_local(doubleType, 0);
3576       if (scope-&gt;method()-&gt;intrinsic_id() == vmIntrinsics::_dpow) {
3577         load_local(doubleType, 2);
3578       }
3579 
3580       // Emit the intrinsic node.
3581       bool result = try_inline_intrinsics(scope-&gt;method());
3582       if (!result) BAILOUT(&quot;failed to inline intrinsic&quot;);
3583       method_return(dpop());
3584 
3585       // connect the begin and end blocks and we&#39;re all done.
3586       BlockEnd* end = last()-&gt;as_BlockEnd();
3587       block()-&gt;set_end(end);
3588       break;
3589     }
3590 
3591   case vmIntrinsics::_Reference_get:
3592     {
3593       {
3594         // With java.lang.ref.reference.get() we must go through the
3595         // intrinsic - when G1 is enabled - even when get() is the root
3596         // method of the compile so that, if necessary, the value in
3597         // the referent field of the reference object gets recorded by
3598         // the pre-barrier code.
3599         // Specifically, if G1 is enabled, the value in the referent
3600         // field is recorded by the G1 SATB pre barrier. This will
3601         // result in the referent being marked live and the reference
3602         // object removed from the list of discovered references during
3603         // reference processing.
3604         if (CheckIntrinsics &amp;&amp; !scope-&gt;method()-&gt;intrinsic_candidate()) {
3605           BAILOUT(&quot;failed to inline intrinsic, method not annotated&quot;);
3606         }
3607 
3608         // Also we need intrinsic to prevent commoning reads from this field
3609         // across safepoint since GC can change its value.
3610 
3611         // Set up a stream so that appending instructions works properly.
3612         ciBytecodeStream s(scope-&gt;method());
3613         s.reset_to_bci(0);
3614         scope_data()-&gt;set_stream(&amp;s);
3615         s.next();
3616 
3617         // setup the initial block state
3618         _block = start_block;
3619         _state = start_block-&gt;state()-&gt;copy_for_parsing();
3620         _last  = start_block;
3621         load_local(objectType, 0);
3622 
3623         // Emit the intrinsic node.
3624         bool result = try_inline_intrinsics(scope-&gt;method());
3625         if (!result) BAILOUT(&quot;failed to inline intrinsic&quot;);
3626         method_return(apop());
3627 
3628         // connect the begin and end blocks and we&#39;re all done.
3629         BlockEnd* end = last()-&gt;as_BlockEnd();
3630         block()-&gt;set_end(end);
3631         break;
3632       }
3633       // Otherwise, fall thru
3634     }
3635 
3636   default:
3637     scope_data()-&gt;add_to_work_list(start_block);
3638     iterate_all_blocks();
3639     break;
3640   }
3641   CHECK_BAILOUT();
3642 
3643   _start = setup_start_block(osr_bci, start_block, _osr_entry, _initial_state);
3644 
3645   eliminate_redundant_phis(_start);
3646 
3647   NOT_PRODUCT(if (PrintValueNumbering &amp;&amp; Verbose) print_stats());
3648   // for osr compile, bailout if some requirements are not fulfilled
3649   if (osr_bci != -1) {
3650     BlockBegin* osr_block = blm.bci2block()-&gt;at(osr_bci);
3651     if (!osr_block-&gt;is_set(BlockBegin::was_visited_flag)) {
3652       BAILOUT(&quot;osr entry must have been visited for osr compile&quot;);
3653     }
3654 
3655     // check if osr entry point has empty stack - we cannot handle non-empty stacks at osr entry points
3656     if (!osr_block-&gt;state()-&gt;stack_is_empty()) {
3657       BAILOUT(&quot;stack not empty at OSR entry point&quot;);
3658     }
3659   }
3660 #ifndef PRODUCT
3661   if (PrintCompilation &amp;&amp; Verbose) tty-&gt;print_cr(&quot;Created %d Instructions&quot;, _instruction_count);
3662 #endif
3663 }
3664 
3665 
3666 ValueStack* GraphBuilder::copy_state_before() {
3667   return copy_state_before_with_bci(bci());
3668 }
3669 
3670 ValueStack* GraphBuilder::copy_state_exhandling() {
3671   return copy_state_exhandling_with_bci(bci());
3672 }
3673 
3674 ValueStack* GraphBuilder::copy_state_for_exception() {
3675   return copy_state_for_exception_with_bci(bci());
3676 }
3677 
3678 ValueStack* GraphBuilder::copy_state_before_with_bci(int bci) {
3679   return state()-&gt;copy(ValueStack::StateBefore, bci);
3680 }
3681 
3682 ValueStack* GraphBuilder::copy_state_exhandling_with_bci(int bci) {
3683   if (!has_handler()) return NULL;
3684   return state()-&gt;copy(ValueStack::StateBefore, bci);
3685 }
3686 
3687 ValueStack* GraphBuilder::copy_state_for_exception_with_bci(int bci) {
3688   ValueStack* s = copy_state_exhandling_with_bci(bci);
3689   if (s == NULL) {
3690     if (_compilation-&gt;env()-&gt;should_retain_local_variables()) {
3691       s = state()-&gt;copy(ValueStack::ExceptionState, bci);
3692     } else {
3693       s = state()-&gt;copy(ValueStack::EmptyExceptionState, bci);
3694     }
3695   }
3696   return s;
3697 }
3698 
3699 int GraphBuilder::recursive_inline_level(ciMethod* cur_callee) const {
3700   int recur_level = 0;
3701   for (IRScope* s = scope(); s != NULL; s = s-&gt;caller()) {
3702     if (s-&gt;method() == cur_callee) {
3703       ++recur_level;
3704     }
3705   }
3706   return recur_level;
3707 }
3708 
3709 
3710 bool GraphBuilder::try_inline(ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc, Value receiver) {
3711   const char* msg = NULL;
3712 
3713   // clear out any existing inline bailout condition
3714   clear_inline_bailout();
3715 
3716   // exclude methods we don&#39;t want to inline
3717   msg = should_not_inline(callee);
3718   if (msg != NULL) {
3719     print_inlining(callee, msg, /*success*/ false);
3720     return false;
3721   }
3722 
3723   // method handle invokes
3724   if (callee-&gt;is_method_handle_intrinsic()) {
3725     if (try_method_handle_inline(callee, ignore_return)) {
3726       if (callee-&gt;has_reserved_stack_access()) {
3727         compilation()-&gt;set_has_reserved_stack_access(true);
3728       }
3729       return true;
3730     }
3731     return false;
3732   }
3733 
3734   // handle intrinsics
3735   if (callee-&gt;intrinsic_id() != vmIntrinsics::_none &amp;&amp;
3736       (CheckIntrinsics ? callee-&gt;intrinsic_candidate() : true)) {
3737     if (try_inline_intrinsics(callee, ignore_return)) {
3738       print_inlining(callee, &quot;intrinsic&quot;);
3739       if (callee-&gt;has_reserved_stack_access()) {
3740         compilation()-&gt;set_has_reserved_stack_access(true);
3741       }
3742       return true;
3743     }
3744     // try normal inlining
3745   }
3746 
3747   // certain methods cannot be parsed at all
3748   msg = check_can_parse(callee);
3749   if (msg != NULL) {
3750     print_inlining(callee, msg, /*success*/ false);
3751     return false;
3752   }
3753 
3754   // If bytecode not set use the current one.
3755   if (bc == Bytecodes::_illegal) {
3756     bc = code();
3757   }
3758   if (try_inline_full(callee, holder_known, ignore_return, bc, receiver)) {
3759     if (callee-&gt;has_reserved_stack_access()) {
3760       compilation()-&gt;set_has_reserved_stack_access(true);
3761     }
3762     return true;
3763   }
3764 
3765   // Entire compilation could fail during try_inline_full call.
3766   // In that case printing inlining decision info is useless.
3767   if (!bailed_out())
3768     print_inlining(callee, _inline_bailout_msg, /*success*/ false);
3769 
3770   return false;
3771 }
3772 
3773 
3774 const char* GraphBuilder::check_can_parse(ciMethod* callee) const {
3775   // Certain methods cannot be parsed at all:
3776   if ( callee-&gt;is_native())            return &quot;native method&quot;;
3777   if ( callee-&gt;is_abstract())          return &quot;abstract method&quot;;
3778   if (!callee-&gt;can_be_compiled())      return &quot;not compilable (disabled)&quot;;
3779   if (!callee-&gt;can_be_parsed())        return &quot;cannot be parsed&quot;;
3780   return NULL;
3781 }
3782 
3783 // negative filter: should callee NOT be inlined?  returns NULL, ok to inline, or rejection msg
3784 const char* GraphBuilder::should_not_inline(ciMethod* callee) const {
3785   if ( compilation()-&gt;directive()-&gt;should_not_inline(callee)) return &quot;disallowed by CompileCommand&quot;;
3786   if ( callee-&gt;dont_inline())          return &quot;don&#39;t inline by annotation&quot;;
3787   return NULL;
3788 }
3789 
3790 void GraphBuilder::build_graph_for_intrinsic(ciMethod* callee, bool ignore_return) {
3791   vmIntrinsics::ID id = callee-&gt;intrinsic_id();
3792   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
3793 
3794   // Some intrinsics need special IR nodes.
3795   switch(id) {
3796   case vmIntrinsics::_getReference       : append_unsafe_get_obj(callee, T_OBJECT,  false); return;
3797   case vmIntrinsics::_getBoolean         : append_unsafe_get_obj(callee, T_BOOLEAN, false); return;
3798   case vmIntrinsics::_getByte            : append_unsafe_get_obj(callee, T_BYTE,    false); return;
3799   case vmIntrinsics::_getShort           : append_unsafe_get_obj(callee, T_SHORT,   false); return;
3800   case vmIntrinsics::_getChar            : append_unsafe_get_obj(callee, T_CHAR,    false); return;
3801   case vmIntrinsics::_getInt             : append_unsafe_get_obj(callee, T_INT,     false); return;
3802   case vmIntrinsics::_getLong            : append_unsafe_get_obj(callee, T_LONG,    false); return;
3803   case vmIntrinsics::_getFloat           : append_unsafe_get_obj(callee, T_FLOAT,   false); return;
3804   case vmIntrinsics::_getDouble          : append_unsafe_get_obj(callee, T_DOUBLE,  false); return;
3805   case vmIntrinsics::_putReference       : append_unsafe_put_obj(callee, T_OBJECT,  false); return;
3806   case vmIntrinsics::_putBoolean         : append_unsafe_put_obj(callee, T_BOOLEAN, false); return;
3807   case vmIntrinsics::_putByte            : append_unsafe_put_obj(callee, T_BYTE,    false); return;
3808   case vmIntrinsics::_putShort           : append_unsafe_put_obj(callee, T_SHORT,   false); return;
3809   case vmIntrinsics::_putChar            : append_unsafe_put_obj(callee, T_CHAR,    false); return;
3810   case vmIntrinsics::_putInt             : append_unsafe_put_obj(callee, T_INT,     false); return;
3811   case vmIntrinsics::_putLong            : append_unsafe_put_obj(callee, T_LONG,    false); return;
3812   case vmIntrinsics::_putFloat           : append_unsafe_put_obj(callee, T_FLOAT,   false); return;
3813   case vmIntrinsics::_putDouble          : append_unsafe_put_obj(callee, T_DOUBLE,  false); return;
3814   case vmIntrinsics::_getShortUnaligned  : append_unsafe_get_obj(callee, T_SHORT,   false); return;
3815   case vmIntrinsics::_getCharUnaligned   : append_unsafe_get_obj(callee, T_CHAR,    false); return;
3816   case vmIntrinsics::_getIntUnaligned    : append_unsafe_get_obj(callee, T_INT,     false); return;
3817   case vmIntrinsics::_getLongUnaligned   : append_unsafe_get_obj(callee, T_LONG,    false); return;
3818   case vmIntrinsics::_putShortUnaligned  : append_unsafe_put_obj(callee, T_SHORT,   false); return;
3819   case vmIntrinsics::_putCharUnaligned   : append_unsafe_put_obj(callee, T_CHAR,    false); return;
3820   case vmIntrinsics::_putIntUnaligned    : append_unsafe_put_obj(callee, T_INT,     false); return;
3821   case vmIntrinsics::_putLongUnaligned   : append_unsafe_put_obj(callee, T_LONG,    false); return;
3822   case vmIntrinsics::_getReferenceVolatile  : append_unsafe_get_obj(callee, T_OBJECT,  true); return;
3823   case vmIntrinsics::_getBooleanVolatile : append_unsafe_get_obj(callee, T_BOOLEAN, true); return;
3824   case vmIntrinsics::_getByteVolatile    : append_unsafe_get_obj(callee, T_BYTE,    true); return;
3825   case vmIntrinsics::_getShortVolatile   : append_unsafe_get_obj(callee, T_SHORT,   true); return;
3826   case vmIntrinsics::_getCharVolatile    : append_unsafe_get_obj(callee, T_CHAR,    true); return;
3827   case vmIntrinsics::_getIntVolatile     : append_unsafe_get_obj(callee, T_INT,     true); return;
3828   case vmIntrinsics::_getLongVolatile    : append_unsafe_get_obj(callee, T_LONG,    true); return;
3829   case vmIntrinsics::_getFloatVolatile   : append_unsafe_get_obj(callee, T_FLOAT,   true); return;
3830   case vmIntrinsics::_getDoubleVolatile  : append_unsafe_get_obj(callee, T_DOUBLE,  true); return;
3831   case vmIntrinsics::_putReferenceVolatile : append_unsafe_put_obj(callee, T_OBJECT,  true); return;
3832   case vmIntrinsics::_putBooleanVolatile : append_unsafe_put_obj(callee, T_BOOLEAN, true); return;
3833   case vmIntrinsics::_putByteVolatile    : append_unsafe_put_obj(callee, T_BYTE,    true); return;
3834   case vmIntrinsics::_putShortVolatile   : append_unsafe_put_obj(callee, T_SHORT,   true); return;
3835   case vmIntrinsics::_putCharVolatile    : append_unsafe_put_obj(callee, T_CHAR,    true); return;
3836   case vmIntrinsics::_putIntVolatile     : append_unsafe_put_obj(callee, T_INT,     true); return;
3837   case vmIntrinsics::_putLongVolatile    : append_unsafe_put_obj(callee, T_LONG,    true); return;
3838   case vmIntrinsics::_putFloatVolatile   : append_unsafe_put_obj(callee, T_FLOAT,   true); return;
3839   case vmIntrinsics::_putDoubleVolatile  : append_unsafe_put_obj(callee, T_DOUBLE,  true); return;
3840   case vmIntrinsics::_compareAndSetLong:
3841   case vmIntrinsics::_compareAndSetInt:
3842   case vmIntrinsics::_compareAndSetReference : append_unsafe_CAS(callee); return;
3843   case vmIntrinsics::_getAndAddInt:
3844   case vmIntrinsics::_getAndAddLong      : append_unsafe_get_and_set_obj(callee, true); return;
3845   case vmIntrinsics::_getAndSetInt       :
3846   case vmIntrinsics::_getAndSetLong      :
3847   case vmIntrinsics::_getAndSetReference : append_unsafe_get_and_set_obj(callee, false); return;
3848   case vmIntrinsics::_getCharStringU     : append_char_access(callee, false); return;
3849   case vmIntrinsics::_putCharStringU     : append_char_access(callee, true); return;
3850   default:
3851     break;
3852   }
3853 
3854   // create intrinsic node
3855   const bool has_receiver = !callee-&gt;is_static();
3856   ValueType* result_type = as_ValueType(callee-&gt;return_type());
3857   ValueStack* state_before = copy_state_for_exception();
3858 
3859   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
3860 
3861   if (is_profiling()) {
3862     // Don&#39;t profile in the special case where the root method
3863     // is the intrinsic
3864     if (callee != method()) {
3865       // Note that we&#39;d collect profile data in this method if we wanted it.
3866       compilation()-&gt;set_would_profile(true);
3867       if (profile_calls()) {
3868         Value recv = NULL;
3869         if (has_receiver) {
3870           recv = args-&gt;at(0);
3871           null_check(recv);
3872         }
3873         profile_call(callee, recv, NULL, collect_args_for_profiling(args, callee, true), true);
3874       }
3875     }
3876   }
3877 
3878   Intrinsic* result = new Intrinsic(result_type, callee-&gt;intrinsic_id(),
3879                                     args, has_receiver, state_before,
3880                                     vmIntrinsics::preserves_state(id),
3881                                     vmIntrinsics::can_trap(id));
3882   // append instruction &amp; push result
3883   Value value = append_split(result);
3884   if (result_type != voidType &amp;&amp; !ignore_return) {
3885     push(result_type, value);
3886   }
3887 
3888   if (callee != method() &amp;&amp; profile_return() &amp;&amp; result_type-&gt;is_object_kind()) {
3889     profile_return_type(result, callee);
3890   }
3891 }
3892 
3893 bool GraphBuilder::try_inline_intrinsics(ciMethod* callee, bool ignore_return) {
3894   // For calling is_intrinsic_available we need to transition to
3895   // the &#39;_thread_in_vm&#39; state because is_intrinsic_available()
3896   // accesses critical VM-internal data.
3897   bool is_available = false;
3898   {
3899     VM_ENTRY_MARK;
3900     methodHandle mh(THREAD, callee-&gt;get_Method());
3901     is_available = _compilation-&gt;compiler()-&gt;is_intrinsic_available(mh, _compilation-&gt;directive());
3902   }
3903 
3904   if (!is_available) {
3905     if (!InlineNatives) {
3906       // Return false and also set message that the inlining of
3907       // intrinsics has been disabled in general.
3908       INLINE_BAILOUT(&quot;intrinsic method inlining disabled&quot;);
3909     } else {
3910       return false;
3911     }
3912   }
3913   build_graph_for_intrinsic(callee, ignore_return);
3914   return true;
3915 }
3916 
3917 
3918 bool GraphBuilder::try_inline_jsr(int jsr_dest_bci) {
3919   // Introduce a new callee continuation point - all Ret instructions
3920   // will be replaced with Gotos to this point.
3921   BlockBegin* cont = block_at(next_bci());
3922   assert(cont != NULL, &quot;continuation must exist (BlockListBuilder starts a new block after a jsr&quot;);
3923 
3924   // Note: can not assign state to continuation yet, as we have to
3925   // pick up the state from the Ret instructions.
3926 
3927   // Push callee scope
3928   push_scope_for_jsr(cont, jsr_dest_bci);
3929 
3930   // Temporarily set up bytecode stream so we can append instructions
3931   // (only using the bci of this stream)
3932   scope_data()-&gt;set_stream(scope_data()-&gt;parent()-&gt;stream());
3933 
3934   BlockBegin* jsr_start_block = block_at(jsr_dest_bci);
3935   assert(jsr_start_block != NULL, &quot;jsr start block must exist&quot;);
3936   assert(!jsr_start_block-&gt;is_set(BlockBegin::was_visited_flag), &quot;should not have visited jsr yet&quot;);
3937   Goto* goto_sub = new Goto(jsr_start_block, false);
3938   // Must copy state to avoid wrong sharing when parsing bytecodes
3939   assert(jsr_start_block-&gt;state() == NULL, &quot;should have fresh jsr starting block&quot;);
3940   jsr_start_block-&gt;set_state(copy_state_before_with_bci(jsr_dest_bci));
3941   append(goto_sub);
3942   _block-&gt;set_end(goto_sub);
3943   _last = _block = jsr_start_block;
3944 
3945   // Clear out bytecode stream
3946   scope_data()-&gt;set_stream(NULL);
3947 
3948   scope_data()-&gt;add_to_work_list(jsr_start_block);
3949 
3950   // Ready to resume parsing in subroutine
3951   iterate_all_blocks();
3952 
3953   // If we bailed out during parsing, return immediately (this is bad news)
3954   CHECK_BAILOUT_(false);
3955 
3956   // Detect whether the continuation can actually be reached. If not,
3957   // it has not had state set by the join() operations in
3958   // iterate_bytecodes_for_block()/ret() and we should not touch the
3959   // iteration state. The calling activation of
3960   // iterate_bytecodes_for_block will then complete normally.
3961   if (cont-&gt;state() != NULL) {
3962     if (!cont-&gt;is_set(BlockBegin::was_visited_flag)) {
3963       // add continuation to work list instead of parsing it immediately
3964       scope_data()-&gt;parent()-&gt;add_to_work_list(cont);
3965     }
3966   }
3967 
3968   assert(jsr_continuation() == cont, &quot;continuation must not have changed&quot;);
3969   assert(!jsr_continuation()-&gt;is_set(BlockBegin::was_visited_flag) ||
3970          jsr_continuation()-&gt;is_set(BlockBegin::parser_loop_header_flag),
3971          &quot;continuation can only be visited in case of backward branches&quot;);
3972   assert(_last &amp;&amp; _last-&gt;as_BlockEnd(), &quot;block must have end&quot;);
3973 
3974   // continuation is in work list, so end iteration of current block
3975   _skip_block = true;
3976   pop_scope_for_jsr();
3977 
3978   return true;
3979 }
3980 
3981 
3982 // Inline the entry of a synchronized method as a monitor enter and
3983 // register the exception handler which releases the monitor if an
3984 // exception is thrown within the callee. Note that the monitor enter
3985 // cannot throw an exception itself, because the receiver is
3986 // guaranteed to be non-null by the explicit null check at the
3987 // beginning of inlining.
3988 void GraphBuilder::inline_sync_entry(Value lock, BlockBegin* sync_handler) {
3989   assert(lock != NULL &amp;&amp; sync_handler != NULL, &quot;lock or handler missing&quot;);
3990 
3991   monitorenter(lock, SynchronizationEntryBCI);
3992   assert(_last-&gt;as_MonitorEnter() != NULL, &quot;monitor enter expected&quot;);
3993   _last-&gt;set_needs_null_check(false);
3994 
3995   sync_handler-&gt;set(BlockBegin::exception_entry_flag);
3996   sync_handler-&gt;set(BlockBegin::is_on_work_list_flag);
3997 
3998   ciExceptionHandler* desc = new ciExceptionHandler(method()-&gt;holder(), 0, method()-&gt;code_size(), -1, 0);
3999   XHandler* h = new XHandler(desc);
4000   h-&gt;set_entry_block(sync_handler);
4001   scope_data()-&gt;xhandlers()-&gt;append(h);
4002   scope_data()-&gt;set_has_handler();
4003 }
4004 
4005 
4006 // If an exception is thrown and not handled within an inlined
4007 // synchronized method, the monitor must be released before the
4008 // exception is rethrown in the outer scope. Generate the appropriate
4009 // instructions here.
4010 void GraphBuilder::fill_sync_handler(Value lock, BlockBegin* sync_handler, bool default_handler) {
4011   BlockBegin* orig_block = _block;
4012   ValueStack* orig_state = _state;
4013   Instruction* orig_last = _last;
4014   _last = _block = sync_handler;
4015   _state = sync_handler-&gt;state()-&gt;copy();
4016 
4017   assert(sync_handler != NULL, &quot;handler missing&quot;);
4018   assert(!sync_handler-&gt;is_set(BlockBegin::was_visited_flag), &quot;is visited here&quot;);
4019 
4020   assert(lock != NULL || default_handler, &quot;lock or handler missing&quot;);
4021 
4022   XHandler* h = scope_data()-&gt;xhandlers()-&gt;remove_last();
4023   assert(h-&gt;entry_block() == sync_handler, &quot;corrupt list of handlers&quot;);
4024 
4025   block()-&gt;set(BlockBegin::was_visited_flag);
4026   Value exception = append_with_bci(new ExceptionObject(), SynchronizationEntryBCI);
4027   assert(exception-&gt;is_pinned(), &quot;must be&quot;);
4028 
4029   int bci = SynchronizationEntryBCI;
4030   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
4031     // Report exit from inline methods.  We don&#39;t have a stream here
4032     // so pass an explicit bci of SynchronizationEntryBCI.
4033     Values* args = new Values(1);
4034     args-&gt;push(append_with_bci(new Constant(new MethodConstant(method())), bci));
4035     append_with_bci(new RuntimeCall(voidType, &quot;dtrace_method_exit&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), args), bci);
4036   }
4037 
4038   if (lock) {
4039     assert(state()-&gt;locks_size() &gt; 0 &amp;&amp; state()-&gt;lock_at(state()-&gt;locks_size() - 1) == lock, &quot;lock is missing&quot;);
4040     if (!lock-&gt;is_linked()) {
4041       lock = append_with_bci(lock, bci);
4042     }
4043 
4044     // exit the monitor in the context of the synchronized method
4045     monitorexit(lock, bci);
4046 
4047     // exit the context of the synchronized method
4048     if (!default_handler) {
4049       pop_scope();
4050       bci = _state-&gt;caller_state()-&gt;bci();
4051       _state = _state-&gt;caller_state()-&gt;copy_for_parsing();
4052     }
4053   }
4054 
4055   // perform the throw as if at the the call site
4056   apush(exception);
4057   throw_op(bci);
4058 
4059   BlockEnd* end = last()-&gt;as_BlockEnd();
4060   block()-&gt;set_end(end);
4061 
4062   _block = orig_block;
4063   _state = orig_state;
4064   _last = orig_last;
4065 }
4066 
4067 
4068 bool GraphBuilder::try_inline_full(ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc, Value receiver) {
4069   assert(!callee-&gt;is_native(), &quot;callee must not be native&quot;);
4070   if (CompilationPolicy::policy()-&gt;should_not_inline(compilation()-&gt;env(), callee)) {
4071     INLINE_BAILOUT(&quot;inlining prohibited by policy&quot;);
4072   }
4073   // first perform tests of things it&#39;s not possible to inline
4074   if (callee-&gt;has_exception_handlers() &amp;&amp;
4075       !InlineMethodsWithExceptionHandlers) INLINE_BAILOUT(&quot;callee has exception handlers&quot;);
4076   if (callee-&gt;is_synchronized() &amp;&amp;
4077       !InlineSynchronizedMethods         ) INLINE_BAILOUT(&quot;callee is synchronized&quot;);
4078   if (!callee-&gt;holder()-&gt;is_initialized()) INLINE_BAILOUT(&quot;callee&#39;s klass not initialized yet&quot;);
4079   if (!callee-&gt;has_balanced_monitors())    INLINE_BAILOUT(&quot;callee&#39;s monitors do not match&quot;);
4080 
4081   // Proper inlining of methods with jsrs requires a little more work.
4082   if (callee-&gt;has_jsrs()                 ) INLINE_BAILOUT(&quot;jsrs not handled properly by inliner yet&quot;);
4083 
4084   if (strict_fp_requires_explicit_rounding &amp;&amp;
4085       method()-&gt;is_strict() != callee-&gt;is_strict()) {
4086 #ifdef IA32
4087     // If explicit rounding is required, do not inline strict code into non-strict code (or the reverse).
4088     // When SSE2 is present, no special handling is needed.
4089     if (UseSSE &lt; 2) {
4090       INLINE_BAILOUT(&quot;caller and callee have different strict fp requirements&quot;);
4091     }
4092 #else
4093     Unimplemented();
4094 #endif // IA32
4095   }
4096 
4097   if (is_profiling() &amp;&amp; !callee-&gt;ensure_method_data()) {
4098     INLINE_BAILOUT(&quot;mdo allocation failed&quot;);
4099   }
4100 
4101   const bool is_invokedynamic = (bc == Bytecodes::_invokedynamic);
4102   const bool has_receiver = (bc != Bytecodes::_invokestatic &amp;&amp; !is_invokedynamic);
4103 
4104   const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();
4105   assert(args_base &gt;= 0, &quot;stack underflow during inlining&quot;);
4106 
4107   Value recv = NULL;
4108   if (has_receiver) {
4109     assert(!callee-&gt;is_static(), &quot;callee must not be static&quot;);
4110     assert(callee-&gt;arg_size() &gt; 0, &quot;must have at least a receiver&quot;);
4111 
4112     recv = state()-&gt;stack_at(args_base);
4113     if (recv-&gt;is_null_obj()) {
4114       INLINE_BAILOUT(&quot;receiver is always null&quot;);
4115     }
4116   }
4117 
4118   // now perform tests that are based on flag settings
4119   bool inlinee_by_directive = compilation()-&gt;directive()-&gt;should_inline(callee);
4120   if (callee-&gt;force_inline() || inlinee_by_directive) {
4121     if (inline_level() &gt; MaxForceInlineLevel                      ) INLINE_BAILOUT(&quot;MaxForceInlineLevel&quot;);
4122     if (recursive_inline_level(callee) &gt; C1MaxRecursiveInlineLevel) INLINE_BAILOUT(&quot;recursive inlining too deep&quot;);
4123 
4124     const char* msg = &quot;&quot;;
4125     if (callee-&gt;force_inline())  msg = &quot;force inline by annotation&quot;;
4126     if (inlinee_by_directive)    msg = &quot;force inline by CompileCommand&quot;;
4127     print_inlining(callee, msg);
4128   } else {
4129     // use heuristic controls on inlining
4130     if (inline_level() &gt; C1MaxInlineLevel                       ) INLINE_BAILOUT(&quot;inlining too deep&quot;);
4131     int callee_recursive_level = recursive_inline_level(callee);
4132     if (callee_recursive_level &gt; C1MaxRecursiveInlineLevel      ) INLINE_BAILOUT(&quot;recursive inlining too deep&quot;);
4133     if (callee-&gt;code_size_for_inlining() &gt; max_inline_size()    ) INLINE_BAILOUT(&quot;callee is too large&quot;);
4134     // Additional condition to limit stack usage for non-recursive calls.
4135     if ((callee_recursive_level == 0) &amp;&amp;
4136         (callee-&gt;max_stack() + callee-&gt;max_locals() - callee-&gt;size_of_parameters() &gt; C1InlineStackLimit)) {
4137       INLINE_BAILOUT(&quot;callee uses too much stack&quot;);
4138     }
4139 
4140     // don&#39;t inline throwable methods unless the inlining tree is rooted in a throwable class
4141     if (callee-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
4142         callee-&gt;holder()-&gt;is_subclass_of(ciEnv::current()-&gt;Throwable_klass())) {
4143       // Throwable constructor call
4144       IRScope* top = scope();
4145       while (top-&gt;caller() != NULL) {
4146         top = top-&gt;caller();
4147       }
4148       if (!top-&gt;method()-&gt;holder()-&gt;is_subclass_of(ciEnv::current()-&gt;Throwable_klass())) {
4149         INLINE_BAILOUT(&quot;don&#39;t inline Throwable constructors&quot;);
4150       }
4151     }
4152 
4153     if (compilation()-&gt;env()-&gt;num_inlined_bytecodes() &gt; DesiredMethodLimit) {
4154       INLINE_BAILOUT(&quot;total inlining greater than DesiredMethodLimit&quot;);
4155     }
4156     // printing
4157     print_inlining(callee, &quot;inline&quot;, /*success*/ true);
4158   }
4159 
4160   // NOTE: Bailouts from this point on, which occur at the
4161   // GraphBuilder level, do not cause bailout just of the inlining but
4162   // in fact of the entire compilation.
4163 
4164   BlockBegin* orig_block = block();
4165 
4166   // Insert null check if necessary
4167   if (has_receiver) {
4168     // note: null check must happen even if first instruction of callee does
4169     //       an implicit null check since the callee is in a different scope
4170     //       and we must make sure exception handling does the right thing
4171     null_check(recv);
4172   }
4173 
4174   if (is_profiling()) {
4175     // Note that we&#39;d collect profile data in this method if we wanted it.
4176     // this may be redundant here...
4177     compilation()-&gt;set_would_profile(true);
4178 
4179     if (profile_calls()) {
4180       int start = 0;
4181       Values* obj_args = args_list_for_profiling(callee, start, has_receiver);
4182       if (obj_args != NULL) {
4183         int s = obj_args-&gt;max_length();
4184         // if called through method handle invoke, some arguments may have been popped
4185         for (int i = args_base+start, j = 0; j &lt; obj_args-&gt;max_length() &amp;&amp; i &lt; state()-&gt;stack_size(); ) {
4186           Value v = state()-&gt;stack_at_inc(i);
4187           if (v-&gt;type()-&gt;is_object_kind()) {
4188             obj_args-&gt;push(v);
4189             j++;
4190           }
4191         }
4192         check_args_for_profiling(obj_args, s);
4193       }
4194       profile_call(callee, recv, holder_known ? callee-&gt;holder() : NULL, obj_args, true);
4195     }
4196   }
4197 
4198   // Introduce a new callee continuation point - if the callee has
4199   // more than one return instruction or the return does not allow
4200   // fall-through of control flow, all return instructions of the
4201   // callee will need to be replaced by Goto&#39;s pointing to this
4202   // continuation point.
4203   BlockBegin* cont = block_at(next_bci());
4204   bool continuation_existed = true;
4205   if (cont == NULL) {
4206     cont = new BlockBegin(next_bci());
4207     // low number so that continuation gets parsed as early as possible
4208     cont-&gt;set_depth_first_number(0);
4209     if (PrintInitialBlockList) {
4210       tty-&gt;print_cr(&quot;CFG: created block %d (bci %d) as continuation for inline at bci %d&quot;,
4211                     cont-&gt;block_id(), cont-&gt;bci(), bci());
4212     }
4213     continuation_existed = false;
4214   }
4215   // Record number of predecessors of continuation block before
4216   // inlining, to detect if inlined method has edges to its
4217   // continuation after inlining.
4218   int continuation_preds = cont-&gt;number_of_preds();
4219 
4220   // Push callee scope
4221   push_scope(callee, cont);
4222 
4223   // the BlockListBuilder for the callee could have bailed out
4224   if (bailed_out())
4225       return false;
4226 
4227   // Temporarily set up bytecode stream so we can append instructions
4228   // (only using the bci of this stream)
4229   scope_data()-&gt;set_stream(scope_data()-&gt;parent()-&gt;stream());
4230 
4231   // Pass parameters into callee state: add assignments
4232   // note: this will also ensure that all arguments are computed before being passed
4233   ValueStack* callee_state = state();
4234   ValueStack* caller_state = state()-&gt;caller_state();
4235   for (int i = args_base; i &lt; caller_state-&gt;stack_size(); ) {
4236     const int arg_no = i - args_base;
4237     Value arg = caller_state-&gt;stack_at_inc(i);
4238     store_local(callee_state, arg, arg_no);
4239   }
4240 
4241   // Remove args from stack.
4242   // Note that we preserve locals state in case we can use it later
4243   // (see use of pop_scope() below)
4244   caller_state-&gt;truncate_stack(args_base);
4245   assert(callee_state-&gt;stack_size() == 0, &quot;callee stack must be empty&quot;);
4246 
4247   Value lock = NULL;
4248   BlockBegin* sync_handler = NULL;
4249 
4250   // Inline the locking of the receiver if the callee is synchronized
4251   if (callee-&gt;is_synchronized()) {
4252     lock = callee-&gt;is_static() ? append(new Constant(new InstanceConstant(callee-&gt;holder()-&gt;java_mirror())))
4253                                : state()-&gt;local_at(0);
4254     sync_handler = new BlockBegin(SynchronizationEntryBCI);
4255     inline_sync_entry(lock, sync_handler);
4256   }
4257 
4258   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
4259     Values* args = new Values(1);
4260     args-&gt;push(append(new Constant(new MethodConstant(method()))));
4261     append(new RuntimeCall(voidType, &quot;dtrace_method_entry&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry), args));
4262   }
4263 
4264   if (profile_inlined_calls()) {
4265     profile_invocation(callee, copy_state_before_with_bci(SynchronizationEntryBCI));
4266   }
4267 
4268   BlockBegin* callee_start_block = block_at(0);
4269   if (callee_start_block != NULL) {
4270     assert(callee_start_block-&gt;is_set(BlockBegin::parser_loop_header_flag), &quot;must be loop header&quot;);
4271     Goto* goto_callee = new Goto(callee_start_block, false);
4272     // The state for this goto is in the scope of the callee, so use
4273     // the entry bci for the callee instead of the call site bci.
4274     append_with_bci(goto_callee, 0);
4275     _block-&gt;set_end(goto_callee);
4276     callee_start_block-&gt;merge(callee_state);
4277 
4278     _last = _block = callee_start_block;
4279 
4280     scope_data()-&gt;add_to_work_list(callee_start_block);
4281   }
4282 
4283   // Clear out bytecode stream
4284   scope_data()-&gt;set_stream(NULL);
4285   scope_data()-&gt;set_ignore_return(ignore_return);
4286 
4287   CompileLog* log = compilation()-&gt;log();
4288   if (log != NULL) log-&gt;head(&quot;parse method=&#39;%d&#39;&quot;, log-&gt;identify(callee));
4289 
4290   // Ready to resume parsing in callee (either in the same block we
4291   // were in before or in the callee&#39;s start block)
4292   iterate_all_blocks(callee_start_block == NULL);
4293 
4294   if (log != NULL) log-&gt;done(&quot;parse&quot;);
4295 
4296   // If we bailed out during parsing, return immediately (this is bad news)
4297   if (bailed_out())
4298       return false;
4299 
4300   // iterate_all_blocks theoretically traverses in random order; in
4301   // practice, we have only traversed the continuation if we are
4302   // inlining into a subroutine
4303   assert(continuation_existed ||
4304          !continuation()-&gt;is_set(BlockBegin::was_visited_flag),
4305          &quot;continuation should not have been parsed yet if we created it&quot;);
4306 
4307   // At this point we are almost ready to return and resume parsing of
4308   // the caller back in the GraphBuilder. The only thing we want to do
4309   // first is an optimization: during parsing of the callee we
4310   // generated at least one Goto to the continuation block. If we
4311   // generated exactly one, and if the inlined method spanned exactly
4312   // one block (and we didn&#39;t have to Goto its entry), then we snip
4313   // off the Goto to the continuation, allowing control to fall
4314   // through back into the caller block and effectively performing
4315   // block merging. This allows load elimination and CSE to take place
4316   // across multiple callee scopes if they are relatively simple, and
4317   // is currently essential to making inlining profitable.
4318   if (num_returns() == 1
4319       &amp;&amp; block() == orig_block
4320       &amp;&amp; block() == inline_cleanup_block()) {
4321     _last  = inline_cleanup_return_prev();
4322     _state = inline_cleanup_state();
4323   } else if (continuation_preds == cont-&gt;number_of_preds()) {
4324     // Inlining caused that the instructions after the invoke in the
4325     // caller are not reachable any more. So skip filling this block
4326     // with instructions!
4327     assert(cont == continuation(), &quot;&quot;);
4328     assert(_last &amp;&amp; _last-&gt;as_BlockEnd(), &quot;&quot;);
4329     _skip_block = true;
4330   } else {
4331     // Resume parsing in continuation block unless it was already parsed.
4332     // Note that if we don&#39;t change _last here, iteration in
4333     // iterate_bytecodes_for_block will stop when we return.
4334     if (!continuation()-&gt;is_set(BlockBegin::was_visited_flag)) {
4335       // add continuation to work list instead of parsing it immediately
4336       assert(_last &amp;&amp; _last-&gt;as_BlockEnd(), &quot;&quot;);
4337       scope_data()-&gt;parent()-&gt;add_to_work_list(continuation());
4338       _skip_block = true;
4339     }
4340   }
4341 
4342   // Fill the exception handler for synchronized methods with instructions
4343   if (callee-&gt;is_synchronized() &amp;&amp; sync_handler-&gt;state() != NULL) {
4344     fill_sync_handler(lock, sync_handler);
4345   } else {
4346     pop_scope();
4347   }
4348 
4349   compilation()-&gt;notice_inlined_method(callee);
4350 
4351   return true;
4352 }
4353 
4354 
4355 bool GraphBuilder::try_method_handle_inline(ciMethod* callee, bool ignore_return) {
4356   ValueStack* state_before = copy_state_before();
4357   vmIntrinsics::ID iid = callee-&gt;intrinsic_id();
4358   switch (iid) {
4359   case vmIntrinsics::_invokeBasic:
4360     {
4361       // get MethodHandle receiver
4362       const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();
4363       ValueType* type = state()-&gt;stack_at(args_base)-&gt;type();
4364       if (type-&gt;is_constant()) {
4365         ciMethod* target = type-&gt;as_ObjectType()-&gt;constant_value()-&gt;as_method_handle()-&gt;get_vmtarget();
4366         // We don&#39;t do CHA here so only inline static and statically bindable methods.
4367         if (target-&gt;is_static() || target-&gt;can_be_statically_bound()) {
4368           if (ciMethod::is_consistent_info(callee, target)) {
4369             Bytecodes::Code bc = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual;
4370             ignore_return = ignore_return || (callee-&gt;return_type()-&gt;is_void() &amp;&amp; !target-&gt;return_type()-&gt;is_void());
4371             if (try_inline(target, /*holder_known*/ !callee-&gt;is_static(), ignore_return, bc)) {
4372               return true;
4373             }
4374           } else {
4375             print_inlining(target, &quot;signatures mismatch&quot;, /*success*/ false);
4376           }
4377         } else {
4378           print_inlining(target, &quot;not static or statically bindable&quot;, /*success*/ false);
4379         }
4380       } else {
4381         print_inlining(callee, &quot;receiver not constant&quot;, /*success*/ false);
4382       }
4383     }
4384     break;
4385 
4386   case vmIntrinsics::_linkToVirtual:
4387   case vmIntrinsics::_linkToStatic:
4388   case vmIntrinsics::_linkToSpecial:
4389   case vmIntrinsics::_linkToInterface:
4390     {
4391       // pop MemberName argument
4392       const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();
4393       ValueType* type = apop()-&gt;type();
4394       if (type-&gt;is_constant()) {
4395         ciMethod* target = type-&gt;as_ObjectType()-&gt;constant_value()-&gt;as_member_name()-&gt;get_vmtarget();
4396         ignore_return = ignore_return || (callee-&gt;return_type()-&gt;is_void() &amp;&amp; !target-&gt;return_type()-&gt;is_void());
4397         // If the target is another method handle invoke, try to recursively get
4398         // a better target.
4399         if (target-&gt;is_method_handle_intrinsic()) {
4400           if (try_method_handle_inline(target, ignore_return)) {
4401             return true;
4402           }
4403         } else if (!ciMethod::is_consistent_info(callee, target)) {
4404           print_inlining(target, &quot;signatures mismatch&quot;, /*success*/ false);
4405         } else {
4406           ciSignature* signature = target-&gt;signature();
4407           const int receiver_skip = target-&gt;is_static() ? 0 : 1;
4408           // Cast receiver to its type.
4409           if (!target-&gt;is_static()) {
4410             ciKlass* tk = signature-&gt;accessing_klass();
4411             Value obj = state()-&gt;stack_at(args_base);
4412             if (obj-&gt;exact_type() == NULL &amp;&amp;
4413                 obj-&gt;declared_type() != tk &amp;&amp; tk != compilation()-&gt;env()-&gt;Object_klass()) {
4414               TypeCast* c = new TypeCast(tk, obj, state_before);
4415               append(c);
4416               state()-&gt;stack_at_put(args_base, c);
4417             }
4418           }
4419           // Cast reference arguments to its type.
4420           for (int i = 0, j = 0; i &lt; signature-&gt;count(); i++) {
4421             ciType* t = signature-&gt;type_at(i);
4422             if (t-&gt;is_klass()) {
4423               ciKlass* tk = t-&gt;as_klass();
4424               Value obj = state()-&gt;stack_at(args_base + receiver_skip + j);
4425               if (obj-&gt;exact_type() == NULL &amp;&amp;
4426                   obj-&gt;declared_type() != tk &amp;&amp; tk != compilation()-&gt;env()-&gt;Object_klass()) {
4427                 TypeCast* c = new TypeCast(t, obj, state_before);
4428                 append(c);
4429                 state()-&gt;stack_at_put(args_base + receiver_skip + j, c);
4430               }
4431             }
4432             j += t-&gt;size();  // long and double take two slots
4433           }
4434           // We don&#39;t do CHA here so only inline static and statically bindable methods.
4435           if (target-&gt;is_static() || target-&gt;can_be_statically_bound()) {
4436             Bytecodes::Code bc = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual;
4437             if (try_inline(target, /*holder_known*/ !callee-&gt;is_static(), ignore_return, bc)) {
4438               return true;
4439             }
4440           } else {
4441             print_inlining(target, &quot;not static or statically bindable&quot;, /*success*/ false);
4442           }
4443         }
4444       } else {
4445         print_inlining(callee, &quot;MemberName not constant&quot;, /*success*/ false);
4446       }
4447     }
4448     break;
4449 
4450   default:
4451     fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
4452     break;
4453   }
4454   set_state(state_before-&gt;copy_for_parsing());
4455   return false;
4456 }
4457 
4458 
4459 void GraphBuilder::inline_bailout(const char* msg) {
4460   assert(msg != NULL, &quot;inline bailout msg must exist&quot;);
4461   _inline_bailout_msg = msg;
4462 }
4463 
4464 
4465 void GraphBuilder::clear_inline_bailout() {
4466   _inline_bailout_msg = NULL;
4467 }
4468 
4469 
4470 void GraphBuilder::push_root_scope(IRScope* scope, BlockList* bci2block, BlockBegin* start) {
4471   ScopeData* data = new ScopeData(NULL);
4472   data-&gt;set_scope(scope);
4473   data-&gt;set_bci2block(bci2block);
4474   _scope_data = data;
4475   _block = start;
4476 }
4477 
4478 
4479 void GraphBuilder::push_scope(ciMethod* callee, BlockBegin* continuation) {
4480   IRScope* callee_scope = new IRScope(compilation(), scope(), bci(), callee, -1, false);
4481   scope()-&gt;add_callee(callee_scope);
4482 
4483   BlockListBuilder blb(compilation(), callee_scope, -1);
4484   CHECK_BAILOUT();
4485 
4486   if (!blb.bci2block()-&gt;at(0)-&gt;is_set(BlockBegin::parser_loop_header_flag)) {
4487     // this scope can be inlined directly into the caller so remove
4488     // the block at bci 0.
4489     blb.bci2block()-&gt;at_put(0, NULL);
4490   }
4491 
4492   set_state(new ValueStack(callee_scope, state()-&gt;copy(ValueStack::CallerState, bci())));
4493 
4494   ScopeData* data = new ScopeData(scope_data());
4495   data-&gt;set_scope(callee_scope);
4496   data-&gt;set_bci2block(blb.bci2block());
4497   data-&gt;set_continuation(continuation);
4498   _scope_data = data;
4499 }
4500 
4501 
4502 void GraphBuilder::push_scope_for_jsr(BlockBegin* jsr_continuation, int jsr_dest_bci) {
4503   ScopeData* data = new ScopeData(scope_data());
4504   data-&gt;set_parsing_jsr();
4505   data-&gt;set_jsr_entry_bci(jsr_dest_bci);
4506   data-&gt;set_jsr_return_address_local(-1);
4507   // Must clone bci2block list as we will be mutating it in order to
4508   // properly clone all blocks in jsr region as well as exception
4509   // handlers containing rets
4510   BlockList* new_bci2block = new BlockList(bci2block()-&gt;length());
4511   new_bci2block-&gt;appendAll(bci2block());
4512   data-&gt;set_bci2block(new_bci2block);
4513   data-&gt;set_scope(scope());
4514   data-&gt;setup_jsr_xhandlers();
4515   data-&gt;set_continuation(continuation());
4516   data-&gt;set_jsr_continuation(jsr_continuation);
4517   _scope_data = data;
4518 }
4519 
4520 
4521 void GraphBuilder::pop_scope() {
4522   int number_of_locks = scope()-&gt;number_of_locks();
4523   _scope_data = scope_data()-&gt;parent();
4524   // accumulate minimum number of monitor slots to be reserved
4525   scope()-&gt;set_min_number_of_locks(number_of_locks);
4526 }
4527 
4528 
4529 void GraphBuilder::pop_scope_for_jsr() {
4530   _scope_data = scope_data()-&gt;parent();
4531 }
4532 
4533 void GraphBuilder::append_unsafe_get_obj(ciMethod* callee, BasicType t, bool is_volatile) {
4534   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4535   null_check(args-&gt;at(0));
4536   Instruction* offset = args-&gt;at(2);
4537 #ifndef _LP64
4538   offset = append(new Convert(Bytecodes::_l2i, offset, as_ValueType(T_INT)));
4539 #endif
4540   Instruction* op = append(new UnsafeGetObject(t, args-&gt;at(1), offset, is_volatile));
4541   push(op-&gt;type(), op);
4542   compilation()-&gt;set_has_unsafe_access(true);
4543 }
4544 
4545 
4546 void GraphBuilder::append_unsafe_put_obj(ciMethod* callee, BasicType t, bool is_volatile) {
4547   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4548   null_check(args-&gt;at(0));
4549   Instruction* offset = args-&gt;at(2);
4550 #ifndef _LP64
4551   offset = append(new Convert(Bytecodes::_l2i, offset, as_ValueType(T_INT)));
4552 #endif
4553   Value val = args-&gt;at(3);
4554   if (t == T_BOOLEAN) {
4555     Value mask = append(new Constant(new IntConstant(1)));
4556     val = append(new LogicOp(Bytecodes::_iand, val, mask));
4557   }
4558   Instruction* op = append(new UnsafePutObject(t, args-&gt;at(1), offset, val, is_volatile));
4559   compilation()-&gt;set_has_unsafe_access(true);
4560   kill_all();
4561 }
4562 
4563 
4564 void GraphBuilder::append_unsafe_get_raw(ciMethod* callee, BasicType t) {
4565   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4566   null_check(args-&gt;at(0));
4567   Instruction* op = append(new UnsafeGetRaw(t, args-&gt;at(1), false));
4568   push(op-&gt;type(), op);
4569   compilation()-&gt;set_has_unsafe_access(true);
4570 }
4571 
4572 
4573 void GraphBuilder::append_unsafe_put_raw(ciMethod* callee, BasicType t) {
4574   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4575   null_check(args-&gt;at(0));
4576   Instruction* op = append(new UnsafePutRaw(t, args-&gt;at(1), args-&gt;at(2)));
4577   compilation()-&gt;set_has_unsafe_access(true);
4578 }
4579 
4580 
4581 void GraphBuilder::append_unsafe_CAS(ciMethod* callee) {
4582   ValueStack* state_before = copy_state_for_exception();
4583   ValueType* result_type = as_ValueType(callee-&gt;return_type());
4584   assert(result_type-&gt;is_int(), &quot;int result&quot;);
4585   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4586 
4587   // Pop off some args to specially handle, then push back
4588   Value newval = args-&gt;pop();
4589   Value cmpval = args-&gt;pop();
4590   Value offset = args-&gt;pop();
4591   Value src = args-&gt;pop();
4592   Value unsafe_obj = args-&gt;pop();
4593 
4594   // Separately handle the unsafe arg. It is not needed for code
4595   // generation, but must be null checked
4596   null_check(unsafe_obj);
4597 
4598 #ifndef _LP64
4599   offset = append(new Convert(Bytecodes::_l2i, offset, as_ValueType(T_INT)));
4600 #endif
4601 
4602   args-&gt;push(src);
4603   args-&gt;push(offset);
4604   args-&gt;push(cmpval);
4605   args-&gt;push(newval);
4606 
4607   // An unsafe CAS can alias with other field accesses, but we don&#39;t
4608   // know which ones so mark the state as no preserved.  This will
4609   // cause CSE to invalidate memory across it.
4610   bool preserves_state = false;
4611   Intrinsic* result = new Intrinsic(result_type, callee-&gt;intrinsic_id(), args, false, state_before, preserves_state);
4612   append_split(result);
4613   push(result_type, result);
4614   compilation()-&gt;set_has_unsafe_access(true);
4615 }
4616 
4617 void GraphBuilder::append_char_access(ciMethod* callee, bool is_store) {
4618   // This intrinsic accesses byte[] array as char[] array. Computing the offsets
4619   // correctly requires matched array shapes.
4620   assert (arrayOopDesc::base_offset_in_bytes(T_CHAR) == arrayOopDesc::base_offset_in_bytes(T_BYTE),
4621           &quot;sanity: byte[] and char[] bases agree&quot;);
4622   assert (type2aelembytes(T_CHAR) == type2aelembytes(T_BYTE)*2,
4623           &quot;sanity: byte[] and char[] scales agree&quot;);
4624 
4625   ValueStack* state_before = copy_state_indexed_access();
4626   compilation()-&gt;set_has_access_indexed(true);
4627   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4628   Value array = args-&gt;at(0);
4629   Value index = args-&gt;at(1);
4630   if (is_store) {
4631     Value value = args-&gt;at(2);
4632     Instruction* store = append(new StoreIndexed(array, index, NULL, T_CHAR, value, state_before, false, true));
4633     store-&gt;set_flag(Instruction::NeedsRangeCheckFlag, false);
4634     _memory-&gt;store_value(value);
4635   } else {
4636     Instruction* load = append(new LoadIndexed(array, index, NULL, T_CHAR, state_before, true));
4637     load-&gt;set_flag(Instruction::NeedsRangeCheckFlag, false);
4638     push(load-&gt;type(), load);
4639   }
4640 }
4641 
4642 void GraphBuilder::print_inlining(ciMethod* callee, const char* msg, bool success) {
4643   CompileLog* log = compilation()-&gt;log();
4644   if (log != NULL) {
4645     assert(msg != NULL, &quot;inlining msg should not be null!&quot;);
4646     if (success) {
4647       log-&gt;inline_success(msg);
4648     } else {
4649       log-&gt;inline_fail(msg);
4650     }
4651   }
4652   EventCompilerInlining event;
4653   if (event.should_commit()) {
4654     CompilerEvent::InlineEvent::post(event, compilation()-&gt;env()-&gt;task()-&gt;compile_id(), method()-&gt;get_Method(), callee, success, msg, bci());
4655   }
4656 
4657   CompileTask::print_inlining_ul(callee, scope()-&gt;level(), bci(), msg);
4658 
4659   if (!compilation()-&gt;directive()-&gt;PrintInliningOption) {
4660     return;
4661   }
4662   CompileTask::print_inlining_tty(callee, scope()-&gt;level(), bci(), msg);
4663   if (success &amp;&amp; CIPrintMethodCodes) {
4664     callee-&gt;print_codes();
4665   }
4666 }
4667 
4668 void GraphBuilder::append_unsafe_get_and_set_obj(ciMethod* callee, bool is_add) {
4669   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4670   BasicType t = callee-&gt;return_type()-&gt;basic_type();
4671   null_check(args-&gt;at(0));
4672   Instruction* offset = args-&gt;at(2);
4673 #ifndef _LP64
4674   offset = append(new Convert(Bytecodes::_l2i, offset, as_ValueType(T_INT)));
4675 #endif
4676   Instruction* op = append(new UnsafeGetAndSetObject(t, args-&gt;at(1), offset, args-&gt;at(3), is_add));
4677   compilation()-&gt;set_has_unsafe_access(true);
4678   kill_all();
4679   push(op-&gt;type(), op);
4680 }
4681 
4682 #ifndef PRODUCT
4683 void GraphBuilder::print_stats() {
4684   vmap()-&gt;print();
4685 }
4686 #endif // PRODUCT
4687 
4688 void GraphBuilder::profile_call(ciMethod* callee, Value recv, ciKlass* known_holder, Values* obj_args, bool inlined) {
4689   assert(known_holder == NULL || (known_holder-&gt;is_instance_klass() &amp;&amp;
4690                                   (!known_holder-&gt;is_interface() ||
4691                                    ((ciInstanceKlass*)known_holder)-&gt;has_nonstatic_concrete_methods())), &quot;should be non-static concrete method&quot;);
4692   if (known_holder != NULL) {
4693     if (known_holder-&gt;exact_klass() == NULL) {
4694       known_holder = compilation()-&gt;cha_exact_type(known_holder);
4695     }
4696   }
4697 
4698   append(new ProfileCall(method(), bci(), callee, recv, known_holder, obj_args, inlined));
4699 }
4700 
4701 void GraphBuilder::profile_return_type(Value ret, ciMethod* callee, ciMethod* m, int invoke_bci) {
4702   assert((m == NULL) == (invoke_bci &lt; 0), &quot;invalid method and invalid bci together&quot;);
4703   if (m == NULL) {
4704     m = method();
4705   }
4706   if (invoke_bci &lt; 0) {
4707     invoke_bci = bci();
4708   }
4709   ciMethodData* md = m-&gt;method_data_or_null();
4710   ciProfileData* data = md-&gt;bci_to_data(invoke_bci);
4711   if (data != NULL &amp;&amp; (data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData())) {
4712     bool has_return = data-&gt;is_CallTypeData() ? ((ciCallTypeData*)data)-&gt;has_return() : ((ciVirtualCallTypeData*)data)-&gt;has_return();
4713     if (has_return) {
4714       append(new ProfileReturnType(m , invoke_bci, callee, ret));
4715     }
4716   }
4717 }
4718 
4719 void GraphBuilder::profile_invocation(ciMethod* callee, ValueStack* state) {
4720   append(new ProfileInvoke(callee, state));
4721 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>