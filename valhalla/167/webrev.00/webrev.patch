diff a/src/hotspot/share/c1/c1_GraphBuilder.cpp b/src/hotspot/share/c1/c1_GraphBuilder.cpp
--- a/src/hotspot/share/c1/c1_GraphBuilder.cpp
+++ b/src/hotspot/share/c1/c1_GraphBuilder.cpp
@@ -1835,29 +1835,31 @@
       if (state_before == NULL && field->is_flattened()) {
         // Save the entire state and re-execute on deopt when accessing flattened fields
         assert(Interpreter::bytecode_should_reexecute(code), "should reexecute");
         state_before = copy_state_before();
       }
-      obj = apop();
-      ObjectType* obj_type = obj->type()->as_ObjectType();
-      if (field->is_constant() && !field->is_flattened() && obj_type->is_constant() && !PatchALot) {
-        ciObject* const_oop = obj_type->constant_value();
-        if (!const_oop->is_null_object() && const_oop->is_loaded()) {
-          ciConstant field_value = field->constant_value_of(const_oop);
-          if (field_value.is_valid()) {
-            if (field->signature()->is_Q_signature() && field_value.is_null_or_zero()) {
-              // Non-flattened inline type field. Replace null by the default value.
-              constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));
-            } else {
-              constant = make_constant(field_value, field);
-            }
-            // For CallSite objects add a dependency for invalidation of the optimization.
-            if (field->is_call_site_target()) {
-              ciCallSite* call_site = const_oop->as_call_site();
-              if (!call_site->is_fully_initialized_constant_call_site()) {
-                ciMethodHandle* target = field_value.as_object()->as_method_handle();
-                dependency_recorder()->assert_call_site_target_value(call_site, target);
+      if (!has_delayed_flattened_field_access()) {
+        obj = apop();
+        ObjectType* obj_type = obj->type()->as_ObjectType();
+        if (field->is_constant() && !field->is_flattened() && obj_type->is_constant() && !PatchALot) {
+          ciObject* const_oop = obj_type->constant_value();
+          if (!const_oop->is_null_object() && const_oop->is_loaded()) {
+            ciConstant field_value = field->constant_value_of(const_oop);
+            if (field_value.is_valid()) {
+              if (field->signature()->is_Q_signature() && field_value.is_null_or_zero()) {
+                // Non-flattened inline type field. Replace null by the default value.
+                constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));
+              } else {
+                constant = make_constant(field_value, field);
+              }
+              // For CallSite objects add a dependency for invalidation of the optimization.
+              if (field->is_call_site_target()) {
+                ciCallSite* call_site = const_oop->as_call_site();
+                if (!call_site->is_fully_initialized_constant_call_site()) {
+                  ciMethodHandle* target = field_value.as_object()->as_method_handle();
+                  dependency_recorder()->assert_call_site_target_value(call_site, target);
+                }
               }
             }
           }
         }
       }
@@ -1866,11 +1868,19 @@
       } else {
         if (state_before == NULL) {
           state_before = copy_state_for_exception();
         }
         if (!field->is_flattened()) {
-          LoadField* load = new LoadField(obj, offset, field, false, state_before, needs_patching);
+          LoadField* load;
+          if (!has_delayed_flattened_field_access()) {
+            load = new LoadField(obj, offset, field, false, state_before, needs_patching);
+          } else {
+            load = new LoadField(_delayed_flattened_field_access->obj(),
+                                 _delayed_flattened_field_access->offset() + offset - field->holder()->as_inline_klass()->first_field_offset(),
+                                 field, false, state_before, needs_patching);
+            _delayed_flattened_field_access = NULL;
+          }
           Value replacement = !needs_patching ? _memory->load(load) : load;
           if (replacement != load) {
             assert(replacement->is_linked() || !replacement->can_be_linked(), "should already by linked");
             // Writing an (integer) value to a boolean, byte, char or short field includes an implicit narrowing
             // conversion. Emit an explicit conversion here to get the correct field value after the write.
@@ -1891,22 +1901,42 @@
             }
             push(type, replacement);
           } else {
             push(type, append(load));
           }
-        } else { // flattened field, not optimized solution: re-instantiate the flattened value
-          assert(field->type()->is_inlinetype(), "Sanity check");
-          ciInlineKlass* inline_klass = field->type()->as_inline_klass();
-          int flattening_offset = field->offset() - inline_klass->first_field_offset();
-          assert(field->type()->is_inlinetype(), "Sanity check");
-          scope()->set_wrote_final();
-          scope()->set_wrote_fields();
-          NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(inline_klass, state_before, false);
-          _memory->new_instance(new_instance);
-          apush(append_split(new_instance));
-          copy_inline_content(inline_klass, obj, field->offset(), new_instance, inline_klass->first_field_offset(),
-                       state_before, needs_patching);
+        } else {
+          ciBytecodeStream s(method());
+          s.force_bci(bci());
+          s.next();
+          if (s.cur_bc() == Bytecodes::_getfield && !needs_patching) {
+            if (!has_delayed_flattened_field_access()) {
+              null_check(obj);
+              DelayedFlattenedFieldAccess* dffa = new DelayedFlattenedFieldAccess(obj, field, field->offset());
+              _delayed_flattened_field_access = dffa;
+            } else {
+              _delayed_flattened_field_access->update(field, offset - field->holder()->as_inline_klass()->first_field_offset());
+            }
+          } else {
+            assert(field->type()->is_inlinetype(), "Sanity check");
+            ciInlineKlass* inline_klass = field->type()->as_inline_klass();
+            assert(field->type()->is_inlinetype(), "Sanity check");
+            scope()->set_wrote_final();
+            scope()->set_wrote_fields();
+            NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(inline_klass, state_before, false);
+            _memory->new_instance(new_instance);
+            apush(append_split(new_instance));
+            if (!has_delayed_flattened_field_access()) {
+              copy_inline_content(inline_klass, obj, field->offset(), new_instance, inline_klass->first_field_offset(),
+                          state_before, needs_patching);
+            } else {
+              copy_inline_content(inline_klass, _delayed_flattened_field_access->obj(),
+                                  _delayed_flattened_field_access->offset() + field->offset() - field->holder()->as_inline_klass()->first_field_offset(),
+                                  new_instance, inline_klass->first_field_offset(),
+                                  state_before, needs_patching);
+              _delayed_flattened_field_access = NULL;
+            }
+          }
         }
       }
       break;
     }
     case Bytecodes::_withfield:
@@ -3489,10 +3519,11 @@
   , _compilation(compilation)
   , _memory(new MemoryBuffer())
   , _inline_bailout_msg(NULL)
   , _instruction_count(0)
   , _osr_entry(NULL)
+  , _delayed_flattened_field_access(NULL)
 {
   int osr_bci = compilation->osr_bci();
 
   // determine entry points and bci2block mapping
   BlockListBuilder blm(compilation, scope, osr_bci);
diff a/src/hotspot/share/c1/c1_GraphBuilder.hpp b/src/hotspot/share/c1/c1_GraphBuilder.hpp
--- a/src/hotspot/share/c1/c1_GraphBuilder.hpp
+++ b/src/hotspot/share/c1/c1_GraphBuilder.hpp
@@ -33,10 +33,30 @@
 #include "ci/ciStreams.hpp"
 #include "compiler/compileLog.hpp"
 
 class MemoryBuffer;
 
+class DelayedFlattenedFieldAccess : public CompilationResourceObj {
+private:
+  Value _obj;
+  ciField* _field;
+  int _offset;
+public:
+  DelayedFlattenedFieldAccess(Value obj, ciField* field, int offset)
+  : _obj(obj)
+  , _field(field)
+  , _offset(offset) { }
+
+  void update(ciField* field, int offset) {
+    _field = field;
+    _offset += offset;
+  }
+  Value obj() { return _obj; }
+  ciField* field() { return _field; }
+  int offset() { return _offset; }
+};
+
 class GraphBuilder {
  private:
   // Per-scope data. These are pushed and popped as we descend into
   // inlined methods. Currently in order to generate good code in the
   // inliner we have to attempt to inline methods directly into the
@@ -189,10 +209,14 @@
   BlockBegin*       _block;                      // the current block
   ValueStack*       _state;                      // the current execution state
   Instruction*      _last;                       // the last instruction added
   bool              _skip_block;                 // skip processing of the rest of this block
 
+  DelayedFlattenedFieldAccess* _delayed_flattened_field_access;
+  bool              has_delayed_flattened_field_access() { return _delayed_flattened_field_access != NULL; }
+
+
   // accessors
   ScopeData*        scope_data() const           { return _scope_data; }
   Compilation*      compilation() const          { return _compilation; }
   BlockList*        bci2block() const            { return scope_data()->bci2block(); }
   ValueMap*         vmap() const                 { assert(UseLocalValueNumbering, "should not access otherwise"); return _vmap; }
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/GetfieldChains.jcod b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/GetfieldChains.jcod
--- /dev/null
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/GetfieldChains.jcod
@@ -0,0 +1,926 @@
+class compiler/valhalla/inlinetypes/NamedRectangleN {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [] { // Constant Pool
+    ; // first element is empty
+    Method #2 #3; // #1
+    class #4; // #2
+    NameAndType #5 #6; // #3
+    Utf8 "java/lang/Object"; // #4
+    Utf8 "<init>"; // #5
+    Utf8 "()V"; // #6
+    Method #8 #9; // #7
+    class #10; // #8
+    NameAndType #5 #11; // #9
+    Utf8 "compiler/valhalla/inlinetypes/RectangleN"; // #10
+    Utf8 "()Qcompiler/valhalla/inlinetypes/RectangleN;"; // #11
+    Field #13 #14; // #12
+    class #15; // #13
+    NameAndType #16 #17; // #14
+    Utf8 "compiler/valhalla/inlinetypes/NamedRectangleN"; // #15
+    Utf8 "rect"; // #16
+    Utf8 "Qcompiler/valhalla/inlinetypes/RectangleN;"; // #17
+    String #19; // #18
+    Utf8 ""; // #19
+    Field #13 #21; // #20
+    NameAndType #22 #23; // #21
+    Utf8 "name"; // #22
+    Utf8 "Ljava/lang/String;"; // #23
+    Field #8 #25; // #24
+    NameAndType #26 #27; // #25
+    Utf8 "p1"; // #26
+    Utf8 "Qcompiler/valhalla/inlinetypes/PointN;"; // #27
+    Field #29 #30; // #28
+    class #31; // #29
+    NameAndType #32 #33; // #30
+    Utf8 "compiler/valhalla/inlinetypes/PointN"; // #31
+    Utf8 "x"; // #32
+    Utf8 "I"; // #33
+    Utf8 "Code"; // #34
+    Utf8 "LineNumberTable"; // #35
+    Utf8 "getP1X"; // #36
+    Utf8 "(Lcompiler/valhalla/inlinetypes/NamedRectangleN;)I"; // #37
+    Utf8 "getP1"; // #38
+    Utf8 "(Lcompiler/valhalla/inlinetypes/NamedRectangleN;)Qcompiler/valhalla/inlinetypes/PointN;"; // #39
+    Utf8 "SourceFile"; // #40
+    Utf8 "NamedRectangleN.java"; // #41
+  } // Constant Pool
+
+  0x0021; // access
+  #13;// this_cpx
+  #2;// super_cpx
+
+  [] { // Interfaces
+  } // Interfaces
+
+  [] { // Fields
+    {  // field
+      0x0000; // access
+      #16; // name_index
+      #17; // descriptor_index
+      [] { // Attributes
+      } // Attributes
+    }
+    ;
+    {  // field
+      0x0000; // access
+      #22; // name_index
+      #23; // descriptor_index
+      [] { // Attributes
+      } // Attributes
+    }
+  } // Fields
+
+  [] { // Methods
+    {  // method
+      0x0001; // access
+      #5; // name_index
+      #6; // descriptor_index
+      [] { // Attributes
+        Attr(#34) { // Code
+          2; // max_stack
+          1; // max_locals
+          Bytes[]{
+            0x2AB700012AB80007;
+            0xB5000C2A1212B500;
+            0x14B1;
+          }
+          [] { // Traps
+          } // end Traps
+          [] { // Attributes
+            Attr(#35) { // LineNumberTable
+              [] { // line_number_table
+                0  26;
+                4  27;
+                11  28;
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    }
+    ;
+    {  // method
+      0x0008; // access
+      #36; // name_index
+      #37; // descriptor_index
+      [] { // Attributes
+        Attr(#34) { // Code
+          1; // max_stack
+          1; // max_locals
+          Bytes[]{
+            0x2AB4000CB40018B4;
+            0x001CAC;
+          }
+          [] { // Traps
+          } // end Traps
+          [] { // Attributes
+            Attr(#35) { // LineNumberTable
+              [] { // line_number_table
+                0  31;
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    }
+    ;
+    {  // method
+      0x0008; // access
+      #38; // name_index
+      #39; // descriptor_index
+      [] { // Attributes
+        Attr(#34) { // Code
+          1; // max_stack
+          1; // max_locals
+          Bytes[]{
+            0x2AB4000CB40018B0;
+          }
+          [] { // Traps
+          } // end Traps
+          [] { // Attributes
+            Attr(#35) { // LineNumberTable
+              [] { // line_number_table
+                0  37;
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    }
+  } // Methods
+
+  [] { // Attributes
+    Attr(#40) { // SourceFile
+      #41;
+    } // end SourceFile
+  } // Attributes
+} // end class compiler/valhalla/inlinetypes/NamedRectangleN
+
+class compiler/valhalla/inlinetypes/NamedRectangleP {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [] { // Constant Pool
+    ; // first element is empty
+    Method #2 #3; // #1
+    class #4; // #2
+    NameAndType #5 #6; // #3
+    Utf8 "java/lang/Object"; // #4
+    Utf8 "<init>"; // #5
+    Utf8 "()V"; // #6
+    Method #8 #9; // #7
+    class #10; // #8
+    NameAndType #5 #11; // #9
+    Utf8 "compiler/valhalla/inlinetypes/RectangleP"; // #10
+    Utf8 "()Qcompiler/valhalla/inlinetypes/RectangleP;"; // #11
+    Field #13 #14; // #12
+    class #15; // #13
+    NameAndType #16 #17; // #14
+    Utf8 "compiler/valhalla/inlinetypes/NamedRectangleP"; // #15
+    Utf8 "rect"; // #16
+    Utf8 "Qcompiler/valhalla/inlinetypes/RectangleP;"; // #17
+    String #19; // #18
+    Utf8 ""; // #19
+    Field #13 #21; // #20
+    NameAndType #22 #23; // #21
+    Utf8 "name"; // #22
+    Utf8 "Ljava/lang/String;"; // #23
+    Field #8 #25; // #24
+    NameAndType #26 #27; // #25
+    Utf8 "p1"; // #26
+    Utf8 "Qcompiler/valhalla/inlinetypes/Point;"; // #27
+    Field #29 #30; // #28
+    class #31; // #29
+    NameAndType #32 #33; // #30
+    Utf8 "compiler/valhalla/inlinetypes/Point"; // #31
+    Utf8 "x"; // #32
+    Utf8 "I"; // #33
+    Utf8 "Code"; // #34
+    Utf8 "LineNumberTable"; // #35
+    Utf8 "getP1X"; // #36
+    Utf8 "(Lcompiler/valhalla/inlinetypes/NamedRectangleP;)I"; // #37
+    Utf8 "getP1"; // #38
+    Utf8 "(Lcompiler/valhalla/inlinetypes/NamedRectangleP;)Qcompiler/valhalla/inlinetypes/Point;"; // #39
+    Utf8 "SourceFile"; // #40
+    Utf8 "NamedRectangleP.java"; // #41
+  } // Constant Pool
+
+  0x0021; // access
+  #13;// this_cpx
+  #2;// super_cpx
+
+  [] { // Interfaces
+  } // Interfaces
+
+  [] { // Fields
+    {  // field
+      0x0000; // access
+      #16; // name_index
+      #17; // descriptor_index
+      [] { // Attributes
+      } // Attributes
+    }
+    ;
+    {  // field
+      0x0000; // access
+      #22; // name_index
+      #23; // descriptor_index
+      [] { // Attributes
+      } // Attributes
+    }
+  } // Fields
+
+  [] { // Methods
+    {  // method
+      0x0001; // access
+      #5; // name_index
+      #6; // descriptor_index
+      [] { // Attributes
+        Attr(#34) { // Code
+          2; // max_stack
+          1; // max_locals
+          Bytes[]{
+            0x2AB700012AB80007;
+            0xB5000C2A1212B500;
+            0x14B1;
+          }
+          [] { // Traps
+          } // end Traps
+          [] { // Attributes
+            Attr(#35) { // LineNumberTable
+              [] { // line_number_table
+                0  26;
+                4  27;
+                11  28;
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    }
+    ;
+    {  // method
+      0x0008; // access
+      #36; // name_index
+      #37; // descriptor_index
+      [] { // Attributes
+        Attr(#34) { // Code
+          1; // max_stack
+          1; // max_locals
+          Bytes[]{
+            0x2AB4000CB40018B4;
+            0x001CAC;
+          }
+          [] { // Traps
+          } // end Traps
+          [] { // Attributes
+            Attr(#35) { // LineNumberTable
+              [] { // line_number_table
+                0  31;
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    }
+    ;
+    {  // method
+      0x0008; // access
+      #38; // name_index
+      #39; // descriptor_index
+      [] { // Attributes
+        Attr(#34) { // Code
+          1; // max_stack
+          1; // max_locals
+          Bytes[]{
+            0x2AB4000CB40018B0;
+          }
+          [] { // Traps
+          } // end Traps
+          [] { // Attributes
+            Attr(#35) { // LineNumberTable
+              [] { // line_number_table
+                0  37;
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    }
+  } // Methods
+
+  [] { // Attributes
+    Attr(#40) { // SourceFile
+      #41;
+    } // end SourceFile
+  } // Attributes
+} // end class compiler/valhalla/inlinetypes/NamedRectangleP
+
+class compiler/valhalla/inlinetypes/PointN$ref {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [] { // Constant Pool
+    ; // first element is empty
+    class #2; // #1
+    Utf8 "compiler/valhalla/inlinetypes/PointN$ref"; // #2
+    class #4; // #3
+    Utf8 "java/lang/Object"; // #4
+    Utf8 "SourceFile"; // #5
+    Utf8 "PointN.java"; // #6
+    Utf8 "NestMembers"; // #7
+    class #9; // #8
+    Utf8 "compiler/valhalla/inlinetypes/PointN"; // #9
+    Utf8 "PermittedSubclasses"; // #10
+  } // Constant Pool
+
+  0x0421; // access
+  #1;// this_cpx
+  #3;// super_cpx
+
+  [] { // Interfaces
+  } // Interfaces
+
+  [] { // Fields
+  } // Fields
+
+  [] { // Methods
+  } // Methods
+
+  [] { // Attributes
+    Attr(#5) { // SourceFile
+      #6;
+    } // end SourceFile
+    ;
+    Attr(#7) { // NestMembers
+      [] { // classes
+        #8;
+      }
+    } // end NestMembers
+    ;
+    Attr(#10) { // PermittedSubclasses
+      0x00010008;
+    } // end PermittedSubclasses
+  } // Attributes
+} // end class compiler/valhalla/inlinetypes/PointN$ref
+
+class compiler/valhalla/inlinetypes/PointN {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [] { // Constant Pool
+    ; // first element is empty
+    class #2; // #1
+    Utf8 "compiler/valhalla/inlinetypes/PointN"; // #2
+    Field #1 #4; // #3
+    NameAndType #5 #6; // #4
+    Utf8 "x1"; // #5                // field name changed from x to x1
+    Utf8 "I"; // #6
+    Field #1 #8; // #7
+    NameAndType #9 #6; // #8
+    Utf8 "y"; // #9
+    InvokeDynamic 0s #11; // #10
+    NameAndType #12 #13; // #11
+    Utf8 "toString"; // #12
+    Utf8 "(Qcompiler/valhalla/inlinetypes/PointN;)Ljava/lang/String;"; // #13
+    class #15; // #14
+    Utf8 "compiler/valhalla/inlinetypes/PointN$ref"; // #15
+    Utf8 "()Ljava/lang/String;"; // #16
+    Utf8 "Code"; // #17
+    Utf8 "LineNumberTable"; // #18
+    Utf8 "<init>"; // #19
+    Utf8 "()Qcompiler/valhalla/inlinetypes/PointN;"; // #20
+    Utf8 "SourceFile"; // #21
+    Utf8 "PointN.java"; // #22
+    Utf8 "NestHost"; // #23
+    Utf8 "BootstrapMethods"; // #24
+    MethodHandle 6b #26; // #25
+    Method #27 #28; // #26
+    class #29; // #27
+    NameAndType #30 #31; // #28
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #29
+    Utf8 "makeBootstrapMethod"; // #30
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #31
+    Utf8 "InnerClasses"; // #32
+    class #34; // #33
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #34
+    class #36; // #35
+    Utf8 "java/lang/invoke/MethodHandles"; // #36
+    Utf8 "Lookup"; // #37
+  } // Constant Pool
+
+  0x0131; // access
+  #1;// this_cpx
+  #14;// super_cpx
+
+  [] { // Interfaces
+  } // Interfaces
+
+  [] { // Fields
+    {  // field
+      0x0010; // access
+      #5; // name_index
+      #6; // descriptor_index
+      [] { // Attributes
+      } // Attributes
+    }
+    ;
+    {  // field
+      0x0010; // access
+      #9; // name_index
+      #6; // descriptor_index
+      [] { // Attributes
+      } // Attributes
+    }
+  } // Fields
+
+  [] { // Methods
+    {  // method
+      0x0011; // access
+      #12; // name_index
+      #16; // descriptor_index
+      [] { // Attributes
+        Attr(#17) { // Code
+          1; // max_stack
+          1; // max_locals
+          Bytes[]{
+            0x2ABA000A0000B0;
+          }
+          [] { // Traps
+          } // end Traps
+          [] { // Attributes
+            Attr(#18) { // LineNumberTable
+              [] { // line_number_table
+                0  26;
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    }
+    ;
+    {  // method
+      0x0009; // access
+      #19; // name_index
+      #20; // descriptor_index
+      [] { // Attributes
+        Attr(#17) { // Code
+          2; // max_stack
+          1; // max_locals
+          Bytes[]{
+            0xCB00014B072A5FCC;
+            0x00034B10072A5FCC;
+            0x00074B2AB0;
+          }
+          [] { // Traps
+          } // end Traps
+          [] { // Attributes
+            Attr(#18) { // LineNumberTable
+              [] { // line_number_table
+                0  26;
+                4  27;
+                11  28;
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    }
+  } // Methods
+
+  [] { // Attributes
+    Attr(#21) { // SourceFile
+      #22;
+    } // end SourceFile
+    ;
+    Attr(#23) { // NestHost
+      #14;
+    } // end NestHost
+    ;
+    Attr(#24) { // BootstrapMethods
+      [] { // bootstrap_methods
+        {  //  bootstrap_method
+          #25; // bootstrap_method_ref
+          [] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+    ;
+    Attr(#32) { // InnerClasses
+      [] { // classes
+        #33 #35 #37 25;
+      }
+    } // end InnerClasses
+  } // Attributes
+} // end class compiler/valhalla/inlinetypes/PointN
+
+class compiler/valhalla/inlinetypes/RectangleN$ref {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [] { // Constant Pool
+    ; // first element is empty
+    class #2; // #1
+    Utf8 "compiler/valhalla/inlinetypes/RectangleN$ref"; // #2
+    class #4; // #3
+    Utf8 "java/lang/Object"; // #4
+    Utf8 "SourceFile"; // #5
+    Utf8 "RectangleN.java"; // #6
+    Utf8 "NestMembers"; // #7
+    class #9; // #8
+    Utf8 "compiler/valhalla/inlinetypes/RectangleN"; // #9
+    Utf8 "PermittedSubclasses"; // #10
+  } // Constant Pool
+
+  0x0421; // access
+  #1;// this_cpx
+  #3;// super_cpx
+
+  [] { // Interfaces
+  } // Interfaces
+
+  [] { // Fields
+  } // Fields
+
+  [] { // Methods
+  } // Methods
+
+  [] { // Attributes
+    Attr(#5) { // SourceFile
+      #6;
+    } // end SourceFile
+    ;
+    Attr(#7) { // NestMembers
+      [] { // classes
+        #8;
+      }
+    } // end NestMembers
+    ;
+    Attr(#10) { // PermittedSubclasses
+      0x00010008;
+    } // end PermittedSubclasses
+  } // Attributes
+} // end class compiler/valhalla/inlinetypes/RectangleN$ref
+
+class compiler/valhalla/inlinetypes/RectangleN {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [] { // Constant Pool
+    ; // first element is empty
+    class #2; // #1
+    Utf8 "compiler/valhalla/inlinetypes/RectangleN"; // #2
+    Method #4 #5; // #3
+    class #6; // #4
+    NameAndType #7 #8; // #5
+    Utf8 "compiler/valhalla/inlinetypes/PointN"; // #6
+    Utf8 "<init>"; // #7
+    Utf8 "()Qcompiler/valhalla/inlinetypes/PointN;"; // #8
+    Field #1 #10; // #9
+    NameAndType #11 #12; // #10
+    Utf8 "p0"; // #11
+    Utf8 "Qcompiler/valhalla/inlinetypes/PointN;"; // #12
+    Field #1 #14; // #13
+    NameAndType #15 #12; // #14
+    Utf8 "p1"; // #15
+    InvokeDynamic 0s #17; // #16
+    NameAndType #18 #19; // #17
+    Utf8 "toString"; // #18
+    Utf8 "(Qcompiler/valhalla/inlinetypes/RectangleN;)Ljava/lang/String;"; // #19
+    class #21; // #20
+    Utf8 "compiler/valhalla/inlinetypes/RectangleN$ref"; // #21
+    Utf8 "()Ljava/lang/String;"; // #22
+    Utf8 "Code"; // #23
+    Utf8 "LineNumberTable"; // #24
+    Utf8 "()Qcompiler/valhalla/inlinetypes/RectangleN;"; // #25
+    Utf8 "SourceFile"; // #26
+    Utf8 "RectangleN.java"; // #27
+    Utf8 "NestHost"; // #28
+    Utf8 "BootstrapMethods"; // #29
+    MethodHandle 6b #31; // #30
+    Method #32 #33; // #31
+    class #34; // #32
+    NameAndType #35 #36; // #33
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #34
+    Utf8 "makeBootstrapMethod"; // #35
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #36
+    Utf8 "InnerClasses"; // #37
+    class #39; // #38
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #39
+    class #41; // #40
+    Utf8 "java/lang/invoke/MethodHandles"; // #41
+    Utf8 "Lookup"; // #42
+  } // Constant Pool
+
+  0x0131; // access
+  #1;// this_cpx
+  #20;// super_cpx
+
+  [] { // Interfaces
+  } // Interfaces
+
+  [] { // Fields
+    {  // field
+      0x0010; // access
+      #11; // name_index
+      #12; // descriptor_index
+      [] { // Attributes
+      } // Attributes
+    }
+    ;
+    {  // field
+      0x0010; // access
+      #15; // name_index
+      #12; // descriptor_index
+      [] { // Attributes
+      } // Attributes
+    }
+  } // Fields
+
+  [] { // Methods
+    {  // method
+      0x0011; // access
+      #18; // name_index
+      #22; // descriptor_index
+      [] { // Attributes
+        Attr(#23) { // Code
+          1; // max_stack
+          1; // max_locals
+          Bytes[]{
+            0x2ABA00100000B0;
+          }
+          [] { // Traps
+          } // end Traps
+          [] { // Attributes
+            Attr(#24) { // LineNumberTable
+              [] { // line_number_table
+                0  26;
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    }
+    ;
+    {  // method
+      0x0009; // access
+      #7; // name_index
+      #25; // descriptor_index
+      [] { // Attributes
+        Attr(#23) { // Code
+          2; // max_stack
+          1; // max_locals
+          Bytes[]{
+            0xCB00014BB800032A;
+            0x5FCC00094BB80003;
+            0x2A5FCC000D4B2AB0;
+          }
+          [] { // Traps
+          } // end Traps
+          [] { // Attributes
+            Attr(#24) { // LineNumberTable
+              [] { // line_number_table
+                0  26;
+                4  27;
+                13  28;
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    }
+  } // Methods
+
+  [] { // Attributes
+    Attr(#26) { // SourceFile
+      #27;
+    } // end SourceFile
+    ;
+    Attr(#28) { // NestHost
+      #20;
+    } // end NestHost
+    ;
+    Attr(#29) { // BootstrapMethods
+      [] { // bootstrap_methods
+        {  //  bootstrap_method
+          #30; // bootstrap_method_ref
+          [] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+    ;
+    Attr(#37) { // InnerClasses
+      [] { // classes
+        #38 #40 #42 25;
+      }
+    } // end InnerClasses
+  } // Attributes
+} // end class compiler/valhalla/inlinetypes/RectangleN
+
+class compiler/valhalla/inlinetypes/RectangleP$ref {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [] { // Constant Pool
+    ; // first element is empty
+    class #2; // #1
+    Utf8 "compiler/valhalla/inlinetypes/RectangleP$ref"; // #2
+    class #4; // #3
+    Utf8 "java/lang/Object"; // #4
+    Utf8 "SourceFile"; // #5
+    Utf8 "Rectangle.java"; // #6
+    Utf8 "NestMembers"; // #7
+    class #9; // #8
+    Utf8 "compiler/valhalla/inlinetypes/RectangleP"; // #9
+    Utf8 "PermittedSubclasses"; // #10
+  } // Constant Pool
+
+  0x0421; // access
+  #1;// this_cpx
+  #3;// super_cpx
+
+  [] { // Interfaces
+  } // Interfaces
+
+  [] { // Fields
+  } // Fields
+
+  [] { // Methods
+  } // Methods
+
+  [] { // Attributes
+    Attr(#5) { // SourceFile
+      #6;
+    } // end SourceFile
+    ;
+    Attr(#7) { // NestMembers
+      [] { // classes
+        #8;
+      }
+    } // end NestMembers
+    ;
+    Attr(#10) { // PermittedSubclasses
+      0x00010008;
+    } // end PermittedSubclasses
+  } // Attributes
+} // end class compiler/valhalla/inlinetypes/RectangleP$ref
+
+class compiler/valhalla/inlinetypes/RectangleP {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [] { // Constant Pool
+    ; // first element is empty
+    class #2; // #1
+    Utf8 "compiler/valhalla/inlinetypes/RectangleP"; // #2
+    Method #4 #5; // #3
+    class #6; // #4
+    NameAndType #7 #8; // #5
+    Utf8 "compiler/valhalla/inlinetypes/Point"; // #6
+    Utf8 "<init>"; // #7
+    Utf8 "()Qcompiler/valhalla/inlinetypes/Point;"; // #8
+    Field #1 #10; // #9
+    NameAndType #11 #12; // #10
+    Utf8 "p0"; // #11
+    Utf8 "Qcompiler/valhalla/inlinetypes/Point;"; // #12
+    Field #1 #14; // #13
+    NameAndType #15 #12; // #14
+    Utf8 "p1"; // #15
+    InvokeDynamic 0s #17; // #16
+    NameAndType #18 #19; // #17
+    Utf8 "toString"; // #18
+    Utf8 "(Qcompiler/valhalla/inlinetypes/RectangleP;)Ljava/lang/String;"; // #19
+    class #21; // #20
+    Utf8 "compiler/valhalla/inlinetypes/RectangleP$ref"; // #21
+    Utf8 "()Ljava/lang/String;"; // #22
+    Utf8 "Code"; // #23
+    Utf8 "LineNumberTable"; // #24
+    Utf8 "()Qcompiler/valhalla/inlinetypes/RectangleP;"; // #25
+    Utf8 "SourceFile"; // #26
+    Utf8 "RectangleP.java"; // #27
+    Utf8 "NestHost"; // #28
+    Utf8 "BootstrapMethods"; // #29
+    MethodHandle 6b #31; // #30
+    Method #32 #33; // #31
+    class #34; // #32
+    NameAndType #35 #36; // #33
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #34
+    Utf8 "makeBootstrapMethod"; // #35
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #36
+    Utf8 "InnerClasses"; // #37
+    class #39; // #38
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #39
+    class #41; // #40
+    Utf8 "java/lang/invoke/MethodHandles"; // #41
+    Utf8 "Lookup"; // #42
+  } // Constant Pool
+
+  0x0131; // access
+  #1;// this_cpx
+  #20;// super_cpx
+
+  [] { // Interfaces
+  } // Interfaces
+
+  [] { // Fields
+    {  // field
+      0x0010; // access
+      #11; // name_index
+      #12; // descriptor_index
+      [] { // Attributes
+      } // Attributes
+    }
+    ;
+    {  // field
+      0x0012; // access  // Access flags have been modified to make field p1 private
+      #15; // name_index
+      #12; // descriptor_index
+      [] { // Attributes
+      } // Attributes
+    }
+  } // Fields
+
+  [] { // Methods
+    {  // method
+      0x0011; // access
+      #18; // name_index
+      #22; // descriptor_index
+      [] { // Attributes
+        Attr(#23) { // Code
+          1; // max_stack
+          1; // max_locals
+          Bytes[]{
+            0x2ABA00100000B0;
+          }
+          [] { // Traps
+          } // end Traps
+          [] { // Attributes
+            Attr(#24) { // LineNumberTable
+              [] { // line_number_table
+                0  26;
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    }
+    ;
+    {  // method
+      0x0009; // access
+      #7; // name_index
+      #25; // descriptor_index
+      [] { // Attributes
+        Attr(#23) { // Code
+          2; // max_stack
+          1; // max_locals
+          Bytes[]{
+            0xCB00014BB800032A;
+            0x5FCC00094BB80003;
+            0x2A5FCC000D4B2AB0;
+          }
+          [] { // Traps
+          } // end Traps
+          [] { // Attributes
+            Attr(#24) { // LineNumberTable
+              [] { // line_number_table
+                0  26;
+                4  27;
+                13  28;
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    }
+  } // Methods
+
+  [] { // Attributes
+    Attr(#26) { // SourceFile
+      #27;
+    } // end SourceFile
+    ;
+    Attr(#28) { // NestHost
+      #20;
+    } // end NestHost
+    ;
+    Attr(#29) { // BootstrapMethods
+      [] { // bootstrap_methods
+        {  //  bootstrap_method
+          #30; // bootstrap_method_ref
+          [] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+    ;
+    Attr(#37) { // InnerClasses
+      [] { // classes
+        #38 #40 #42 25;
+      }
+    } // end InnerClasses
+  } // Attributes
+} // end class compiler/valhalla/inlinetypes/RectangleP
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/NamedRectangle.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/NamedRectangle.java
--- /dev/null
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/NamedRectangle.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package compiler.valhalla.inlinetypes;
+
+public class NamedRectangle {
+    Rectangle rect = new Rectangle();
+    String name = "";
+
+    static int getP1X(NamedRectangle nr) {
+        return nr.rect
+            .p1
+            .x;
+    }
+
+    static Point getP1(NamedRectangle nr) {
+        return nr.rect
+            .p1;
+    }
+}
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/Point.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/Point.java
--- /dev/null
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/Point.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package compiler.valhalla.inlinetypes;
+
+public inline class Point {
+    int x = 4;
+    int y = 7;
+}
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/Rectangle.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/Rectangle.java
--- /dev/null
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/Rectangle.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package compiler.valhalla.inlinetypes;
+
+public inline class Rectangle {
+    Point p0 = new Point();
+    Point p1 = new Point();
+}
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestGetfieldChains.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestGetfieldChains.java
--- /dev/null
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestGetfieldChains.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+package compiler.valhalla.inlinetypes;
+
+import java.lang.invoke.*;
+import java.lang.reflect.Method;
+import java.nio.file.NoSuchFileException;
+import java.util.Arrays;
+
+import jdk.experimental.value.MethodHandleBuilder;
+import jdk.test.lib.Asserts;
+
+/*
+ * @test
+ * @key randomness
+ * @summary Verify that chains of getfields on flattened fields are correctly optimized
+ * @modules java.base/jdk.experimental.value
+ * @library /testlibrary /test/lib /compiler/whitebox /
+ * @requires os.simpleArch == "x64"
+ * @compile TestGetfieldChains.java NamedRectangle.java Rectangle.java Point.java GetfieldChains.jcod
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
+ * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
+ *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
+ *                               compiler.valhalla.inlinetypes.InlineTypeTest
+ *                               compiler.valhalla.inlinetypes.TestGetfieldChains
+ */
+
+public class TestGetfieldChains extends InlineTypeTest {
+    public static final int C1 = COMP_LEVEL_SIMPLE;
+    public static final int C2 = COMP_LEVEL_FULL_OPTIMIZATION;
+
+    public static void main(String[] args) throws Throwable {
+        TestGetfieldChains test = new TestGetfieldChains();
+        test.run(args, TestGetfieldChains.class);
+    }
+
+    @Override
+    public int getNumScenarios() {
+        return 5;
+    }
+
+    @Override
+    public String[] getVMParameters(int scenario) {
+        switch (scenario) {
+        case 0: return new String[] { // C1 only
+                "-XX:TieredStopAtLevel=1",
+                "-XX:+TieredCompilation",
+            };
+        case 1: return new String[] { // C2 only. (Make sure the tests are correctly written)
+                "-XX:TieredStopAtLevel=4",
+                "-XX:-TieredCompilation",
+                "-XX:-OmitStackTraceInFastThrow",
+            };
+        case 2: return new String[] { // interpreter only
+                "-Xint",
+            };
+        case 3: return new String[] {
+                // Xcomp Only C1.
+                "-XX:TieredStopAtLevel=1",
+                "-XX:+TieredCompilation",
+                "-Xcomp",
+            };
+        case 4: return new String[] {
+                // Xcomp Only C2.
+                "-XX:TieredStopAtLevel=4",
+                "-XX:-TieredCompilation",
+                "-XX:-OmitStackTraceInFastThrow",
+                "-Xcomp",
+            };
+        }
+        return null;
+    }
+
+    // Simple chain of getfields ending with primitive field
+    @Test(compLevel=C1)
+    public int test1() {
+            return NamedRectangle.getP1X(new NamedRectangle());
+    }
+
+    @DontCompile
+    public void test1_verifier(boolean warmup) {
+            int res = test1();
+            Asserts.assertEQ(res, 4);
+    }
+
+    // Simple chain of getfields ending with a flattened field
+    @Test(compLevel=C1)
+    public Point test2() {
+            return NamedRectangle.getP1(new NamedRectangle());
+    }
+
+    @DontCompile
+    public void test2_verifier(boolean warmup) {
+        Point p = test2();
+        Asserts.assertEQ(p.x, 4);
+        Asserts.assertEQ(p.y, 7);
+    }
+
+    // Chain of getfields but the initial receiver is null
+    @Test(compLevel=C1)
+    public NullPointerException test3() {
+        NullPointerException npe = null;
+        try {
+            NamedRectangle.getP1X(null);
+        } catch(NullPointerException e) {
+            npe = e;
+        }
+        return npe;
+    }
+
+    @DontCompile
+    public void test3_verifier(boolean warmup) {
+        NullPointerException npe = test3();
+        Asserts.assertNE(npe, null);
+        StackTraceElement st = npe.getStackTrace()[0];
+        Asserts.assertEQ(st.getMethodName(), "getP1X");
+        Asserts.assertEQ(st.getLineNumber(), 31);       // line number depends on file NamedRectangle.java
+    }
+
+    // Chain of getfields but one getfield in the middle of the chain trigger an illegal access
+    @Test(compLevel=C1)
+    public IllegalAccessError test4() {
+        IllegalAccessError iae = null;
+        try {
+            int i = NamedRectangleP.getP1X(new NamedRectangleP());
+        } catch(IllegalAccessError e) {
+            iae = e;
+        }
+        return iae;
+    }
+
+    @DontCompile
+    public void test4_verifier(boolean warmup) {
+        IllegalAccessError iae = test4();
+        Asserts.assertNE(iae, null);
+        StackTraceElement st = iae.getStackTrace()[0];
+        Asserts.assertEQ(st.getMethodName(), "getP1X");
+        Asserts.assertEQ(st.getLineNumber(), 31);       // line number depends on jcod file generated from NamedRectangle.java
+        Asserts.assertTrue(iae.getMessage().contains("class compiler.valhalla.inlinetypes.NamedRectangleP tried to access private field compiler.valhalla.inlinetypes.RectangleP.p1"));
+    }
+
+    // Chain of getfields but the last getfield trigger a NoSuchFieldError
+    @Test(compLevel=C1)
+    public NoSuchFieldError test5() {
+        NoSuchFieldError nsfe = null;
+        try {
+            int i = NamedRectangleN.getP1X(new NamedRectangleN());
+        } catch(NoSuchFieldError e) {
+            nsfe = e;
+        }
+        return nsfe;
+    }
+
+    @DontCompile
+    public void test5_verifier(boolean warmup) {
+        NoSuchFieldError nsfe = test5();
+        Asserts.assertNE(nsfe, null);
+        StackTraceElement st = nsfe.getStackTrace()[0];
+        Asserts.assertEQ(st.getMethodName(), "getP1X");
+        Asserts.assertEQ(st.getLineNumber(), 31);       // line number depends on jcod file generated from NamedRectangle.java
+        Asserts.assertEQ(nsfe.getMessage(), "x");
+    }
+}
