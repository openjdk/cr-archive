<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorld.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.inlinetypes;
  25 
  26 import java.lang.invoke.*;
  27 import java.lang.reflect.Method;
  28 import java.util.Arrays;
  29 
  30 import jdk.experimental.value.MethodHandleBuilder;
  31 import jdk.test.lib.Asserts;
  32 
  33 /*
  34  * @test
  35  * @key randomness
  36  * @summary Test inline types in LWorld.
  37  * @modules java.base/jdk.experimental.value
  38  * @library /testlibrary /test/lib /compiler/whitebox /
  39  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  40  * @compile TestLWorld.java
  41  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  42  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  43  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  44  *                               compiler.valhalla.inlinetypes.InlineTypeTest
  45  *                               compiler.valhalla.inlinetypes.TestLWorld
  46  */
  47 public class TestLWorld extends InlineTypeTest {
  48     // Extra VM parameters for some test scenarios. See InlineTypeTest.getVMParameters()
  49     @Override
  50     public String[] getExtraVMParameters(int scenario) {
  51         switch (scenario) {
  52         case 1: return new String[] {&quot;-XX:-UseOptoBiasInlining&quot;};
  53         case 2: return new String[] {&quot;-DVerifyIR=false&quot;, &quot;-XX:-UseBiasedLocking&quot;};
  54         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UseBiasedLocking&quot;, &quot;-XX:FlatArrayElementMaxSize=-1&quot;};
  55         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;};
  56         }
  57         return null;
  58     }
  59 
  60     public static void main(String[] args) throws Throwable {
  61         TestLWorld test = new TestLWorld();
  62         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class, MyValue3.class,
  63                  MyValue3Inline.class, Test51Value.class);
  64     }
  65 
  66     // Helper methods
  67 
  68     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
  69     private static final MyValue2 testValue2 = MyValue2.createWithFieldsInline(rI, true);
  70 
  71     protected long hash() {
  72         return testValue1.hash();
  73     }
  74 
  75     // Test passing an inline type as an Object
  76     @DontInline
  77     public Object test1_dontinline1(Object o) {
  78         return o;
  79     }
  80 
  81     @DontInline
  82     public MyValue1 test1_dontinline2(Object o) {
  83         return (MyValue1)o;
  84     }
  85 
  86     @ForceInline
  87     public Object test1_inline1(Object o) {
  88         return o;
  89     }
  90 
  91     @ForceInline
  92     public MyValue1 test1_inline2(Object o) {
  93         return (MyValue1)o;
  94     }
  95 
  96     @Test()
  97     public MyValue1 test1() {
  98         MyValue1 vt = testValue1;
  99         vt = (MyValue1)test1_dontinline1(vt);
 100         vt =           test1_dontinline2(vt);
 101         vt = (MyValue1)test1_inline1(vt);
 102         vt =           test1_inline2(vt);
 103         return vt;
 104     }
 105 
 106     @DontCompile
 107     public void test1_verifier(boolean warmup) {
 108         Asserts.assertEQ(test1().hash(), hash());
 109     }
 110 
 111     // Test storing/loading inline types to/from Object and inline type fields
 112     Object objectField1 = null;
 113     Object objectField2 = null;
 114     Object objectField3 = null;
 115     Object objectField4 = null;
 116     Object objectField5 = null;
 117     Object objectField6 = null;
 118 
 119     MyValue1 valueField1 = testValue1;
 120     MyValue1 valueField2 = testValue1;
 121     MyValue1.ref valueField3 = testValue1;
 122     MyValue1 valueField4;
 123     MyValue1.ref valueField5;
 124 
 125     static MyValue1.ref staticValueField1 = testValue1;
 126     static MyValue1 staticValueField2 = testValue1;
 127     static MyValue1 staticValueField3;
 128     static MyValue1.ref staticValueField4;
 129 
 130     @DontInline
 131     public Object readValueField5() {
 132         return (Object)valueField5;
 133     }
 134 
 135     @DontInline
 136     public Object readStaticValueField4() {
 137         return (Object)staticValueField4;
 138     }
 139 
 140     @Test()
 141     public long test2(MyValue1 vt1, Object vt2) {
 142         objectField1 = vt1;
 143         objectField2 = (MyValue1)vt2;
 144         objectField3 = testValue1;
 145         objectField4 = MyValue1.createWithFieldsDontInline(rI, rL);
 146         objectField5 = valueField1;
 147         objectField6 = valueField3;
 148         valueField1 = (MyValue1)objectField1;
 149         valueField2 = (MyValue1)vt2;
 150         valueField3 = (MyValue1)vt2;
 151         staticValueField1 = (MyValue1)objectField1;
 152         staticValueField2 = (MyValue1)vt1;
 153         // Don&#39;t inline these methods because reading NULL will trigger a deoptimization
 154         if (readValueField5() != null || readStaticValueField4() != null) {
 155             throw new RuntimeException(&quot;Should be null&quot;);
 156         }
 157         return ((MyValue1)objectField1).hash() + ((MyValue1)objectField2).hash() +
 158                ((MyValue1)objectField3).hash() + ((MyValue1)objectField4).hash() +
 159                ((MyValue1)objectField5).hash() + ((MyValue1)objectField6).hash() +
 160                 valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +
 161                 staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();
 162     }
 163 
 164     @DontCompile
 165     public void test2_verifier(boolean warmup) {
 166         MyValue1 vt = testValue1;
 167         MyValue1 def = MyValue1.createDefaultDontInline();
 168         long result = test2(vt, vt);
 169         Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
 170     }
 171 
 172     // Test merging inline types and objects
 173     @Test()
 174     public Object test3(int state) {
 175         Object res = null;
 176         if (state == 0) {
 177             res = new Integer(rI);
 178         } else if (state == 1) {
 179             res = MyValue1.createWithFieldsInline(rI, rL);
 180         } else if (state == 2) {
 181             res = MyValue1.createWithFieldsDontInline(rI, rL);
 182         } else if (state == 3) {
 183             res = (MyValue1)objectField1;
 184         } else if (state == 4) {
 185             res = valueField1;
 186         } else if (state == 5) {
 187             res = null;
 188         } else if (state == 6) {
 189             res = MyValue2.createWithFieldsInline(rI, true);
 190         } else if (state == 7) {
 191             res = testValue2;
 192         }
 193         return res;
 194     }
 195 
 196     @DontCompile
 197     public void test3_verifier(boolean warmup) {
 198         objectField1 = valueField1;
 199         Object result = null;
 200         result = test3(0);
 201         Asserts.assertEQ((Integer)result, rI);
 202         result = test3(1);
 203         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 204         result = test3(2);
 205         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 206         result = test3(3);
 207         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 208         result = test3(4);
 209         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 210         result = test3(5);
 211         Asserts.assertEQ(result, null);
 212         result = test3(6);
 213         Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());
 214         result = test3(7);
 215         Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());
 216     }
 217 
 218     // Test merging inline types and objects in loops
 219     @Test()
 220     public Object test4(int iters) {
 221         Object res = new Integer(rI);
 222         for (int i = 0; i &lt; iters; ++i) {
 223             if (res instanceof Integer) {
 224                 res = MyValue1.createWithFieldsInline(rI, rL);
 225             } else {
 226                 res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
 227             }
 228         }
 229         return res;
 230     }
 231 
 232     @DontCompile
 233     public void test4_verifier(boolean warmup) {
 234         Integer result1 = (Integer)test4(0);
 235         Asserts.assertEQ(result1, rI);
 236         int iters = (Math.abs(rI) % 10) + 1;
 237         MyValue1 result2 = (MyValue1)test4(iters);
 238         MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
 239         Asserts.assertEQ(result2.hash(), vt.hash());
 240     }
 241 
 242     // Test inline types in object variables that are live at safepoint
 243     @Test(failOn = ALLOC + STORE + LOOP)
 244     public long test5(MyValue1 arg, boolean deopt) {
 245         Object vt1 = MyValue1.createWithFieldsInline(rI, rL);
 246         Object vt2 = MyValue1.createWithFieldsDontInline(rI, rL);
 247         Object vt3 = arg;
 248         Object vt4 = valueField1;
 249         if (deopt) {
 250             // uncommon trap
 251             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test5&quot;));
 252         }
 253         return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +
 254                ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();
 255     }
 256 
 257     @DontCompile
 258     public void test5_verifier(boolean warmup) {
 259         long result = test5(valueField1, !warmup);
 260         Asserts.assertEQ(result, 4*hash());
 261     }
 262 
 263     // Test comparing inline types with objects
 264     @Test(failOn = LOAD + LOOP)
 265     public boolean test6(Object arg) {
 266         Object vt = MyValue1.createWithFieldsInline(rI, rL);
 267         if (vt == arg || vt == (Object)valueField1 || vt == objectField1 || vt == null ||
 268             arg == vt || (Object)valueField1 == vt || objectField1 == vt || null == vt) {
 269             return true;
 270         }
 271         return false;
 272     }
 273 
 274     @DontCompile
 275     public void test6_verifier(boolean warmup) {
 276         boolean result = test6(null);
 277         Asserts.assertFalse(result);
 278     }
 279 
 280     // merge of inline type and non-inline type
 281     @Test
 282     public Object test7(boolean flag) {
 283         Object res = null;
 284         if (flag) {
 285             res = valueField1;
 286         } else {
 287             res = objectField1;
 288         }
 289         return res;
 290     }
 291 
 292     @DontCompile
 293     public void test7_verifier(boolean warmup) {
 294         test7(true);
 295         test7(false);
 296     }
 297 
 298     @Test
 299     public Object test8(boolean flag) {
 300         Object res = null;
 301         if (flag) {
 302             res = objectField1;
 303         } else {
 304             res = valueField1;
 305         }
 306         return res;
 307     }
 308 
 309     @DontCompile
 310     public void test8_verifier(boolean warmup) {
 311         test8(true);
 312         test8(false);
 313     }
 314 
 315     // merge of inline types in a loop, stored in an object local
 316     @Test
 317     public Object test9() {
 318         Object o = valueField1;
 319         for (int i = 1; i &lt; 100; i *= 2) {
 320             MyValue1 v = (MyValue1)o;
 321             o = MyValue1.setX(v, v.x + 1);
 322         }
 323         return o;
 324     }
 325 
 326     @DontCompile
 327     public void test9_verifier(boolean warmup) {
 328         test9();
 329     }
 330 
 331     // merge of inline types in an object local
 332     public Object test10_helper() {
 333         return valueField1;
 334     }
 335 
 336     @Test(failOn = ALLOC + LOAD + STORE)
 337     public void test10(boolean flag) {
 338         Object o = null;
 339         if (flag) {
 340             o = valueField1;
 341         } else {
 342             o = test10_helper();
 343         }
 344         valueField1 = (MyValue1)o;
 345     }
 346 
 347     @DontCompile
 348     public void test10_verifier(boolean warmup) {
 349         test10(true);
 350         test10(false);
 351     }
 352 
 353     // Interface tests
 354 
 355     @DontInline
 356     public MyInterface test11_dontinline1(MyInterface o) {
 357         return o;
 358     }
 359 
 360     @DontInline
 361     public MyValue1 test11_dontinline2(MyInterface o) {
 362         return (MyValue1)o;
 363     }
 364 
 365     @ForceInline
 366     public MyInterface test11_inline1(MyInterface o) {
 367         return o;
 368     }
 369 
 370     @ForceInline
 371     public MyValue1 test11_inline2(MyInterface o) {
 372         return (MyValue1)o;
 373     }
 374 
 375     @Test()
 376     public MyValue1 test11() {
 377         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 378         vt = (MyValue1)test11_dontinline1(vt);
 379         vt =           test11_dontinline2(vt);
 380         vt = (MyValue1)test11_inline1(vt);
 381         vt =           test11_inline2(vt);
 382         return vt;
 383     }
 384 
 385     @DontCompile
 386     public void test11_verifier(boolean warmup) {
 387         Asserts.assertEQ(test11().hash(), hash());
 388     }
 389 
 390     // Test storing/loading inline types to/from interface and inline type fields
 391     MyInterface interfaceField1 = null;
 392     MyInterface interfaceField2 = null;
 393     MyInterface interfaceField3 = null;
 394     MyInterface interfaceField4 = null;
 395     MyInterface interfaceField5 = null;
 396     MyInterface interfaceField6 = null;
 397 
 398     @DontInline
 399     public MyInterface readValueField5AsInterface() {
 400         return (MyInterface)valueField5;
 401     }
 402 
 403     @DontInline
 404     public MyInterface readStaticValueField4AsInterface() {
 405         return (MyInterface)staticValueField4;
 406     }
 407 
 408     @Test()
 409     public long test12(MyValue1 vt1, MyInterface vt2) {
 410         interfaceField1 = vt1;
 411         interfaceField2 = (MyValue1)vt2;
 412         interfaceField3 = MyValue1.createWithFieldsInline(rI, rL);
 413         interfaceField4 = MyValue1.createWithFieldsDontInline(rI, rL);
 414         interfaceField5 = valueField1;
 415         interfaceField6 = valueField3;
 416         valueField1 = (MyValue1)interfaceField1;
 417         valueField2 = (MyValue1)vt2;
 418         valueField3 = (MyValue1)vt2;
 419         staticValueField1 = (MyValue1)interfaceField1;
 420         staticValueField2 = (MyValue1)vt1;
 421         // Don&#39;t inline these methods because reading NULL will trigger a deoptimization
 422         if (readValueField5AsInterface() != null || readStaticValueField4AsInterface() != null) {
 423             throw new RuntimeException(&quot;Should be null&quot;);
 424         }
 425         return ((MyValue1)interfaceField1).hash() + ((MyValue1)interfaceField2).hash() +
 426                ((MyValue1)interfaceField3).hash() + ((MyValue1)interfaceField4).hash() +
 427                ((MyValue1)interfaceField5).hash() + ((MyValue1)interfaceField6).hash() +
 428                 valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +
 429                 staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();
 430     }
 431 
 432     @DontCompile
 433     public void test12_verifier(boolean warmup) {
 434         MyValue1 vt = testValue1;
 435         MyValue1 def = MyValue1.createDefaultDontInline();
 436         long result = test12(vt, vt);
 437         Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
 438     }
 439 
 440     class MyObject1 implements MyInterface {
 441         public int x;
 442 
 443         public MyObject1(int x) {
 444             this.x = x;
 445         }
 446 
 447         @ForceInline
 448         public long hash() {
 449             return x;
 450         }
 451     }
 452 
 453     // Test merging inline types and interfaces
 454     @Test()
 455     public MyInterface test13(int state) {
 456         MyInterface res = null;
 457         if (state == 0) {
 458             res = new MyObject1(rI);
 459         } else if (state == 1) {
 460             res = MyValue1.createWithFieldsInline(rI, rL);
 461         } else if (state == 2) {
 462             res = MyValue1.createWithFieldsDontInline(rI, rL);
 463         } else if (state == 3) {
 464             res = (MyValue1)objectField1;
 465         } else if (state == 4) {
 466             res = valueField1;
 467         } else if (state == 5) {
 468             res = null;
 469         }
 470         return res;
 471     }
 472 
 473     @DontCompile
 474     public void test13_verifier(boolean warmup) {
 475         objectField1 = valueField1;
 476         MyInterface result = null;
 477         result = test13(0);
 478         Asserts.assertEQ(((MyObject1)result).x, rI);
 479         result = test13(1);
 480         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 481         result = test13(2);
 482         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 483         result = test13(3);
 484         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 485         result = test13(4);
 486         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 487         result = test13(5);
 488         Asserts.assertEQ(result, null);
 489     }
 490 
 491     // Test merging inline types and interfaces in loops
 492     @Test()
 493     public MyInterface test14(int iters) {
 494         MyInterface res = new MyObject1(rI);
 495         for (int i = 0; i &lt; iters; ++i) {
 496             if (res instanceof MyObject1) {
 497                 res = MyValue1.createWithFieldsInline(rI, rL);
 498             } else {
 499                 res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
 500             }
 501         }
 502         return res;
 503     }
 504 
 505     @DontCompile
 506     public void test14_verifier(boolean warmup) {
 507         MyObject1 result1 = (MyObject1)test14(0);
 508         Asserts.assertEQ(result1.x, rI);
 509         int iters = (Math.abs(rI) % 10) + 1;
 510         MyValue1 result2 = (MyValue1)test14(iters);
 511         MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
 512         Asserts.assertEQ(result2.hash(), vt.hash());
 513     }
 514 
 515     // Test inline types in interface variables that are live at safepoint
 516     @Test(failOn = ALLOC + STORE + LOOP)
 517     public long test15(MyValue1 arg, boolean deopt) {
 518         MyInterface vt1 = MyValue1.createWithFieldsInline(rI, rL);
 519         MyInterface vt2 = MyValue1.createWithFieldsDontInline(rI, rL);
 520         MyInterface vt3 = arg;
 521         MyInterface vt4 = valueField1;
 522         if (deopt) {
 523             // uncommon trap
 524             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test15&quot;));
 525         }
 526         return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +
 527                ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();
 528     }
 529 
 530     @DontCompile
 531     public void test15_verifier(boolean warmup) {
 532         long result = test15(valueField1, !warmup);
 533         Asserts.assertEQ(result, 4*hash());
 534     }
 535 
 536     // Test comparing inline types with interfaces
 537     @Test(failOn = LOAD + LOOP)
 538     public boolean test16(Object arg) {
 539         MyInterface vt = MyValue1.createWithFieldsInline(rI, rL);
 540         if (vt == arg || vt == (MyInterface)valueField1 || vt == interfaceField1 || vt == null ||
 541             arg == vt || (MyInterface)valueField1 == vt || interfaceField1 == vt || null == vt) {
 542             return true;
 543         }
 544         return false;
 545     }
 546 
 547     @DontCompile
 548     public void test16_verifier(boolean warmup) {
 549         boolean result = test16(null);
 550         Asserts.assertFalse(result);
 551     }
 552 
 553     // Test subtype check when casting to inline type
 554     @Test
 555     public MyValue1 test17(MyValue1 vt, Object obj) {
 556         try {
 557             vt = (MyValue1)obj;
 558             throw new RuntimeException(&quot;ClassCastException expected&quot;);
 559         } catch (ClassCastException e) {
 560             // Expected
 561         }
 562         return vt;
 563     }
 564 
 565     @DontCompile
 566     public void test17_verifier(boolean warmup) {
 567         MyValue1 vt = testValue1;
 568         MyValue1 result = test17(vt, new Integer(rI));
 569         Asserts.assertEquals(result.hash(), vt.hash());
 570     }
 571 
 572     @Test
 573     public MyValue1 test18(MyValue1 vt) {
 574         Object obj = vt;
 575         vt = (MyValue1)obj;
 576         return vt;
 577     }
 578 
 579     @DontCompile
 580     public void test18_verifier(boolean warmup) {
 581         MyValue1 vt = testValue1;
 582         MyValue1 result = test18(vt);
 583         Asserts.assertEquals(result.hash(), vt.hash());
 584     }
 585 
 586     @Test
 587     public void test19(MyValue1 vt) {
 588         Object obj = vt;
 589         try {
 590             MyValue2 vt2 = (MyValue2)obj;
 591             throw new RuntimeException(&quot;ClassCastException expected&quot;);
 592         } catch (ClassCastException e) {
 593             // Expected
 594         }
 595     }
 596 
 597     @DontCompile
 598     public void test19_verifier(boolean warmup) {
 599         test19(valueField1);
 600     }
 601 
 602     @Test
 603     public void test20(MyValue1 vt) {
 604         Object obj = vt;
 605         try {
 606             Integer i = (Integer)obj;
 607             throw new RuntimeException(&quot;ClassCastException expected&quot;);
 608         } catch (ClassCastException e) {
 609             // Expected
 610         }
 611     }
 612 
 613     @DontCompile
 614     public void test20_verifier(boolean warmup) {
 615         test20(valueField1);
 616     }
 617 
 618     // Array tests
 619 
 620     private static final MyValue1[] testValue1Array = new MyValue1[] {testValue1,
 621                                                                       testValue1,
 622                                                                       testValue1};
 623 
 624     private static final MyValue1[][] testValue1Array2 = new MyValue1[][] {testValue1Array,
 625                                                                            testValue1Array,
 626                                                                            testValue1Array};
 627 
 628     private static final MyValue2[] testValue2Array = new MyValue2[] {testValue2,
 629                                                                       testValue2,
 630                                                                       testValue2};
 631 
 632     private static final Integer[] testIntegerArray = new Integer[42];
 633 
 634     // Test load from (flattened) inline type array disguised as object array
 635     @Test()
 636     public Object test21(Object[] oa, int index) {
 637         return oa[index];
 638     }
 639 
 640     @DontCompile
 641     public void test21_verifier(boolean warmup) {
 642         MyValue1 result = (MyValue1)test21(testValue1Array, Math.abs(rI) % 3);
 643         Asserts.assertEQ(result.hash(), hash());
 644     }
 645 
 646     // Test load from (flattened) inline type array disguised as interface array
 647     @Test()
 648     public Object test22Interface(MyInterface[] ia, int index) {
 649         return ia[index];
 650     }
 651 
 652     @DontCompile
 653     public void test22Interface_verifier(boolean warmup) {
 654         MyValue1 result = (MyValue1)test22Interface(testValue1Array, Math.abs(rI) % 3);
 655         Asserts.assertEQ(result.hash(), hash());
 656     }
 657 
 658     // Test load from (flattened) inline type array disguised as abstract array
 659     @Test()
 660     public Object test22Abstract(MyAbstract[] ia, int index) {
 661         return ia[index];
 662     }
 663 
 664     @DontCompile
 665     public void test22Abstract_verifier(boolean warmup) {
 666         MyValue1 result = (MyValue1)test22Abstract(testValue1Array, Math.abs(rI) % 3);
 667         Asserts.assertEQ(result.hash(), hash());
 668     }
 669 
 670     // Test inline store to (flattened) inline type array disguised as object array
 671     @ForceInline
 672     public void test23_inline(Object[] oa, Object o, int index) {
 673         oa[index] = o;
 674     }
 675 
 676     @Test()
 677     public void test23(Object[] oa, MyValue1 vt, int index) {
 678         test23_inline(oa, vt, index);
 679     }
 680 
 681     @DontCompile
 682     public void test23_verifier(boolean warmup) {
 683         int index = Math.abs(rI) % 3;
 684         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 685         test23(testValue1Array, vt, index);
 686         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
 687         testValue1Array[index] = testValue1;
 688         try {
 689             test23(testValue2Array, vt, index);
 690             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 691         } catch (ArrayStoreException e) {
 692             // Expected
 693         }
 694         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
 695     }
 696 
 697     @ForceInline
 698     public void test24_inline(Object[] oa, Object o, int index) {
 699         oa[index] = o;
 700     }
 701 
 702     @Test()
 703     public void test24(Object[] oa, MyValue1 vt, int index) {
 704         test24_inline(oa, vt, index);
 705     }
 706 
 707     @DontCompile
 708     public void test24_verifier(boolean warmup) {
 709         int index = Math.abs(rI) % 3;
 710         try {
 711             test24(testIntegerArray, testValue1, index);
 712             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 713         } catch (ArrayStoreException e) {
 714             // Expected
 715         }
 716     }
 717 
 718     @ForceInline
 719     public void test25_inline(Object[] oa, Object o, int index) {
 720         oa[index] = o;
 721     }
 722 
 723     @Test()
 724     public void test25(Object[] oa, MyValue1 vt, int index) {
 725         test25_inline(oa, vt, index);
 726     }
 727 
 728     @DontCompile
 729     public void test25_verifier(boolean warmup) {
 730         int index = Math.abs(rI) % 3;
 731         try {
 732             test25(null, testValue1, index);
 733             throw new RuntimeException(&quot;No NPE thrown&quot;);
 734         } catch (NullPointerException e) {
 735             // Expected
 736         }
 737     }
 738 
 739     // Test inline store to (flattened) inline type array disguised as interface array
 740     @ForceInline
 741     public void test26Interface_inline(MyInterface[] ia, MyInterface i, int index) {
 742         ia[index] = i;
 743     }
 744 
 745     @Test()
 746     public void test26Interface(MyInterface[] ia, MyValue1 vt, int index) {
 747       test26Interface_inline(ia, vt, index);
 748     }
 749 
 750     @DontCompile
 751     public void test26Interface_verifier(boolean warmup) {
 752         int index = Math.abs(rI) % 3;
 753         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 754         test26Interface(testValue1Array, vt, index);
 755         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
 756         testValue1Array[index] = testValue1;
 757         try {
 758             test26Interface(testValue2Array, vt, index);
 759             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 760         } catch (ArrayStoreException e) {
 761             // Expected
 762         }
 763         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
 764     }
 765 
 766     @ForceInline
 767     public void test27Interface_inline(MyInterface[] ia, MyInterface i, int index) {
 768         ia[index] = i;
 769     }
 770 
 771     @Test()
 772     public void test27Interface(MyInterface[] ia, MyValue1 vt, int index) {
 773         test27Interface_inline(ia, vt, index);
 774     }
 775 
 776     @DontCompile
 777     public void test27Interface_verifier(boolean warmup) {
 778         int index = Math.abs(rI) % 3;
 779         try {
 780             test27Interface(null, testValue1, index);
 781             throw new RuntimeException(&quot;No NPE thrown&quot;);
 782         } catch (NullPointerException e) {
 783             // Expected
 784         }
 785     }
 786 
 787     // Test inline store to (flattened) inline type array disguised as abstract array
 788     @ForceInline
 789     public void test26Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
 790         ia[index] = i;
 791     }
 792 
 793     @Test()
 794     public void test26Abstract(MyAbstract[] ia, MyValue1 vt, int index) {
 795       test26Abstract_inline(ia, vt, index);
 796     }
 797 
 798     @DontCompile
 799     public void test26Abstract_verifier(boolean warmup) {
 800         int index = Math.abs(rI) % 3;
 801         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 802         test26Abstract(testValue1Array, vt, index);
 803         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
 804         testValue1Array[index] = testValue1;
 805         try {
 806             test26Abstract(testValue2Array, vt, index);
 807             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 808         } catch (ArrayStoreException e) {
 809             // Expected
 810         }
 811         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
 812     }
 813 
 814     @ForceInline
 815     public void test27Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
 816         ia[index] = i;
 817     }
 818 
 819     @Test()
 820     public void test27Abstract(MyAbstract[] ia, MyValue1 vt, int index) {
 821         test27Abstract_inline(ia, vt, index);
 822     }
 823 
 824     @DontCompile
 825     public void test27Abstract_verifier(boolean warmup) {
 826         int index = Math.abs(rI) % 3;
 827         try {
 828             test27Abstract(null, testValue1, index);
 829             throw new RuntimeException(&quot;No NPE thrown&quot;);
 830         } catch (NullPointerException e) {
 831             // Expected
 832         }
 833     }
 834 
 835     // Test object store to (flattened) inline type array disguised as object array
 836     @ForceInline
 837     public void test28_inline(Object[] oa, Object o, int index) {
 838         oa[index] = o;
 839     }
 840 
 841     @Test()
 842     public void test28(Object[] oa, Object o, int index) {
 843         test28_inline(oa, o, index);
 844     }
 845 
 846     @DontCompile
 847     public void test28_verifier(boolean warmup) {
 848         int index = Math.abs(rI) % 3;
 849         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 850         test28(testValue1Array, vt1, index);
 851         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 852         try {
 853             test28(testValue1Array, testValue2, index);
 854             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 855         } catch (ArrayStoreException e) {
 856             // Expected
 857         }
 858         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 859         testValue1Array[index] = testValue1;
 860     }
 861 
 862     @ForceInline
 863     public void test29_inline(Object[] oa, Object o, int index) {
 864         oa[index] = o;
 865     }
 866 
 867     @Test()
 868     public void test29(Object[] oa, Object o, int index) {
 869         test29_inline(oa, o, index);
 870     }
 871 
 872     @DontCompile
 873     public void test29_verifier(boolean warmup) {
 874         int index = Math.abs(rI) % 3;
 875         try {
 876             test29(testValue2Array, testValue1, index);
 877             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 878         } catch (ArrayStoreException e) {
 879             // Expected
 880         }
 881         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
 882     }
 883 
 884     @ForceInline
 885     public void test30_inline(Object[] oa, Object o, int index) {
 886         oa[index] = o;
 887     }
 888 
 889     @Test()
 890     public void test30(Object[] oa, Object o, int index) {
 891         test30_inline(oa, o, index);
 892     }
 893 
 894     @DontCompile
 895     public void test30_verifier(boolean warmup) {
 896         int index = Math.abs(rI) % 3;
 897         try {
 898             test30(testIntegerArray, testValue1, index);
 899             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 900         } catch (ArrayStoreException e) {
 901             // Expected
 902         }
 903     }
 904 
 905     // Test inline store to (flattened) inline type array disguised as interface array
 906     @ForceInline
 907     public void test31Interface_inline(MyInterface[] ia, MyInterface i, int index) {
 908         ia[index] = i;
 909     }
 910 
 911     @Test()
 912     public void test31Interface(MyInterface[] ia, MyInterface i, int index) {
 913         test31Interface_inline(ia, i, index);
 914     }
 915 
 916     @DontCompile
 917     public void test31Interface_verifier(boolean warmup) {
 918         int index = Math.abs(rI) % 3;
 919         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 920         test31Interface(testValue1Array, vt1, index);
 921         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 922         try {
 923             test31Interface(testValue1Array, testValue2, index);
 924             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 925         } catch (ArrayStoreException e) {
 926             // Expected
 927         }
 928         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 929         testValue1Array[index] = testValue1;
 930     }
 931 
 932     @ForceInline
 933     public void test32Interface_inline(MyInterface[] ia, MyInterface i, int index) {
 934         ia[index] = i;
 935     }
 936 
 937     @Test()
 938     public void test32Interface(MyInterface[] ia, MyInterface i, int index) {
 939         test32Interface_inline(ia, i, index);
 940     }
 941 
 942     @DontCompile
 943     public void test32Interface_verifier(boolean warmup) {
 944         int index = Math.abs(rI) % 3;
 945         try {
 946             test32Interface(testValue2Array, testValue1, index);
 947             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 948         } catch (ArrayStoreException e) {
 949             // Expected
 950         }
 951     }
 952 
 953     // Test inline store to (flattened) inline type array disguised as abstract array
 954     @ForceInline
 955     public void test31Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
 956         ia[index] = i;
 957     }
 958 
 959     @Test()
 960     public void test31Abstract(MyAbstract[] ia, MyAbstract i, int index) {
 961         test31Abstract_inline(ia, i, index);
 962     }
 963 
 964     @DontCompile
 965     public void test31Abstract_verifier(boolean warmup) {
 966         int index = Math.abs(rI) % 3;
 967         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 968         test31Abstract(testValue1Array, vt1, index);
 969         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 970         try {
 971             test31Abstract(testValue1Array, testValue2, index);
 972             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 973         } catch (ArrayStoreException e) {
 974             // Expected
 975         }
 976         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 977         testValue1Array[index] = testValue1;
 978     }
 979 
 980     @ForceInline
 981     public void test32Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
 982         ia[index] = i;
 983     }
 984 
 985     @Test()
 986     public void test32Abstract(MyAbstract[] ia, MyAbstract i, int index) {
 987         test32Abstract_inline(ia, i, index);
 988     }
 989 
 990     @DontCompile
 991     public void test32Abstract_verifier(boolean warmup) {
 992         int index = Math.abs(rI) % 3;
 993         try {
 994             test32Abstract(testValue2Array, testValue1, index);
 995             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 996         } catch (ArrayStoreException e) {
 997             // Expected
 998         }
 999     }
1000 
1001     // Test writing null to a (flattened) inline type array disguised as object array
1002     @ForceInline
1003     public void test33_inline(Object[] oa, Object o, int index) {
1004         oa[index] = o;
1005     }
1006 
1007     @Test()
1008     public void test33(Object[] oa, Object o, int index) {
1009         test33_inline(oa, o, index);
1010     }
1011 
1012     @DontCompile
1013     public void test33_verifier(boolean warmup) {
1014         int index = Math.abs(rI) % 3;
1015         try {
1016             test33(testValue1Array, null, index);
1017             throw new RuntimeException(&quot;No NPE thrown&quot;);
1018         } catch (NullPointerException e) {
1019             // Expected
1020         }
1021         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1022     }
1023 
1024     // Test writing constant null to a (flattened) inline type array disguised as object array
1025 
1026     @ForceInline
1027     public void test34_inline(Object[] oa, Object o, int index) {
1028         oa[index] = o;
1029     }
1030 
1031     @Test()
1032     public void test34(Object[] oa, int index) {
1033         test34_inline(oa, null, index);
1034     }
1035 
1036     @DontCompile
1037     public void test34_verifier(boolean warmup) {
1038         int index = Math.abs(rI) % 3;
1039         try {
1040             test34(testValue1Array, index);
1041             throw new RuntimeException(&quot;No NPE thrown&quot;);
1042         } catch (NullPointerException e) {
1043             // Expected
1044         }
1045         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1046     }
1047 
1048     // Test writing constant null to a (flattened) inline type array
1049 
1050     private static final MethodHandle setArrayElementNull = MethodHandleBuilder.loadCode(MethodHandles.lookup(),
1051         &quot;setArrayElementNull&quot;,
1052         MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class),
1053         CODE -&gt; {
1054             CODE.
1055             aload_1().
1056             iload_2().
1057             aconst_null().
1058             aastore().
1059             return_();
1060         });
1061 
1062     @Test()
1063     public void test35(MyValue1[] va, int index) throws Throwable {
1064         setArrayElementNull.invoke(this, va, index);
1065     }
1066 
1067     @DontCompile
1068     public void test35_verifier(boolean warmup) throws Throwable {
1069         int index = Math.abs(rI) % 3;
1070         try {
1071             test35(testValue1Array, index);
1072             throw new RuntimeException(&quot;No NPE thrown&quot;);
1073         } catch (NullPointerException e) {
1074             // Expected
1075         }
1076         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1077     }
1078 
1079     // Test writing an inline type to a null inline type array
1080     @Test()
1081     public void test36(MyValue1[] va, MyValue1 vt, int index) {
1082         va[index] = vt;
1083     }
1084 
1085     @DontCompile
1086     public void test36_verifier(boolean warmup) {
1087         int index = Math.abs(rI) % 3;
1088         try {
1089             test36(null, testValue1Array[index], index);
1090             throw new RuntimeException(&quot;No NPE thrown&quot;);
1091         } catch (NullPointerException e) {
1092             // Expected
1093         }
1094     }
1095 
1096     // Test incremental inlining
1097     @ForceInline
1098     public void test37_inline(Object[] oa, Object o, int index) {
1099         oa[index] = o;
1100     }
1101 
1102     @Test()
1103     public void test37(MyValue1[] va, Object o, int index) {
1104         test37_inline(va, o, index);
1105     }
1106 
1107     @DontCompile
1108     public void test37_verifier(boolean warmup) {
1109         int index = Math.abs(rI) % 3;
1110         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
1111         test37(testValue1Array, vt1, index);
1112         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
1113         try {
1114             test37(testValue1Array, testValue2, index);
1115             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1116         } catch (ArrayStoreException e) {
1117             // Expected
1118         }
1119         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
1120         testValue1Array[index] = testValue1;
1121     }
1122 
1123     // Test merging of inline type arrays
1124 
1125     @ForceInline
1126     public Object[] test38_inline() {
1127         return new MyValue1[42];
1128     }
1129 
1130     @Test()
1131     public Object[] test38(Object[] oa, Object o, int i1, int i2, int num) {
1132         Object[] result = null;
1133         switch (num) {
1134         case 0:
1135             result = test38_inline();
1136             break;
1137         case 1:
1138             result = oa;
1139             break;
1140         case 2:
1141             result = testValue1Array;
1142             break;
1143         case 3:
1144             result = testValue2Array;
1145             break;
1146         case 4:
1147             result = testIntegerArray;
1148             break;
1149         case 5:
1150             result = null;
1151             break;
1152         case 6:
1153             result = testValue1Array2;
1154             break;
1155         }
1156         result[i1] = result[i2];
1157         result[i2] = o;
1158         return result;
1159     }
1160 
1161     @DontCompile
1162     public void test38_verifier(boolean warmup) {
1163         int index = Math.abs(rI) % 3;
1164         MyValue1[] va = new MyValue1[42];
1165         Object[] result = test38(null, testValue1, index, index, 0);
1166         Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());
1167         result = test38(testValue1Array, testValue1, index, index, 1);
1168         Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());
1169         result = test38(null, testValue1, index, index, 2);
1170         Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());
1171         result = test38(null, testValue2, index, index, 3);
1172         Asserts.assertEQ(((MyValue2)result[index]).hash(), testValue2.hash());
1173         try {
1174             result = test38(null, null, index, index, 3);
1175             throw new RuntimeException(&quot;No NPE thrown&quot;);
1176         } catch (NullPointerException e) {
1177             // Expected
1178         }
1179         result = test38(null, null, index, index, 4);
1180         try {
1181             result = test38(null, testValue1, index, index, 4);
1182             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1183         } catch (ArrayStoreException e) {
1184             // Expected
1185         }
1186         try {
1187             result = test38(null, testValue1, index, index, 5);
1188             throw new RuntimeException(&quot;No NPE thrown&quot;);
1189         } catch (NullPointerException e) {
1190             // Expected
1191         }
1192         result = test38(null, testValue1Array, index, index, 6);
1193         Asserts.assertEQ(((MyValue1[][])result)[index][index].hash(), testValue1.hash());
1194     }
1195 
1196     @ForceInline
1197     public Object test39_inline() {
1198         return new MyValue1[42];
1199     }
1200 
1201     // Same as above but merging into Object instead of Object[]
1202     @Test()
1203     public Object test39(Object oa, Object o, int i1, int i2, int num) {
1204         Object result = null;
1205         switch (num) {
1206         case 0:
1207             result = test39_inline();
1208             break;
1209         case 1:
1210             result = oa;
1211             break;
1212         case 2:
1213             result = testValue1Array;
1214             break;
1215         case 3:
1216             result = testValue2Array;
1217             break;
1218         case 4:
1219             result = testIntegerArray;
1220             break;
1221         case 5:
1222             result = null;
1223             break;
1224         case 6:
1225             result = testValue1;
1226             break;
1227         case 7:
1228             result = testValue2;
1229             break;
1230         case 8:
1231             result = MyValue1.createWithFieldsInline(rI, rL);
1232             break;
1233         case 9:
1234             result = new Integer(42);
1235             break;
1236         case 10:
1237             result = testValue1Array2;
1238             break;
1239         }
1240         if (result instanceof Object[]) {
1241             ((Object[])result)[i1] = ((Object[])result)[i2];
1242             ((Object[])result)[i2] = o;
1243         }
1244         return result;
1245     }
1246 
1247     @DontCompile
1248     public void test39_verifier(boolean warmup) {
1249         int index = Math.abs(rI) % 3;
1250         MyValue1[] va = new MyValue1[42];
1251         Object result = test39(null, testValue1, index, index, 0);
1252         Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());
1253         result = test39(testValue1Array, testValue1, index, index, 1);
1254         Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());
1255         result = test39(null, testValue1, index, index, 2);
1256         Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());
1257         result = test39(null, testValue2, index, index, 3);
1258         Asserts.assertEQ(((MyValue2[])result)[index].hash(), testValue2.hash());
1259         try {
1260             result = test39(null, null, index, index, 3);
1261             throw new RuntimeException(&quot;No NPE thrown&quot;);
1262         } catch (NullPointerException e) {
1263             // Expected
1264         }
1265         result = test39(null, null, index, index, 4);
1266         try {
1267             result = test39(null, testValue1, index, index, 4);
1268             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1269         } catch (ArrayStoreException e) {
1270             // Expected
1271         }
1272         result = test39(null, testValue1, index, index, 5);
1273         Asserts.assertEQ(result, null);
1274         result = test39(null, testValue1, index, index, 6);
1275         Asserts.assertEQ(((MyValue1)result).hash(), testValue1.hash());
1276         result = test39(null, testValue1, index, index, 7);
1277         Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());
1278         result = test39(null, testValue1, index, index, 8);
1279         Asserts.assertEQ(((MyValue1)result).hash(), testValue1.hash());
1280         result = test39(null, testValue1, index, index, 9);
1281         Asserts.assertEQ(((Integer)result), 42);
1282         result = test39(null, testValue1Array, index, index, 10);
1283         Asserts.assertEQ(((MyValue1[][])result)[index][index].hash(), testValue1.hash());
1284     }
1285 
1286     // Test instanceof with inline types and arrays
1287     @Test()
1288     public long test40(Object o, int index) {
1289         if (o instanceof MyValue1) {
1290           return ((MyValue1)o).hashInterpreted();
1291         } else if (o instanceof MyValue1[]) {
1292           return ((MyValue1[])o)[index].hashInterpreted();
1293         } else if (o instanceof MyValue2) {
1294           return ((MyValue2)o).hash();
1295         } else if (o instanceof MyValue2[]) {
1296           return ((MyValue2[])o)[index].hash();
1297         } else if (o instanceof MyValue1[][]) {
1298           return ((MyValue1[][])o)[index][index].hash();
1299         } else if (o instanceof Long) {
1300           return (long)o;
1301         }
1302         return 0;
1303     }
1304 
1305     @DontCompile
1306     public void test40_verifier(boolean warmup) {
1307         int index = Math.abs(rI) % 3;
1308         long result = test40(testValue1, 0);
1309         Asserts.assertEQ(result, testValue1.hash());
1310         result = test40(testValue1Array, index);
1311         Asserts.assertEQ(result, testValue1.hash());
1312         result = test40(testValue2, index);
1313         Asserts.assertEQ(result, testValue2.hash());
1314         result = test40(testValue2Array, index);
1315         Asserts.assertEQ(result, testValue2.hash());
1316         result = test40(testValue1Array2, index);
1317         Asserts.assertEQ(result, testValue1.hash());
1318         result = test40(new Long(42), index);
1319         Asserts.assertEQ(result, 42L);
1320     }
1321 
1322     // Test for bug in Escape Analysis
1323     @DontInline
1324     public void test41_dontinline(Object o) {
1325         Asserts.assertEQ(o, rI);
1326     }
1327 
1328     @Test()
1329     public void test41() {
1330         MyValue1[] vals = new MyValue1[] {testValue1};
1331         test41_dontinline(vals[0].oa[0]);
1332         test41_dontinline(vals[0].oa[0]);
1333     }
1334 
1335     @DontCompile
1336     public void test41_verifier(boolean warmup) {
1337         test41();
1338     }
1339 
1340     // Test for bug in Escape Analysis
1341     private static final MyValue1.ref test42VT1 = MyValue1.createWithFieldsInline(rI, rL);
1342     private static final MyValue1.ref test42VT2 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
1343 
1344     @Test()
1345     public void test42() {
1346         MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};
1347         Asserts.assertEQ(vals[0].hash(), test42VT1.hash());
1348         Asserts.assertEQ(vals[1].hash(), test42VT2.hash());
1349     }
1350 
1351     @DontCompile
1352     public void test42_verifier(boolean warmup) {
1353         if (!warmup) test42(); // We need -Xcomp behavior
1354     }
1355 
1356     // Test for bug in Escape Analysis
1357     @Test()
1358     public long test43(boolean deopt) {
1359         MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};
1360 
1361         if (deopt) {
1362             // uncommon trap
1363             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test43&quot;));
1364             Asserts.assertEQ(vals[0].hash(), test42VT1.hash());
1365             Asserts.assertEQ(vals[1].hash(), test42VT2.hash());
1366         }
1367 
1368         return vals[0].hash();
1369     }
1370 
1371     @DontCompile
1372     public void test43_verifier(boolean warmup) {
1373         test43(!warmup);
1374     }
1375 
1376     // Tests writing an array element with a (statically known) incompatible type
1377     private static final MethodHandle setArrayElementIncompatible = MethodHandleBuilder.loadCode(MethodHandles.lookup(),
1378         &quot;setArrayElementIncompatible&quot;,
1379         MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, MyValue2.class),
1380         CODE -&gt; {
1381             CODE.
1382             aload_1().
1383             iload_2().
1384             aload_3().
1385             aastore().
1386             return_();
1387         });
1388 
1389     @Test()
1390     public void test44(MyValue1[] va, int index, MyValue2 v) throws Throwable {
1391         setArrayElementIncompatible.invoke(this, va, index, v);
1392     }
1393 
1394     @DontCompile
1395     public void test44_verifier(boolean warmup) throws Throwable {
1396         int index = Math.abs(rI) % 3;
1397         try {
1398             test44(testValue1Array, index, testValue2);
1399             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1400         } catch (ArrayStoreException e) {
1401             // Expected
1402         }
1403         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1404     }
1405 
1406     // Tests writing an array element with a (statically known) incompatible type
1407     @ForceInline
1408     public void test45_inline(Object[] oa, Object o, int index) {
1409         oa[index] = o;
1410     }
1411 
1412     @Test()
1413     public void test45(MyValue1[] va, int index, MyValue2 v) throws Throwable {
1414         test45_inline(va, v, index);
1415     }
1416 
1417     @DontCompile
1418     public void test45_verifier(boolean warmup) throws Throwable {
1419         int index = Math.abs(rI) % 3;
1420         try {
1421             test45(testValue1Array, index, testValue2);
1422             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1423         } catch (ArrayStoreException e) {
1424             // Expected
1425         }
1426         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1427     }
1428 
1429     // instanceof tests with inline types
1430     @Test
1431     public boolean test46(MyValue1 vt) {
1432         Object obj = vt;
1433         return obj instanceof MyValue1;
1434     }
1435 
1436     @DontCompile
1437     public void test46_verifier(boolean warmup) {
1438         MyValue1 vt = testValue1;
1439         boolean result = test46(vt);
1440         Asserts.assertTrue(result);
1441     }
1442 
1443     @Test
1444     public boolean test47(MyValue1 vt) {
1445         Object obj = vt;
1446         return obj instanceof MyValue2;
1447     }
1448 
1449     @DontCompile
1450     public void test47_verifier(boolean warmup) {
1451         MyValue1 vt = testValue1;
1452         boolean result = test47(vt);
1453         Asserts.assertFalse(result);
1454     }
1455 
1456     @Test
1457     public boolean test48(Object obj) {
1458         return obj instanceof MyValue1;
1459     }
1460 
1461     @DontCompile
1462     public void test48_verifier(boolean warmup) {
1463         MyValue1 vt = testValue1;
1464         boolean result = test48(vt);
1465         Asserts.assertTrue(result);
1466     }
1467 
1468     @Test
1469     public boolean test49(Object obj) {
1470         return obj instanceof MyValue2;
1471     }
1472 
1473     @DontCompile
1474     public void test49_verifier(boolean warmup) {
1475         MyValue1 vt = testValue1;
1476         boolean result = test49(vt);
1477         Asserts.assertFalse(result);
1478     }
1479 
1480     @Test
1481     public boolean test50(Object obj) {
1482         return obj instanceof MyValue1;
1483     }
1484 
1485     @DontCompile
1486     public void test50_verifier(boolean warmup) {
1487         boolean result = test49(new Integer(42));
1488         Asserts.assertFalse(result);
1489     }
1490 
1491     // Inline type with some non-flattened fields
1492     final inline class Test51Value {
1493         final Object objectField1;
1494         final Object objectField2;
1495         final Object objectField3;
1496         final Object objectField4;
1497         final Object objectField5;
1498         final Object objectField6;
1499 
1500         final MyValue1 valueField1;
1501         final MyValue1 valueField2;
1502         final MyValue1.ref valueField3;
1503         final MyValue1 valueField4;
1504         final MyValue1.ref valueField5;
1505 
1506         public Test51Value() {
1507             objectField1 = null;
1508             objectField2 = null;
1509             objectField3 = null;
1510             objectField4 = null;
1511             objectField5 = null;
1512             objectField6 = null;
1513             valueField1 = testValue1;
1514             valueField2 = testValue1;
1515             valueField3 = testValue1;
1516             valueField4 = MyValue1.createDefaultDontInline();
1517             valueField5 = MyValue1.createDefaultDontInline();
1518         }
1519 
1520         public Test51Value(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6,
1521                            MyValue1 vt1, MyValue1 vt2, MyValue1.ref vt3, MyValue1 vt4, MyValue1.ref vt5) {
1522             objectField1 = o1;
1523             objectField2 = o2;
1524             objectField3 = o3;
1525             objectField4 = o4;
1526             objectField5 = o5;
1527             objectField6 = o6;
1528             valueField1 = vt1;
1529             valueField2 = vt2;
1530             valueField3 = vt3;
1531             valueField4 = vt4;
1532             valueField5 = vt5;
1533         }
1534 
1535         @ForceInline
1536         public long test(Test51Value holder, MyValue1 vt1, Object vt2) {
1537             holder = new Test51Value(vt1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1538                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1539             holder = new Test51Value(holder.objectField1, (MyValue1)vt2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1540                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1541             holder = new Test51Value(holder.objectField1, holder.objectField2, testValue1, holder.objectField4, holder.objectField5, holder.objectField6,
1542                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1543             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, MyValue1.createWithFieldsDontInline(rI, rL), holder.objectField5, holder.objectField6,
1544                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1545             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.valueField1, holder.objectField6,
1546                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1547             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.valueField3,
1548                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1549             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1550                                      (MyValue1)holder.objectField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1551             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1552                                      holder.valueField1, (MyValue1)vt2, holder.valueField3, holder.valueField4, holder.valueField5);
1553             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1554                                      holder.valueField1, holder.valueField2, (MyValue1)vt2, holder.valueField4, holder.valueField5);
1555 
1556             return ((MyValue1)holder.objectField1).hash() +
1557                    ((MyValue1)holder.objectField2).hash() +
1558                    ((MyValue1)holder.objectField3).hash() +
1559                    ((MyValue1)holder.objectField4).hash() +
1560                    ((MyValue1)holder.objectField5).hash() +
1561                    ((MyValue1)holder.objectField6).hash() +
1562                    holder.valueField1.hash() +
1563                    holder.valueField2.hash() +
1564                    holder.valueField3.hash() +
1565                    holder.valueField4.hashPrimitive();
1566         }
1567     }
1568 
1569     // Same as test2 but with field holder being an inline type
1570     @Test()
1571     public long test51(Test51Value holder, MyValue1 vt1, Object vt2) {
1572         return holder.test(holder, vt1, vt2);
1573     }
1574 
1575     @DontCompile
1576     public void test51_verifier(boolean warmup) {
1577         MyValue1 vt = testValue1;
1578         MyValue1 def = MyValue1.createDefaultDontInline();
1579         Test51Value holder = new Test51Value();
1580         Asserts.assertEQ(testValue1.hash(), vt.hash());
1581         Asserts.assertEQ(holder.valueField1.hash(), vt.hash());
1582         long result = test51(holder, vt, vt);
1583         Asserts.assertEQ(result, 9*vt.hash() + def.hashPrimitive());
1584     }
1585 
1586     // Access non-flattened, uninitialized inline type field with inline type holder
1587     @Test()
1588     public void test52(Test51Value holder) {
1589         if ((Object)holder.valueField5 != null) {
1590             throw new RuntimeException(&quot;Should be null&quot;);
1591         }
1592     }
1593 
1594     @DontCompile
1595     public void test52_verifier(boolean warmup) {
1596         Test51Value vt = Test51Value.default;
1597         test52(vt);
1598     }
1599 
1600     // Merging inline types of different types
1601     @Test()
1602     public Object test53(Object o, boolean b) {
1603         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1604         return b ? vt : o;
1605     }
1606 
1607     @DontCompile
1608     public void test53_verifier(boolean warmup) {
1609         test53(new Object(), false);
1610         MyValue1 result = (MyValue1)test53(new Object(), true);
1611         Asserts.assertEQ(result.hash(), hash());
1612     }
1613 
1614     @Test()
1615     public Object test54(boolean b) {
1616         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1617         return b ? vt : testValue2;
1618     }
1619 
1620     @DontCompile
1621     public void test54_verifier(boolean warmup) {
1622         MyValue1 result1 = (MyValue1)test54(true);
1623         Asserts.assertEQ(result1.hash(), hash());
1624         MyValue2 result2 = (MyValue2)test54(false);
1625         Asserts.assertEQ(result2.hash(), testValue2.hash());
1626     }
1627 
1628     @Test()
1629     public Object test55(boolean b) {
1630         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI, rL);
1631         MyValue2 vt2 = MyValue2.createWithFieldsInline(rI, true);
1632         return b ? vt1 : vt2;
1633     }
1634 
1635     @DontCompile
1636     public void test55_verifier(boolean warmup) {
1637         MyValue1 result1 = (MyValue1)test55(true);
1638         Asserts.assertEQ(result1.hash(), hash());
1639         MyValue2 result2 = (MyValue2)test55(false);
1640         Asserts.assertEQ(result2.hash(), testValue2.hash());
1641     }
1642 
1643     // Test synchronization on inline types
1644     @Test()
1645     public void test56(Object vt) {
1646         synchronized (vt) {
1647             throw new RuntimeException(&quot;test56 failed: synchronization on inline type should not succeed&quot;);
1648         }
1649     }
1650 
1651     @DontCompile
1652     public void test56_verifier(boolean warmup) {
1653         try {
1654             test56(testValue1);
1655             throw new RuntimeException(&quot;test56 failed: no exception thrown&quot;);
1656         } catch (IllegalMonitorStateException ex) {
1657             // Expected
1658         }
1659     }
1660 
1661     @ForceInline
1662     public void test57_inline(Object vt) {
1663         synchronized (vt) {
1664             throw new RuntimeException(&quot;test57 failed: synchronization on inline type should not succeed&quot;);
1665         }
1666     }
1667 
1668     @Test()
1669     public void test57(MyValue1 vt) {
1670         test57_inline(vt);
1671     }
1672 
1673     @DontCompile
1674     public void test57_verifier(boolean warmup) {
1675         try {
1676             test57(testValue1);
1677             throw new RuntimeException(&quot;test57 failed: no exception thrown&quot;);
1678         } catch (IllegalMonitorStateException ex) {
1679             // Expected
1680         }
1681     }
1682 
1683     @ForceInline
1684     public void test58_inline(Object vt) {
1685         synchronized (vt) {
1686             throw new RuntimeException(&quot;test58 failed: synchronization on inline type should not succeed&quot;);
1687         }
1688     }
1689 
1690     @Test()
1691     public void test58() {
1692         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1693         test58_inline(vt);
1694     }
1695 
1696     @DontCompile
1697     public void test58_verifier(boolean warmup) {
1698         try {
1699             test58();
1700             throw new RuntimeException(&quot;test58 failed: no exception thrown&quot;);
1701         } catch (IllegalMonitorStateException ex) {
1702             // Expected
1703         }
1704     }
1705 
1706     @Test()
1707     public void test59(Object o, boolean b) {
1708         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1709         Object sync = b ? vt : o;
1710         synchronized (sync) {
1711             if (b) {
1712                 throw new RuntimeException(&quot;test59 failed: synchronization on inline type should not succeed&quot;);
1713             }
1714         }
1715     }
1716 
1717     @DontCompile
1718     public void test59_verifier(boolean warmup) {
1719         test59(new Object(), false);
1720         try {
1721             test59(new Object(), true);
1722             throw new RuntimeException(&quot;test59 failed: no exception thrown&quot;);
1723         } catch (IllegalMonitorStateException ex) {
1724             // Expected
1725         }
1726     }
1727 
1728     @Test()
1729     public void test60(boolean b) {
1730         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1731         Object sync = b ? vt : testValue2;
1732         synchronized (sync) {
1733             throw new RuntimeException(&quot;test60 failed: synchronization on inline type should not succeed&quot;);
1734         }
1735     }
1736 
1737     @DontCompile
1738     public void test60_verifier(boolean warmup) {
1739         try {
1740             test60(false);
1741             throw new RuntimeException(&quot;test60 failed: no exception thrown&quot;);
1742         } catch (IllegalMonitorStateException ex) {
1743             // Expected
1744         }
1745         try {
1746             test60(true);
1747             throw new RuntimeException(&quot;test60 failed: no exception thrown&quot;);
1748         } catch (IllegalMonitorStateException ex) {
1749             // Expected
1750         }
1751     }
1752 
1753     // Test catching the IllegalMonitorStateException in compiled code
1754     @Test()
1755     public void test61(Object vt) {
1756         boolean thrown = false;
1757         try {
1758             synchronized (vt) {
1759                 throw new RuntimeException(&quot;test61 failed: no exception thrown&quot;);
1760             }
1761         } catch (IllegalMonitorStateException ex) {
1762             thrown = true;
1763         }
1764         if (!thrown) {
1765             throw new RuntimeException(&quot;test61 failed: no exception thrown&quot;);
1766         }
1767     }
1768 
1769     @DontCompile
1770     public void test61_verifier(boolean warmup) {
1771         test61(testValue1);
1772     }
1773 
1774     @Test()
1775     public void test62(Object o) {
1776         try {
1777             synchronized (o) { }
1778         } catch (IllegalMonitorStateException ex) {
1779             // Expected
1780             return;
1781         }
1782         throw new RuntimeException(&quot;test62 failed: no exception thrown&quot;);
1783     }
1784 
1785     @DontCompile
1786     public void test62_verifier(boolean warmup) {
1787         test62(testValue1);
1788     }
1789 
1790     // Test synchronization without any instructions in the synchronized block
1791     @Test()
1792     public void test63(Object o) {
1793         synchronized (o) { }
1794     }
1795 
1796     @DontCompile
1797     public void test63_verifier(boolean warmup) {
1798         try {
1799             test63(testValue1);
1800         } catch (IllegalMonitorStateException ex) {
1801             // Expected
1802             return;
1803         }
1804         throw new RuntimeException(&quot;test63 failed: no exception thrown&quot;);
1805     }
1806 
1807     // type system test with interface and inline type
1808     @ForceInline
1809     public MyInterface test64Interface_helper(MyValue1 vt) {
1810         return vt;
1811     }
1812 
1813     @Test()
1814     public MyInterface test64Interface(MyValue1 vt) {
1815         return test64Interface_helper(vt);
1816     }
1817 
1818     @DontCompile
1819     public void test64Interface_verifier(boolean warmup) {
1820         test64Interface(testValue1);
1821     }
1822 
1823     // type system test with abstract and inline type
1824     @ForceInline
1825     public MyAbstract test64Abstract_helper(MyValue1 vt) {
1826         return vt;
1827     }
1828 
1829     @Test()
1830     public MyAbstract test64Abstract(MyValue1 vt) {
1831         return test64Abstract_helper(vt);
1832     }
1833 
1834     @DontCompile
1835     public void test64Abstract_verifier(boolean warmup) {
1836         test64Abstract(testValue1);
1837     }
1838 
1839     // Array store tests
1840     @Test()
1841     public void test65(Object[] array, MyValue1 vt) {
1842         array[0] = vt;
1843     }
1844 
1845     @DontCompile
1846     public void test65_verifier(boolean warmup) {
1847         Object[] array = new Object[1];
1848         test65(array, testValue1);
1849         Asserts.assertEQ(((MyValue1)array[0]).hash(), testValue1.hash());
1850     }
1851 
1852     @Test()
1853     public void test66(Object[] array, MyValue1 vt) {
1854         array[0] = vt;
1855     }
1856 
1857     @DontCompile
1858     public void test66_verifier(boolean warmup) {
1859         MyValue1[] array = new MyValue1[1];
1860         test66(array, testValue1);
1861         Asserts.assertEQ(array[0].hash(), testValue1.hash());
1862     }
1863 
1864     @Test()
1865     public void test67(Object[] array, Object vt) {
1866         array[0] = vt;
1867     }
1868 
1869     @DontCompile
1870     public void test67_verifier(boolean warmup) {
1871         MyValue1[] array = new MyValue1[1];
1872         test67(array, testValue1);
1873         Asserts.assertEQ(array[0].hash(), testValue1.hash());
1874     }
1875 
1876     @Test()
1877     public void test68(Object[] array, Integer o) {
1878         array[0] = o;
1879     }
1880 
1881     @DontCompile
1882     public void test68_verifier(boolean warmup) {
1883         Integer[] array = new Integer[1];
1884         test68(array, 1);
1885         Asserts.assertEQ(array[0], Integer.valueOf(1));
1886     }
1887 
1888     // Test convertion between an inline type and java.lang.Object without an allocation
1889     @ForceInline
1890     public Object test69_sum(Object a, Object b) {
1891         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
1892         return MyValue1.setX(((MyValue1)a), sum);
1893     }
1894 
1895     @Test(failOn = ALLOC + STORE)
1896     public int test69(MyValue1[] array) {
1897         MyValue1 result = MyValue1.createDefaultInline();
1898         for (int i = 0; i &lt; array.length; ++i) {
1899             result = (MyValue1)test69_sum(result, array[i]);
1900         }
1901         return result.x;
1902     }
1903 
1904     @DontCompile
1905     public void test69_verifier(boolean warmup) {
1906         int result = test69(testValue1Array);
1907         Asserts.assertEQ(result, rI * testValue1Array.length);
1908     }
1909 
1910     // Same as test69 but with an Interface
1911     @ForceInline
1912     public MyInterface test70Interface_sum(MyInterface a, MyInterface b) {
1913         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
1914         return MyValue1.setX(((MyValue1)a), sum);
1915     }
1916 
1917     @Test(failOn = ALLOC + STORE)
1918     public int test70Interface(MyValue1[] array) {
1919         MyValue1 result = MyValue1.createDefaultInline();
1920         for (int i = 0; i &lt; array.length; ++i) {
1921             result = (MyValue1)test70Interface_sum(result, array[i]);
1922         }
1923         return result.x;
1924     }
1925 
1926     @DontCompile
1927     public void test70Interface_verifier(boolean warmup) {
1928         int result = test70Interface(testValue1Array);
1929         Asserts.assertEQ(result, rI * testValue1Array.length);
1930     }
1931 
1932     // Same as test69 but with an Abstract
1933     @ForceInline
1934     public MyAbstract test70Abstract_sum(MyAbstract a, MyAbstract b) {
1935         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
1936         return MyValue1.setX(((MyValue1)a), sum);
1937     }
1938 
1939     @Test(failOn = ALLOC + STORE)
1940     public int test70Abstract(MyValue1[] array) {
1941         MyValue1 result = MyValue1.createDefaultInline();
1942         for (int i = 0; i &lt; array.length; ++i) {
1943             result = (MyValue1)test70Abstract_sum(result, array[i]);
1944         }
1945         return result.x;
1946     }
1947 
1948     @DontCompile
1949     public void test70Abstract_verifier(boolean warmup) {
1950         int result = test70Abstract(testValue1Array);
1951         Asserts.assertEQ(result, rI * testValue1Array.length);
1952     }
1953 
1954     // Test that allocated inline type is not used in non-dominated path
1955     public MyValue1 test71_inline(Object obj) {
1956         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1957         try {
1958             vt = (MyValue1)obj;
1959             throw new RuntimeException(&quot;NullPointerException expected&quot;);
1960         } catch (NullPointerException e) {
1961             // Expected
1962         }
1963         return vt;
1964     }
1965 
1966     @Test
1967     public MyValue1 test71() {
1968         return test71_inline(null);
1969     }
1970 
1971     @DontCompile
1972     public void test71_verifier(boolean warmup) {
1973         MyValue1 vt = test71();
1974         Asserts.assertEquals(vt.hash(), hash());
1975     }
1976 
1977     // Test calling a method on an uninitialized inline type
1978     final inline class Test72Value {
1979         final int x = 42;
1980         public int get() {
1981             return x;
1982         }
1983     }
1984 
1985     // Make sure Test72Value is loaded but not initialized
1986     public void unused(Test72Value vt) { }
1987 
1988     @Test
1989     @Warmup(0)
1990     public int test72() {
1991         Test72Value vt = Test72Value.default;
1992         return vt.get();
1993     }
1994 
1995     @DontCompile
1996     public void test72_verifier(boolean warmup) {
1997         int result = test72();
1998         Asserts.assertEquals(result, 0);
1999     }
2000 
2001     // Tests for loading/storing unkown values
2002     @Test
2003     public Object test73(Object[] va) {
2004         return va[0];
2005     }
2006 
2007     @DontCompile
2008     public void test73_verifier(boolean warmup) {
2009         MyValue1 vt = (MyValue1)test73(testValue1Array);
2010         Asserts.assertEquals(testValue1Array[0].hash(), vt.hash());
2011     }
2012 
2013     @Test
2014     public void test74(Object[] va, Object vt) {
2015         va[0] = vt;
2016     }
2017 
2018     @DontCompile
2019     public void test74_verifier(boolean warmup) {
2020         MyValue1[] va = new MyValue1[1];
2021         test74(va, testValue1);
2022         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2023     }
2024 
2025     // Verify that mixing instances and arrays with the clone api
2026     // doesn&#39;t break anything
2027     @Test
2028     public Object test75(Object o) {
2029         MyValue1[] va = new MyValue1[1];
2030         Object[] next = va;
2031         Object[] arr = va;
2032         for (int i = 0; i &lt; 10; i++) {
2033             arr = next;
2034             next = new Integer[1];
2035         }
2036         return arr[0];
2037     }
2038 
2039     @DontCompile
2040     public void test75_verifier(boolean warmup) {
2041         test75(42);
2042     }
2043 
2044     // Casting a null Integer to a (non-nullable) inline type should throw a NullPointerException
2045     @ForceInline
2046     public MyValue1 test76_helper(Object o) {
2047         return (MyValue1)o;
2048     }
2049 
2050     @Test
2051     public MyValue1 test76(Integer i) throws Throwable {
2052         return test76_helper(i);
2053     }
2054 
2055     @DontCompile
2056     public void test76_verifier(boolean warmup) throws Throwable {
2057         try {
2058             test76(null);
2059             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2060         } catch (NullPointerException e) {
2061             // Expected
2062         } catch (Exception e) {
2063             throw new RuntimeException(&quot;test76 failed: unexpected exception&quot;, e);
2064         }
2065     }
2066 
2067     // Casting an Integer to a (non-nullable) inline type should throw a ClassCastException
2068     @ForceInline
2069     public MyValue1 test77_helper(Object o) {
2070         return (MyValue1)o;
2071     }
2072 
2073     @Test
2074     public MyValue1 test77(Integer i) throws Throwable {
2075         return test77_helper(i);
2076     }
2077 
2078     @DontCompile
2079     public void test77_verifier(boolean warmup) throws Throwable {
2080         try {
2081             test77(new Integer(42));
2082             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2083         } catch (ClassCastException e) {
2084             // Expected
2085         } catch (Exception e) {
2086             throw new RuntimeException(&quot;test77 failed: unexpected exception&quot;, e);
2087         }
2088     }
2089 
2090     // Casting a null Integer to a nullable inline type should not throw
2091     @ForceInline
2092     public MyValue1.ref test78_helper(Object o) {
2093         return (MyValue1.ref)o;
2094     }
2095 
2096     @Test
2097     public MyValue1.ref test78(Integer i) throws Throwable {
2098         return test78_helper(i);
2099     }
2100 
2101     @DontCompile
2102     public void test78_verifier(boolean warmup) throws Throwable {
2103         try {
2104             test78(null); // Should not throw
2105         } catch (Exception e) {
2106             throw new RuntimeException(&quot;test78 failed: unexpected exception&quot;, e);
2107         }
2108     }
2109 
2110     // Casting an Integer to a nullable inline type should throw a ClassCastException
2111     @ForceInline
2112     public MyValue1.ref test79_helper(Object o) {
2113         return (MyValue1.ref)o;
2114     }
2115 
2116     @Test
2117     public MyValue1.ref test79(Integer i) throws Throwable {
2118         return test79_helper(i);
2119     }
2120 
2121     @DontCompile
2122     public void test79_verifier(boolean warmup) throws Throwable {
2123         try {
2124             test79(new Integer(42));
2125             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2126         } catch (ClassCastException e) {
2127             // Expected
2128         } catch (Exception e) {
2129             throw new RuntimeException(&quot;test79 failed: unexpected exception&quot;, e);
2130         }
2131     }
2132 
2133     // Test flattened field with non-flattenend (but flattenable) inline type field
2134     static inline class Small {
2135         final int i;
2136         final Big big; // Too big to be flattened
2137 
2138         private Small() {
2139             i = rI;
2140             big = new Big();
2141         }
2142     }
2143 
2144     static inline class Big {
2145         long l0,l1,l2,l3,l4,l5,l6,l7,l8,l9;
2146         long l10,l11,l12,l13,l14,l15,l16,l17,l18,l19;
2147         long l20,l21,l22,l23,l24,l25,l26,l27,l28,l29;
2148 
2149         private Big() {
2150             l0 = l1 = l2 = l3 = l4 = l5 = l6 = l7 = l8 = l9 = rL;
2151             l10 = l11 = l12 = l13 = l14 = l15 = l16 = l17 = l18 = l19 = rL+1;
2152             l20 = l21 = l22 = l23 = l24 = l25 = l26 = l27 = l28 = l29 = rL+2;
2153         }
2154     }
2155 
2156     Small small = new Small();
2157     Small smallDefault;
2158     Big big = new Big();
2159     Big bigDefault;
2160 
2161     @Test
2162     public long test80() {
2163         return small.i + small.big.l0 + smallDefault.i + smallDefault.big.l29 + big.l0 + bigDefault.l29;
2164     }
2165 
2166     @DontCompile
2167     public void test80_verifier(boolean warmup) throws Throwable {
2168         long result = test80();
2169         Asserts.assertEQ(result, rI + 2*rL);
2170     }
2171 
2172     // Test scalarization with exceptional control flow
2173     public int test81Callee(MyValue1 vt)  {
2174         return vt.x;
2175     }
2176 
2177     @Test(failOn = ALLOC + LOAD + STORE)
2178     public int test81()  {
2179         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
2180         int result = 0;
2181         for (int i = 0; i &lt; 10; i++) {
2182             try {
2183                 result += test81Callee(vt);
2184             } catch (NullPointerException npe) {
2185                 result += rI;
2186             }
2187         }
2188         return result;
2189     }
2190 
2191     @DontCompile
2192     public void test81_verifier(boolean warmup) {
2193         int result = test81();
2194         Asserts.assertEQ(result, 10*rI);
2195     }
2196 
2197     // Test check for null free array when storing to inline tpye array
2198     @Test
2199     public void test82(Object[] dst, Object v) {
2200         dst[0] = v;
2201     }
2202 
2203     @DontCompile
2204     public void test82_verifier(boolean warmup) {
2205         MyValue2[] dst = new MyValue2[1];
2206         test82(dst, testValue2);
2207         if (!warmup) {
2208             try {
2209                 test82(dst, null);
2210                 throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
2211             } catch (NullPointerException e) {
2212                 // Expected
2213             }
2214         }
2215     }
2216 
2217     @Test
2218     @Warmup(10000)
2219     public void test83(Object[] dst, Object v, boolean flag) {
2220         if (dst == null) { // null check
2221         }
2222         if (flag) {
2223             if (dst.getClass() == MyValue1[].class) { // trigger split if
2224             }
2225         } else {
2226             dst = new MyValue2[1]; // constant null free property
2227         }
2228         dst[0] = v;
2229     }
2230 
2231     @DontCompile
2232     public void test83_verifier(boolean warmup) {
2233         MyValue2[] dst = new MyValue2[1];
2234         test83(dst, testValue2, false);
2235         test83(dst, testValue2, true);
2236         if (!warmup) {
2237             try {
2238                 test83(dst, null, true);
2239                 throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
2240             } catch (NullPointerException e) {
2241                 // Expected
2242             }
2243         }
2244     }
2245 
2246     private void rerun_and_recompile_for(String name, int num, Runnable test) {
2247         Method m = tests.get(name);
2248 
2249         for (int i = 1; i &lt; num; i++) {
2250             test.run();
2251 
2252             if (!WHITE_BOX.isMethodCompiled(m, false)) {
2253                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
2254             }
2255         }
2256     }
2257 
2258     // Tests for the Loop Unswitching optimization
2259     // Should make 2 copies of the loop, one for non flattened arrays, one for other cases.
2260     @Test(match = { COUNTEDLOOP_MAIN }, matchCount = { 2 } )
2261     @Warmup(0)
2262     public void test84(Object[] src, Object[] dst) {
2263         for (int i = 0; i &lt; src.length; i++) {
2264             dst[i] = src[i];
2265         }
2266     }
2267 
2268     @DontCompile
2269     public void test84_verifier(boolean warmup) {
2270         MyValue2[] src = new MyValue2[100];
2271         Arrays.fill(src, testValue2);
2272         MyValue2[] dst = new MyValue2[100];
2273         Method m = tests.get(&quot;TestLWorld::test84&quot;);
2274 
2275         rerun_and_recompile_for(&quot;TestLWorld::test84&quot;, 10,
2276                                 () -&gt;  { test84(src, dst);
2277                                          Asserts.assertTrue(Arrays.equals(src, dst)); });
2278     }
2279 
2280     @Test(valid = G1GCOn, match = { COUNTEDLOOP, LOAD_UNKNOWN_INLINE }, matchCount = { 2, 1 } )
2281     @Test(valid = G1GCOff, match = { COUNTEDLOOP_MAIN, LOAD_UNKNOWN_INLINE }, matchCount = { 2, 4 } )
2282     @Warmup(0)
2283     public void test85(Object[] src, Object[] dst) {
2284         for (int i = 0; i &lt; src.length; i++) {
2285             dst[i] = src[i];
2286         }
2287     }
2288 
2289     @DontCompile
2290     public void test85_verifier(boolean warmup) {
2291         Object[] src = new Object[100];
2292         Arrays.fill(src, new Object());
2293         src[0] = null;
2294         Object[] dst = new Object[100];
2295         rerun_and_recompile_for(&quot;TestLWorld::test85&quot;, 10,
2296                                 () -&gt; { test85(src, dst);
2297                                         Asserts.assertTrue(Arrays.equals(src, dst)); });
2298     }
2299 
2300     @Test(valid = G1GCOn, match = { COUNTEDLOOP }, matchCount = { 2 } )
2301     @Test(valid = G1GCOff, match = { COUNTEDLOOP_MAIN }, matchCount = { 2 } )
2302     @Warmup(0)
2303     public void test86(Object[] src, Object[] dst) {
2304         for (int i = 0; i &lt; src.length; i++) {
2305             dst[i] = src[i];
2306         }
2307     }
2308 
2309     @DontCompile
2310     public void test86_verifier(boolean warmup) {
2311         MyValue2[] src = new MyValue2[100];
2312         Arrays.fill(src, testValue2);
2313         Object[] dst = new Object[100];
2314         rerun_and_recompile_for(&quot;TestLWorld::test86&quot;, 10,
2315                                 () -&gt; { test86(src, dst);
2316                                         Asserts.assertTrue(Arrays.equals(src, dst)); });
2317     }
2318 
2319     @Test(match = { COUNTEDLOOP_MAIN }, matchCount = { 2 } )
2320     @Warmup(0)
2321     public void test87(Object[] src, Object[] dst) {
2322         for (int i = 0; i &lt; src.length; i++) {
2323             dst[i] = src[i];
2324         }
2325     }
2326 
2327     @DontCompile
2328     public void test87_verifier(boolean warmup) {
2329         Object[] src = new Object[100];
2330         Arrays.fill(src, testValue2);
2331         MyValue2[] dst = new MyValue2[100];
2332 
2333         rerun_and_recompile_for(&quot;TestLWorld::test87&quot;, 10,
2334                                 () -&gt; { test87(src, dst);
2335                                         Asserts.assertTrue(Arrays.equals(src, dst)); });
2336     }
2337 
2338     @Test(match = { COUNTEDLOOP_MAIN }, matchCount = { 2 } )
2339     @Warmup(0)
2340     public void test88(Object[] src1, Object[] dst1, Object[] src2, Object[] dst2) {
2341         for (int i = 0; i &lt; src1.length; i++) {
2342             dst1[i] = src1[i];
2343             dst2[i] = src2[i];
2344         }
2345     }
2346 
2347     @DontCompile
2348     public void test88_verifier(boolean warmup) {
2349         MyValue2[] src1 = new MyValue2[100];
2350         Arrays.fill(src1, testValue2);
2351         MyValue2[] dst1 = new MyValue2[100];
2352         Object[] src2 = new Object[100];
2353         Arrays.fill(src2, new Object());
2354         Object[] dst2 = new Object[100];
2355 
2356         rerun_and_recompile_for(&quot;TestLWorld::test88&quot;, 10,
2357                                 () -&gt; { test88(src1, dst1, src2, dst2);
2358                                         Asserts.assertTrue(Arrays.equals(src1, dst1));
2359                                         Asserts.assertTrue(Arrays.equals(src2, dst2)); });
2360     }
2361 
2362     @Test
2363     public boolean test89(Object obj) {
2364         return obj.getClass() == Integer.class;
2365     }
2366 
2367     @DontCompile
2368     public void test89_verifier(boolean warmup) {
2369         Asserts.assertTrue(test89(new Integer(42)));
2370         Asserts.assertFalse(test89(new Object()));
2371     }
2372 
2373     @Test
2374     public Integer test90(Object obj) {
2375         return (Integer)obj;
2376     }
2377 
2378     @DontCompile
2379     public void test90_verifier(boolean warmup) {
2380         test90(new Integer(42));
2381         try {
2382             test90(new Object());
2383             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2384         } catch (ClassCastException e) {
2385             // Expected
2386         }
2387     }
2388 
2389     @Test
2390     public boolean test91(Object obj) {
2391         return obj.getClass() == MyValue2[].class;
2392     }
2393 
2394     @DontCompile
2395     public void test91_verifier(boolean warmup) {
2396         Asserts.assertTrue(test91(new MyValue2[1]));
2397         Asserts.assertFalse(test91(new Object()));
2398     }
2399 
2400     static inline class Test92Value {
2401         final int field;
2402         public Test92Value() {
2403             field = 0x42;
2404         }
2405     }
2406 
2407     @Warmup(10000)
2408     @Test(match = { CLASS_CHECK_TRAP }, matchCount = { 2 }, failOn = LOAD_UNKNOWN_INLINE + ALLOC_G + MEMBAR)
2409     public Object test92(Object[] array) {
2410         // Dummy loops to ensure we run enough passes of split if
2411         for (int i = 0; i &lt; 2; i++) {
2412             for (int j = 0; j &lt; 2; j++) {
2413               for (int k = 0; k &lt; 2; k++) {
2414               }
2415             }
2416         }
2417 
2418         return (Integer)array[0];
2419     }
2420 
2421     @DontCompile
2422     public void test92_verifier(boolean warmup) {
2423         Object[] array = new Object[1];
2424         array[0] = 0x42;
2425         Object result = test92(array);
2426         Asserts.assertEquals(result, 0x42);
2427     }
2428 
2429     // If the class check succeeds, the flattened array check that
2430     // precedes will never succeed and the flat array branch should
2431     // trigger an uncommon trap.
2432     @Test
2433     @Warmup(10000)
2434     public Object test93(Object[] array) {
2435         for (int i = 0; i &lt; 2; i++) {
2436             for (int j = 0; j &lt; 2; j++) {
2437             }
2438         }
2439 
2440         Object v = (Integer)array[0];
2441         return v;
2442     }
2443 
2444     @DontCompile
2445     public void test93_verifier(boolean warmup) {
2446         if (warmup) {
2447             Object[] array = new Object[1];
2448             array[0] = 0x42;
2449             Object result = test93(array);
2450             Asserts.assertEquals(result, 0x42);
2451         } else {
2452             Object[] array = new Test92Value[1];
2453             Method m = tests.get(&quot;TestLWorld::test93&quot;);
2454             int extra = 3;
2455             for (int j = 0; j &lt; extra; j++) {
2456                 for (int i = 0; i &lt; 10; i++) {
2457                     try {
2458                         test93(array);
2459                     } catch (ClassCastException cce) {
2460                     }
2461                 }
2462                 boolean compiled = isCompiledByC2(m);
2463                 Asserts.assertTrue(!USE_COMPILER || XCOMP || STRESS_CC || TEST_C1 || compiled || (j != extra-1));
2464                 if (!compiled) {
2465                     enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
2466                 }
2467             }
2468         }
2469     }
2470 
2471     @Warmup(10000)
2472     @Test(match = { CLASS_CHECK_TRAP, LOOP }, matchCount = { 2, 1 }, failOn = LOAD_UNKNOWN_INLINE + ALLOC_G + MEMBAR)
2473     public int test94(Object[] array) {
2474         int res = 0;
2475         for (int i = 1; i &lt; 4; i *= 2) {
2476             Object v = array[i];
2477             res += (Integer)v;
2478         }
2479         return res;
2480     }
2481 
2482     @DontCompile
2483     public void test94_verifier(boolean warmup) {
2484         Object[] array = new Object[4];
2485         array[0] = 0x42;
2486         array[1] = 0x42;
2487         array[2] = 0x42;
2488         array[3] = 0x42;
2489         int result = test94(array);
2490         Asserts.assertEquals(result, 0x42 * 2);
2491     }
2492 
2493     @Warmup(10000)
2494     @Test
2495     public boolean test95(Object o1, Object o2) {
2496         return o1 == o2;
2497     }
2498 
2499     @DontCompile
2500     public void test95_verifier(boolean warmup) {
2501         Object o1 = new Object();
2502         Object o2 = new Object();
2503         Asserts.assertTrue(test95(o1, o1));
2504         Asserts.assertTrue(test95(null, null));
2505         Asserts.assertFalse(test95(o1, null));
2506         Asserts.assertFalse(test95(o1, o2));
2507     }
2508 
2509     @Warmup(10000)
2510     @Test
2511     public boolean test96(Object o1, Object o2) {
2512         return o1 == o2;
2513     }
2514 
2515     @DontCompile
2516     public void test96_verifier(boolean warmup) {
2517         Object o1 = new Object();
2518         Object o2 = new Object();
2519         Asserts.assertTrue(test96(o1, o1));
2520         Asserts.assertFalse(test96(o1, o2));
2521         if (!warmup) {
2522             Asserts.assertTrue(test96(null, null));
2523             Asserts.assertFalse(test96(o1, null));
2524         }
2525     }
2526 
2527     // Abstract class tests
2528 
2529     @DontInline
2530     public MyAbstract test97_dontinline1(MyAbstract o) {
2531         return o;
2532     }
2533 
2534     @DontInline
2535     public MyValue1 test97_dontinline2(MyAbstract o) {
2536         return (MyValue1)o;
2537     }
2538 
2539     @ForceInline
2540     public MyAbstract test97_inline1(MyAbstract o) {
2541         return o;
2542     }
2543 
2544     @ForceInline
2545     public MyValue1 test97_inline2(MyAbstract o) {
2546         return (MyValue1)o;
2547     }
2548 
2549     @Test()
2550     public MyValue1 test97() {
2551         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
2552         vt = (MyValue1)test97_dontinline1(vt);
2553         vt =           test97_dontinline2(vt);
2554         vt = (MyValue1)test97_inline1(vt);
2555         vt =           test97_inline2(vt);
2556         return vt;
2557     }
2558 
2559     @DontCompile
2560     public void test97_verifier(boolean warmup) {
2561         Asserts.assertEQ(test97().hash(), hash());
2562     }
2563 
2564     // Test storing/loading inline types to/from abstract and inline type fields
2565     MyAbstract abstractField1 = null;
2566     MyAbstract abstractField2 = null;
2567     MyAbstract abstractField3 = null;
2568     MyAbstract abstractField4 = null;
2569     MyAbstract abstractField5 = null;
2570     MyAbstract abstractField6 = null;
2571 
2572     @DontInline
2573     public MyAbstract readValueField5AsAbstract() {
2574         return (MyAbstract)valueField5;
2575     }
2576 
2577     @DontInline
2578     public MyAbstract readStaticValueField4AsAbstract() {
2579         return (MyAbstract)staticValueField4;
2580     }
2581 
2582     @Test()
2583     public long test98(MyValue1 vt1, MyAbstract vt2) {
2584         abstractField1 = vt1;
2585         abstractField2 = (MyValue1)vt2;
2586         abstractField3 = MyValue1.createWithFieldsInline(rI, rL);
2587         abstractField4 = MyValue1.createWithFieldsDontInline(rI, rL);
2588         abstractField5 = valueField1;
2589         abstractField6 = valueField3;
2590         valueField1 = (MyValue1)abstractField1;
2591         valueField2 = (MyValue1)vt2;
2592         valueField3 = (MyValue1)vt2;
2593         staticValueField1 = (MyValue1)abstractField1;
2594         staticValueField2 = (MyValue1)vt1;
2595         // Don&#39;t inline these methods because reading NULL will trigger a deoptimization
2596         if (readValueField5AsAbstract() != null || readStaticValueField4AsAbstract() != null) {
2597             throw new RuntimeException(&quot;Should be null&quot;);
2598         }
2599         return ((MyValue1)abstractField1).hash() + ((MyValue1)abstractField2).hash() +
2600                ((MyValue1)abstractField3).hash() + ((MyValue1)abstractField4).hash() +
2601                ((MyValue1)abstractField5).hash() + ((MyValue1)abstractField6).hash() +
2602                 valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +
2603                 staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();
2604     }
2605 
2606     @DontCompile
2607     public void test98_verifier(boolean warmup) {
2608         MyValue1 vt = testValue1;
2609         MyValue1 def = MyValue1.createDefaultDontInline();
2610         long result = test98(vt, vt);
2611         Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
2612     }
2613 
2614     class MyObject2 extends MyAbstract {
2615         public int x;
2616 
2617         public MyObject2(int x) {
2618             this.x = x;
2619         }
2620 
2621         @ForceInline
2622         public long hash() {
2623             return x;
2624         }
2625     }
2626 
2627     // Test merging inline types and abstract classes
2628     @Test()
2629     public MyAbstract test99(int state) {
2630         MyAbstract res = null;
2631         if (state == 0) {
2632             res = new MyObject2(rI);
2633         } else if (state == 1) {
2634             res = MyValue1.createWithFieldsInline(rI, rL);
2635         } else if (state == 2) {
2636             res = MyValue1.createWithFieldsDontInline(rI, rL);
2637         } else if (state == 3) {
2638             res = (MyValue1)objectField1;
2639         } else if (state == 4) {
2640             res = valueField1;
2641         } else if (state == 5) {
2642             res = null;
2643         }
2644         return res;
2645     }
2646 
2647     @DontCompile
2648     public void test99_verifier(boolean warmup) {
2649         objectField1 = valueField1;
2650         MyAbstract result = null;
2651         result = test99(0);
2652         Asserts.assertEQ(((MyObject2)result).x, rI);
2653         result = test99(1);
2654         Asserts.assertEQ(((MyValue1)result).hash(), hash());
2655         result = test99(2);
2656         Asserts.assertEQ(((MyValue1)result).hash(), hash());
2657         result = test99(3);
2658         Asserts.assertEQ(((MyValue1)result).hash(), hash());
2659         result = test99(4);
2660         Asserts.assertEQ(((MyValue1)result).hash(), hash());
2661         result = test99(5);
2662         Asserts.assertEQ(result, null);
2663     }
2664 
2665     // Test merging inline types and abstract classes in loops
2666     @Test()
2667     public MyAbstract test100(int iters) {
2668         MyAbstract res = new MyObject2(rI);
2669         for (int i = 0; i &lt; iters; ++i) {
2670             if (res instanceof MyObject2) {
2671                 res = MyValue1.createWithFieldsInline(rI, rL);
2672             } else {
2673                 res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
2674             }
2675         }
2676         return res;
2677     }
2678 
2679     @DontCompile
2680     public void test100_verifier(boolean warmup) {
2681         MyObject2 result1 = (MyObject2)test100(0);
2682         Asserts.assertEQ(result1.x, rI);
2683         int iters = (Math.abs(rI) % 10) + 1;
2684         MyValue1 result2 = (MyValue1)test100(iters);
2685         MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
2686         Asserts.assertEQ(result2.hash(), vt.hash());
2687     }
2688 
2689     // Test inline types in abstract class variables that are live at safepoint
2690     @Test(failOn = ALLOC + STORE + LOOP)
2691     public long test101(MyValue1 arg, boolean deopt) {
2692         MyAbstract vt1 = MyValue1.createWithFieldsInline(rI, rL);
2693         MyAbstract vt2 = MyValue1.createWithFieldsDontInline(rI, rL);
2694         MyAbstract vt3 = arg;
2695         MyAbstract vt4 = valueField1;
2696         if (deopt) {
2697             // uncommon trap
2698             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test101&quot;));
2699         }
2700         return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +
2701                ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();
2702     }
2703 
2704     @DontCompile
2705     public void test101_verifier(boolean warmup) {
2706         long result = test101(valueField1, !warmup);
2707         Asserts.assertEQ(result, 4*hash());
2708     }
2709 
2710     // Test comparing inline types with abstract classes
2711     @Test(failOn = LOAD + LOOP)
2712     public boolean test102(Object arg) {
2713         MyAbstract vt = MyValue1.createWithFieldsInline(rI, rL);
2714         if (vt == arg || vt == (MyAbstract)valueField1 || vt == abstractField1 || vt == null ||
2715             arg == vt || (MyAbstract)valueField1 == vt || abstractField1 == vt || null == vt) {
2716             return true;
2717         }
2718         return false;
2719     }
2720 
2721     @DontCompile
2722     public void test102_verifier(boolean warmup) {
2723         boolean result = test102(null);
2724         Asserts.assertFalse(result);
2725     }
2726 
2727     // An abstract class with a non-static field can never be implemented by an inline type
2728     abstract class NoValueImplementors1 {
2729         int field = 42;
2730     }
2731 
2732     class MyObject3 extends NoValueImplementors1 {
2733 
2734     }
2735 
2736     class MyObject4 extends NoValueImplementors1 {
2737 
2738     }
2739 
2740     // Loading from an abstract class array does not require a flatness check if the abstract class has a non-static field
2741     @Test(failOn = ALLOC_G + MEMBAR + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
2742     public NoValueImplementors1 test103(NoValueImplementors1[] array, int i) {
2743         return array[i];
2744     }
2745 
2746     @DontCompile
2747     public void test103_verifier(boolean warmup) {
2748         NoValueImplementors1[] array1 = new NoValueImplementors1[3];
2749         MyObject3[] array2 = new MyObject3[3];
2750         MyObject4[] array3 = new MyObject4[3];
2751         NoValueImplementors1 result = test103(array1, 0);
2752         Asserts.assertEquals(result, array1[0]);
2753 
2754         result = test103(array2, 1);
2755         Asserts.assertEquals(result, array1[1]);
2756 
2757         result = test103(array3, 2);
2758         Asserts.assertEquals(result, array1[2]);
2759     }
2760 
2761     // Storing to an abstract class array does not require a flatness/null check if the abstract class has a non-static field
2762     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
2763     public NoValueImplementors1 test104(NoValueImplementors1[] array, NoValueImplementors1 v, MyObject3 o, int i) {
2764         array[0] = v;
2765         array[1] = array[0];
2766         array[2] = o;
2767         return array[i];
2768     }
2769 
2770     @DontCompile
2771     public void test104_verifier(boolean warmup) {
2772         MyObject4 v = new MyObject4();
2773         MyObject3 o = new MyObject3();
2774         NoValueImplementors1[] array1 = new NoValueImplementors1[3];
2775         MyObject3[] array2 = new MyObject3[3];
2776         MyObject4[] array3 = new MyObject4[3];
2777         NoValueImplementors1 result = test104(array1, v, o, 0);
2778         Asserts.assertEquals(array1[0], v);
2779         Asserts.assertEquals(array1[1], v);
2780         Asserts.assertEquals(array1[2], o);
2781         Asserts.assertEquals(result, v);
2782 
2783         result = test104(array2, o, o, 1);
2784         Asserts.assertEquals(array2[0], o);
2785         Asserts.assertEquals(array2[1], o);
2786         Asserts.assertEquals(array2[2], o);
2787         Asserts.assertEquals(result, o);
2788 
2789         result = test104(array3, v, null, 1);
2790         Asserts.assertEquals(array3[0], v);
2791         Asserts.assertEquals(array3[1], v);
2792         Asserts.assertEquals(array3[2], null);
2793         Asserts.assertEquals(result, v);
2794     }
2795 
2796     // An abstract class with a single, non-inline implementor
2797     abstract class NoValueImplementors2 {
2798 
2799     }
2800 
2801     class MyObject5 extends NoValueImplementors2 {
2802 
2803     }
2804 
2805     // Loading from an abstract class array does not require a flatness check if the abstract class has no inline implementor
2806     @Test(failOn = ALLOC_G + MEMBAR + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
2807     public NoValueImplementors2 test105(NoValueImplementors2[] array, int i) {
2808         return array[i];
2809     }
2810 
2811     @DontCompile
2812     public void test105_verifier(boolean warmup) {
2813         NoValueImplementors2[] array1 = new NoValueImplementors2[3];
2814         MyObject5[] array2 = new MyObject5[3];
2815         NoValueImplementors2 result = test105(array1, 0);
2816         Asserts.assertEquals(result, array1[0]);
2817 
2818         result = test105(array2, 1);
2819         Asserts.assertEquals(result, array1[1]);
2820     }
2821 
2822     // Storing to an abstract class array does not require a flatness/null check if the abstract class has no inline implementor
2823     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
2824     public NoValueImplementors2 test106(NoValueImplementors2[] array, NoValueImplementors2 v, MyObject5 o, int i) {
2825         array[0] = v;
2826         array[1] = array[0];
2827         array[2] = o;
2828         return array[i];
2829     }
2830 
2831     @DontCompile
2832     public void test106_verifier(boolean warmup) {
2833         MyObject5 v = new MyObject5();
2834         NoValueImplementors2[] array1 = new NoValueImplementors2[3];
2835         MyObject5[] array2 = new MyObject5[3];
2836         NoValueImplementors2 result = test106(array1, v, null, 0);
2837         Asserts.assertEquals(array1[0], v);
2838         Asserts.assertEquals(array1[1], v);
2839         Asserts.assertEquals(array1[2], null);
2840         Asserts.assertEquals(result, v);
2841 
2842         result = test106(array2, v, v, 1);
2843         Asserts.assertEquals(array2[0], v);
2844         Asserts.assertEquals(array2[1], v);
2845         Asserts.assertEquals(array2[2], v);
2846         Asserts.assertEquals(result, v);
2847     }
2848 
2849     // More tests for the Loop Unswitching optimization (similar to test84 and following)
2850     Object oFld1, oFld2;
2851 
2852     @Test(valid = G1GCOn, failOn = STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD, match = { COUNTEDLOOP, LOAD_UNKNOWN_INLINE }, matchCount = { 2, 2 } )
2853     @Test(valid = G1GCOff, failOn = STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD, match = { COUNTEDLOOP, LOAD_UNKNOWN_INLINE }, matchCount = { 3, 2 } )
2854     @Warmup(0)
2855     public void test107(Object[] src1, Object[] src2) {
2856         for (int i = 0; i &lt; src1.length; i++) {
2857             oFld1 = src1[i];
2858             oFld2 = src2[i];
2859         }
2860     }
2861 
2862     @DontCompile
2863     public void test107_verifier(boolean warmup) {
2864         MyValue2[] src1 = new MyValue2[100];
2865         Arrays.fill(src1, testValue2);
2866         Object[] src2 = new Object[100];
2867         Object obj = new Object();
2868         Arrays.fill(src2, obj);
2869         rerun_and_recompile_for(&quot;TestLWorld::test107&quot;, 10,
2870                                 () -&gt; { test107(src1, src2);
2871                                         Asserts.assertEquals(oFld1, testValue2);
2872                                         Asserts.assertEquals(oFld2, obj);
2873                                         test107(src2, src1);
2874                                         Asserts.assertEquals(oFld1, obj);
2875                                         Asserts.assertEquals(oFld2, testValue2);  });
2876     }
2877 
2878     @Test(valid = G1GCOn, failOn = LOAD_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD, match = { COUNTEDLOOP, STORE_UNKNOWN_INLINE }, matchCount = { 4, 9 } )
2879     @Test(valid = G1GCOff, failOn = LOAD_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD, match = { COUNTEDLOOP, STORE_UNKNOWN_INLINE }, matchCount = { 4, 12 } )
2880     @Warmup(0)
2881     public void test108(Object[] dst1, Object[] dst2, Object o1, Object o2) {
2882         for (int i = 0; i &lt; dst1.length; i++) {
2883             dst1[i] = o1;
2884             dst2[i] = o2;
2885         }
2886     }
2887 
2888     @DontCompile
2889     public void test108_verifier(boolean warmup) {
2890         MyValue2[] dst1 = new MyValue2[100];
2891         Object[] dst2 = new Object[100];
2892         Object o1 = new Object();
2893         rerun_and_recompile_for(&quot;TestLWorld::test108&quot;, 10,
2894                                 () -&gt; { test108(dst1, dst2, testValue2, o1);
2895                                         for (int i = 0; i &lt; dst1.length; i++) {
2896                                             Asserts.assertEquals(dst1[i], testValue2);
2897                                             Asserts.assertEquals(dst2[i], o1);
2898                                         }
2899                                         test108(dst2, dst1, o1, testValue2);
2900                                         for (int i = 0; i &lt; dst1.length; i++) {
2901                                             Asserts.assertEquals(dst1[i], testValue2);
2902                                             Asserts.assertEquals(dst2[i], o1);
2903                                         } });
2904     }
2905 
2906     // Escape analysis tests
2907 
2908     static interface WrapperInterface {
2909         long value();
2910 
2911         final static WrapperInterface ZERO = new LongWrapper(0);
2912 
2913         static WrapperInterface wrap(long val) {
2914             return (val == 0L) ? ZERO : new LongWrapper(val);
2915         }
2916     }
2917 
2918     static inline class LongWrapper implements WrapperInterface {
2919         final static LongWrapper ZERO = new LongWrapper(0);
2920         private long val;
2921 
2922         LongWrapper(long val) {
2923             this.val = val;
2924         }
2925 
2926         static LongWrapper wrap(long val) {
2927             return (val == 0L) ? ZERO : new LongWrapper(val);
2928         }
2929 
2930         public long value() {
2931             return val;
2932         }
2933     }
2934 
2935     static class InterfaceBox {
2936         WrapperInterface content;
2937 
2938         InterfaceBox(WrapperInterface content) {
2939             this.content = content;
2940         }
2941 
2942         static InterfaceBox box_sharp(long val) {
2943             return new InterfaceBox(LongWrapper.wrap(val));
2944         }
2945 
2946         static InterfaceBox box(long val) {
2947             return new InterfaceBox(WrapperInterface.wrap(val));
2948         }
2949     }
2950 
2951     static class ObjectBox {
2952         Object content;
2953 
2954         ObjectBox(Object content) {
2955             this.content = content;
2956         }
2957 
2958         static ObjectBox box_sharp(long val) {
2959             return new ObjectBox(LongWrapper.wrap(val));
2960         }
2961 
2962         static ObjectBox box(long val) {
2963             return new ObjectBox(WrapperInterface.wrap(val));
2964         }
2965     }
2966 
2967     static class RefBox {
2968         LongWrapper.ref content;
2969 
2970         RefBox(LongWrapper.ref content) {
2971             this.content = content;
2972         }
2973 
2974         static RefBox box_sharp(long val) {
2975             return new RefBox(LongWrapper.wrap(val));
2976         }
2977 
2978         static RefBox box(long val) {
2979             return new RefBox((LongWrapper.ref)WrapperInterface.wrap(val));
2980         }
2981     }
2982 
2983     static class InlineBox {
2984         LongWrapper content;
2985 
2986         InlineBox(long val) {
2987             this.content = LongWrapper.wrap(val);
2988         }
2989 
2990         static InlineBox box(long val) {
2991             return new InlineBox(val);
2992         }
2993     }
2994 
2995     static class GenericBox&lt;T&gt; {
2996         T content;
2997 
2998         static GenericBox&lt;LongWrapper.ref&gt; box_sharp(long val) {
2999             GenericBox&lt;LongWrapper.ref&gt; res = new GenericBox&lt;&gt;();
3000             res.content = LongWrapper.wrap(val);
3001             return res;
3002         }
3003 
3004         static GenericBox&lt;WrapperInterface&gt; box(long val) {
3005             GenericBox&lt;WrapperInterface&gt; res = new GenericBox&lt;&gt;();
3006             res.content = WrapperInterface.wrap(val);
3007             return res;
3008         }
3009     }
3010 
3011     long[] lArr = {0L, rL, 0L, rL, 0L, rL, 0L, rL, 0L, rL};
3012 
3013     // Test removal of allocations when inline type instance is wrapped into box object
3014     @Warmup(10000) // Make sure interface calls are inlined
3015     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3016     public long test109() {
3017         long res = 0;
3018         for (int i = 0 ; i &lt; lArr.length; i++) {
3019             res += InterfaceBox.box(lArr[i]).content.value();
3020         }
3021         return res;
3022     }
3023 
3024     @DontCompile
3025     public void test109_verifier(boolean warmup) {
3026         long res = test109();
3027         Asserts.assertEquals(res, 5*rL);
3028     }
3029 
3030     @Warmup(10000) // Make sure interface calls are inlined
3031     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3032     public long test109_sharp() {
3033         long res = 0;
3034         for (int i = 0 ; i &lt; lArr.length; i++) {
3035             res += InterfaceBox.box_sharp(lArr[i]).content.value();
3036         }
3037         return res;
3038     }
3039 
3040     @DontCompile
3041     public void test109_sharp_verifier(boolean warmup) {
3042         long res = test109_sharp();
3043         Asserts.assertEquals(res, 5*rL);
3044     }
3045 
3046     // Same as test109 but with ObjectBox
3047     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3048     @Warmup(10000) // Make sure interface calls are inlined
3049     public long test110() {
3050         long res = 0;
3051         for (int i = 0 ; i &lt; lArr.length; i++) {
3052             res += ((WrapperInterface)ObjectBox.box(lArr[i]).content).value();
3053         }
3054         return res;
3055     }
3056 
3057     @DontCompile
3058     public void test110_verifier(boolean warmup) {
3059         long res = test110();
3060         Asserts.assertEquals(res, 5*rL);
3061     }
3062 
3063     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3064     @Warmup(10000) // Make sure interface calls are inlined
3065     public long test110_sharp() {
3066         long res = 0;
3067         for (int i = 0 ; i &lt; lArr.length; i++) {
3068             res += ((WrapperInterface)ObjectBox.box_sharp(lArr[i]).content).value();
3069         }
3070         return res;
3071     }
3072 
3073     @DontCompile
3074     public void test110_sharp_verifier(boolean warmup) {
3075         long res = test110_sharp();
3076         Asserts.assertEquals(res, 5*rL);
3077     }
3078 
3079     // Same as test109 but with RefBox
3080     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3081     public long test111() {
3082         long res = 0;
3083         for (int i = 0 ; i &lt; lArr.length; i++) {
3084             res += RefBox.box(lArr[i]).content.value();
3085         }
3086         return res;
3087     }
3088 
3089     @DontCompile
3090     public void test111_verifier(boolean warmup) {
3091         long res = test111();
3092         Asserts.assertEquals(res, 5*rL);
3093     }
3094 
3095     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3096     public long test111_sharp() {
3097         long res = 0;
3098         for (int i = 0 ; i &lt; lArr.length; i++) {
3099             res += RefBox.box_sharp(lArr[i]).content.value();
3100         }
3101         return res;
3102     }
3103 
3104     @DontCompile
3105     public void test111_sharp_verifier(boolean warmup) {
3106         long res = test111_sharp();
3107         Asserts.assertEquals(res, 5*rL);
3108     }
3109 
3110     // Same as test109 but with InlineBox
3111     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3112     public long test112() {
3113         long res = 0;
3114         for (int i = 0 ; i &lt; lArr.length; i++) {
3115             res += InlineBox.box(lArr[i]).content.value();
3116         }
3117         return res;
3118     }
3119 
3120     @DontCompile
3121     public void test112_verifier(boolean warmup) {
3122         long res = test112();
3123         Asserts.assertEquals(res, 5*rL);
3124     }
3125 
3126     // Same as test109 but with GenericBox
3127     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3128     @Warmup(10000) // Make sure interface calls are inlined
3129     public long test113() {
3130         long res = 0;
3131         for (int i = 0 ; i &lt; lArr.length; i++) {
3132             res += GenericBox.box(lArr[i]).content.value();
3133         }
3134         return res;
3135     }
3136 
3137     @DontCompile
3138     public void test113_verifier(boolean warmup) {
3139         long res = test113();
3140         Asserts.assertEquals(res, 5*rL);
3141     }
3142 
3143     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3144     @Warmup(10000) // Make sure interface calls are inlined
3145     public long test113_sharp() {
3146         long res = 0;
3147         for (int i = 0 ; i &lt; lArr.length; i++) {
3148             res += GenericBox.box_sharp(lArr[i]).content.value();
3149         }
3150         return res;
3151     }
3152 
3153     @DontCompile
3154     public void test113_sharp_verifier(boolean warmup) {
3155         long res = test113_sharp();
3156         Asserts.assertEquals(res, 5*rL);
3157     }
3158 
3159     static interface WrapperInterface2 {
3160         public long value();
3161 
3162         static final InlineWrapper.ref ZERO = new InlineWrapper(0);
3163 
3164         public static WrapperInterface2 wrap(long val) {
3165             return (val == 0) ? ZERO.content : new LongWrapper2(val);
3166         }
3167 
3168         public static WrapperInterface2 wrap_default(long val) {
3169             return (val == 0) ? LongWrapper2.default : new LongWrapper2(val);
3170         }
3171     }
3172 
3173     static inline class LongWrapper2 implements WrapperInterface2 {
3174         private long val;
3175 
3176         public LongWrapper2(long val) {
3177             this.val = val;
3178         }
3179 
3180         public long value() {
3181             return val;
3182         }
3183     }
3184 
3185     static inline class InlineWrapper {
3186         WrapperInterface2 content;
3187 
3188         public InlineWrapper(long val) {
3189             content = new LongWrapper2(val);
3190         }
3191     }
3192 
3193     static class InterfaceBox2 {
3194         WrapperInterface2 content;
3195 
3196         public InterfaceBox2(long val, boolean def) {
3197             this.content = def ? WrapperInterface2.wrap_default(val) : WrapperInterface2.wrap(val);
3198         }
3199 
3200         static InterfaceBox2 box(long val) {
3201             return new InterfaceBox2(val, false);
3202         }
3203 
3204         static InterfaceBox2 box_default(long val) {
3205             return new InterfaceBox2(val, true);
3206         }
3207     }
3208 
3209     // Same as tests above but with ZERO hidden in field of another inline type
3210     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3211     @Warmup(10000)
3212     public long test114() {
3213         long res = 0;
3214         for (int i = 0; i &lt; lArr.length; i++) {
3215             res += InterfaceBox2.box(lArr[i]).content.value();
3216         }
3217         return res;
3218     }
3219 
3220     @DontCompile
3221     public void test114_verifier(boolean warmup) {
3222         long res = test114();
3223         Asserts.assertEquals(res, 5*rL);
3224     }
3225 
3226     // Same as test114 but with .default instead of ZERO field
3227     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3228     @Warmup(10000)
3229     public long test115() {
3230         long res = 0;
3231         for (int i = 0; i &lt; lArr.length; i++) {
3232             res += InterfaceBox2.box_default(lArr[i]).content.value();
3233         }
3234         return res;
3235     }
3236 
3237     @DontCompile
3238     public void test115_verifier(boolean warmup) {
3239         long res = test115();
3240         Asserts.assertEquals(res, 5*rL);
3241     }
3242 
3243     static MyValueEmpty     fEmpty1;
3244     static MyValueEmpty.ref fEmpty2 = MyValueEmpty.default;
3245            MyValueEmpty     fEmpty3;
3246            MyValueEmpty.ref fEmpty4 = MyValueEmpty.default;
3247 
3248     // Test fields loads/stores with empty inline types
3249     @Test(failOn = ALLOC + ALLOC_G + LOAD + STORE + TRAP)
3250     public void test116() {
3251         fEmpty1 = fEmpty4;
3252         fEmpty2 = fEmpty1;
3253         fEmpty3 = fEmpty2;
3254         fEmpty4 = fEmpty3;
3255     }
3256 
3257     @DontCompile
3258     public void test116_verifier(boolean warmup) {
3259         test116();
3260         Asserts.assertEquals(fEmpty1, fEmpty2);
3261         Asserts.assertEquals(fEmpty2, fEmpty3);
3262         Asserts.assertEquals(fEmpty3, fEmpty4);
3263     }
3264 
3265     // Test array loads/stores with empty inline types
3266     @Test(failOn = ALLOC + ALLOC_G)
3267     public MyValueEmpty test117(MyValueEmpty[] arr1, MyValueEmpty.ref[] arr2) {
3268         arr1[0] = arr2[0];
3269         arr2[0] = new MyValueEmpty();
3270         return arr1[0];
3271     }
3272 
3273     @DontCompile
3274     public void test117_verifier(boolean warmup) {
3275         MyValueEmpty[] arr1 = new MyValueEmpty[]{MyValueEmpty.default};
3276         MyValueEmpty res = test117(arr1, arr1);
3277         Asserts.assertEquals(res, MyValueEmpty.default);
3278         Asserts.assertEquals(arr1[0], MyValueEmpty.default);
3279     }
3280 
3281     // Test acmp with empty inline types
3282     @Test(failOn = ALLOC + ALLOC_G)
3283     public boolean test118(MyValueEmpty v1, MyValueEmpty.ref v2, Object o1) {
3284         return (v1 == v2) &amp;&amp; (v2 == o1);
3285     }
3286 
3287     @DontCompile
3288     public void test118_verifier(boolean warmup) {
3289         boolean res = test118(MyValueEmpty.default, MyValueEmpty.default, new MyValueEmpty());
3290         Asserts.assertTrue(res);
3291     }
3292 }
    </pre>
  </body>
</html>