<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/parallel/psParallelCompact.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/stringTable.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;code/codeCache.hpp&quot;
  33 #include &quot;gc/parallel/parallelArguments.hpp&quot;
  34 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  35 #include &quot;gc/parallel/parMarkBitMap.inline.hpp&quot;
  36 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
  37 #include &quot;gc/parallel/psCompactionManager.inline.hpp&quot;
  38 #include &quot;gc/parallel/psOldGen.hpp&quot;
  39 #include &quot;gc/parallel/psParallelCompact.inline.hpp&quot;
  40 #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;
  41 #include &quot;gc/parallel/psRootType.hpp&quot;
  42 #include &quot;gc/parallel/psScavenge.hpp&quot;
  43 #include &quot;gc/parallel/psYoungGen.hpp&quot;
  44 #include &quot;gc/shared/gcCause.hpp&quot;
  45 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
  46 #include &quot;gc/shared/gcId.hpp&quot;
  47 #include &quot;gc/shared/gcLocker.hpp&quot;
  48 #include &quot;gc/shared/gcTimer.hpp&quot;
  49 #include &quot;gc/shared/gcTrace.hpp&quot;
  50 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  51 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
  52 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
  53 #include &quot;gc/shared/oopStorageSet.inline.hpp&quot;
  54 #include &quot;gc/shared/oopStorageSetParState.inline.hpp&quot;
  55 #include &quot;gc/shared/referencePolicy.hpp&quot;
  56 #include &quot;gc/shared/referenceProcessor.hpp&quot;
  57 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  58 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;
  59 #include &quot;gc/shared/taskTerminator.hpp&quot;
  60 #include &quot;gc/shared/weakProcessor.hpp&quot;
  61 #include &quot;gc/shared/workerPolicy.hpp&quot;
  62 #include &quot;gc/shared/workgroup.hpp&quot;
  63 #include &quot;logging/log.hpp&quot;
  64 #include &quot;memory/iterator.inline.hpp&quot;
  65 #include &quot;memory/resourceArea.hpp&quot;
  66 #include &quot;memory/universe.hpp&quot;
  67 #include &quot;oops/access.inline.hpp&quot;
  68 #include &quot;oops/instanceClassLoaderKlass.inline.hpp&quot;
  69 #include &quot;oops/instanceKlass.inline.hpp&quot;
  70 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;
  71 #include &quot;oops/methodData.hpp&quot;
  72 #include &quot;oops/objArrayKlass.inline.hpp&quot;
  73 #include &quot;oops/oop.inline.hpp&quot;
  74 #include &quot;runtime/atomic.hpp&quot;
  75 #include &quot;runtime/handles.inline.hpp&quot;
  76 #include &quot;runtime/safepoint.hpp&quot;
  77 #include &quot;runtime/vmThread.hpp&quot;
  78 #include &quot;services/memTracker.hpp&quot;
  79 #include &quot;services/memoryService.hpp&quot;
  80 #include &quot;utilities/align.hpp&quot;
  81 #include &quot;utilities/debug.hpp&quot;
  82 #include &quot;utilities/events.hpp&quot;
  83 #include &quot;utilities/formatBuffer.hpp&quot;
  84 #include &quot;utilities/macros.hpp&quot;
  85 #include &quot;utilities/stack.inline.hpp&quot;
  86 #if INCLUDE_JVMCI
  87 #include &quot;jvmci/jvmci.hpp&quot;
  88 #endif
  89 
  90 #include &lt;math.h&gt;
  91 
  92 // All sizes are in HeapWords.
  93 const size_t ParallelCompactData::Log2RegionSize  = 16; // 64K words
  94 const size_t ParallelCompactData::RegionSize      = (size_t)1 &lt;&lt; Log2RegionSize;
  95 const size_t ParallelCompactData::RegionSizeBytes =
  96   RegionSize &lt;&lt; LogHeapWordSize;
  97 const size_t ParallelCompactData::RegionSizeOffsetMask = RegionSize - 1;
  98 const size_t ParallelCompactData::RegionAddrOffsetMask = RegionSizeBytes - 1;
  99 const size_t ParallelCompactData::RegionAddrMask       = ~RegionAddrOffsetMask;
 100 
 101 const size_t ParallelCompactData::Log2BlockSize   = 7; // 128 words
 102 const size_t ParallelCompactData::BlockSize       = (size_t)1 &lt;&lt; Log2BlockSize;
 103 const size_t ParallelCompactData::BlockSizeBytes  =
 104   BlockSize &lt;&lt; LogHeapWordSize;
 105 const size_t ParallelCompactData::BlockSizeOffsetMask = BlockSize - 1;
 106 const size_t ParallelCompactData::BlockAddrOffsetMask = BlockSizeBytes - 1;
 107 const size_t ParallelCompactData::BlockAddrMask       = ~BlockAddrOffsetMask;
 108 
 109 const size_t ParallelCompactData::BlocksPerRegion = RegionSize / BlockSize;
 110 const size_t ParallelCompactData::Log2BlocksPerRegion =
 111   Log2RegionSize - Log2BlockSize;
 112 
 113 const ParallelCompactData::RegionData::region_sz_t
 114 ParallelCompactData::RegionData::dc_shift = 27;
 115 
 116 const ParallelCompactData::RegionData::region_sz_t
 117 ParallelCompactData::RegionData::dc_mask = ~0U &lt;&lt; dc_shift;
 118 
 119 const ParallelCompactData::RegionData::region_sz_t
 120 ParallelCompactData::RegionData::dc_one = 0x1U &lt;&lt; dc_shift;
 121 
 122 const ParallelCompactData::RegionData::region_sz_t
 123 ParallelCompactData::RegionData::los_mask = ~dc_mask;
 124 
 125 const ParallelCompactData::RegionData::region_sz_t
 126 ParallelCompactData::RegionData::dc_claimed = 0x8U &lt;&lt; dc_shift;
 127 
 128 const ParallelCompactData::RegionData::region_sz_t
 129 ParallelCompactData::RegionData::dc_completed = 0xcU &lt;&lt; dc_shift;
 130 
 131 SpaceInfo PSParallelCompact::_space_info[PSParallelCompact::last_space_id];
 132 
 133 SpanSubjectToDiscoveryClosure PSParallelCompact::_span_based_discoverer;
 134 ReferenceProcessor* PSParallelCompact::_ref_processor = NULL;
 135 
 136 double PSParallelCompact::_dwl_mean;
 137 double PSParallelCompact::_dwl_std_dev;
 138 double PSParallelCompact::_dwl_first_term;
 139 double PSParallelCompact::_dwl_adjustment;
 140 #ifdef  ASSERT
 141 bool   PSParallelCompact::_dwl_initialized = false;
 142 #endif  // #ifdef ASSERT
 143 
 144 void SplitInfo::record(size_t src_region_idx, size_t partial_obj_size,
 145                        HeapWord* destination)
 146 {
 147   assert(src_region_idx != 0, &quot;invalid src_region_idx&quot;);
 148   assert(partial_obj_size != 0, &quot;invalid partial_obj_size argument&quot;);
 149   assert(destination != NULL, &quot;invalid destination argument&quot;);
 150 
 151   _src_region_idx = src_region_idx;
 152   _partial_obj_size = partial_obj_size;
 153   _destination = destination;
 154 
 155   // These fields may not be updated below, so make sure they&#39;re clear.
 156   assert(_dest_region_addr == NULL, &quot;should have been cleared&quot;);
 157   assert(_first_src_addr == NULL, &quot;should have been cleared&quot;);
 158 
 159   // Determine the number of destination regions for the partial object.
 160   HeapWord* const last_word = destination + partial_obj_size - 1;
 161   const ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
 162   HeapWord* const beg_region_addr = sd.region_align_down(destination);
 163   HeapWord* const end_region_addr = sd.region_align_down(last_word);
 164 
 165   if (beg_region_addr == end_region_addr) {
 166     // One destination region.
 167     _destination_count = 1;
 168     if (end_region_addr == destination) {
 169       // The destination falls on a region boundary, thus the first word of the
 170       // partial object will be the first word copied to the destination region.
 171       _dest_region_addr = end_region_addr;
 172       _first_src_addr = sd.region_to_addr(src_region_idx);
 173     }
 174   } else {
 175     // Two destination regions.  When copied, the partial object will cross a
 176     // destination region boundary, so a word somewhere within the partial
 177     // object will be the first word copied to the second destination region.
 178     _destination_count = 2;
 179     _dest_region_addr = end_region_addr;
 180     const size_t ofs = pointer_delta(end_region_addr, destination);
 181     assert(ofs &lt; _partial_obj_size, &quot;sanity&quot;);
 182     _first_src_addr = sd.region_to_addr(src_region_idx) + ofs;
 183   }
 184 }
 185 
 186 void SplitInfo::clear()
 187 {
 188   _src_region_idx = 0;
 189   _partial_obj_size = 0;
 190   _destination = NULL;
 191   _destination_count = 0;
 192   _dest_region_addr = NULL;
 193   _first_src_addr = NULL;
 194   assert(!is_valid(), &quot;sanity&quot;);
 195 }
 196 
 197 #ifdef  ASSERT
 198 void SplitInfo::verify_clear()
 199 {
 200   assert(_src_region_idx == 0, &quot;not clear&quot;);
 201   assert(_partial_obj_size == 0, &quot;not clear&quot;);
 202   assert(_destination == NULL, &quot;not clear&quot;);
 203   assert(_destination_count == 0, &quot;not clear&quot;);
 204   assert(_dest_region_addr == NULL, &quot;not clear&quot;);
 205   assert(_first_src_addr == NULL, &quot;not clear&quot;);
 206 }
 207 #endif  // #ifdef ASSERT
 208 
 209 
 210 void PSParallelCompact::print_on_error(outputStream* st) {
 211   _mark_bitmap.print_on_error(st);
 212 }
 213 
 214 #ifndef PRODUCT
 215 const char* PSParallelCompact::space_names[] = {
 216   &quot;old &quot;, &quot;eden&quot;, &quot;from&quot;, &quot;to  &quot;
 217 };
 218 
 219 void PSParallelCompact::print_region_ranges() {
 220   if (!log_develop_is_enabled(Trace, gc, compaction)) {
 221     return;
 222   }
 223   Log(gc, compaction) log;
 224   ResourceMark rm;
 225   LogStream ls(log.trace());
 226   Universe::print_on(&amp;ls);
 227   log.trace(&quot;space  bottom     top        end        new_top&quot;);
 228   log.trace(&quot;------ ---------- ---------- ---------- ----------&quot;);
 229 
 230   for (unsigned int id = 0; id &lt; last_space_id; ++id) {
 231     const MutableSpace* space = _space_info[id].space();
 232     log.trace(&quot;%u %s &quot;
 233               SIZE_FORMAT_W(10) &quot; &quot; SIZE_FORMAT_W(10) &quot; &quot;
 234               SIZE_FORMAT_W(10) &quot; &quot; SIZE_FORMAT_W(10) &quot; &quot;,
 235               id, space_names[id],
 236               summary_data().addr_to_region_idx(space-&gt;bottom()),
 237               summary_data().addr_to_region_idx(space-&gt;top()),
 238               summary_data().addr_to_region_idx(space-&gt;end()),
 239               summary_data().addr_to_region_idx(_space_info[id].new_top()));
 240   }
 241 }
 242 
 243 void
 244 print_generic_summary_region(size_t i, const ParallelCompactData::RegionData* c)
 245 {
 246 #define REGION_IDX_FORMAT        SIZE_FORMAT_W(7)
 247 #define REGION_DATA_FORMAT       SIZE_FORMAT_W(5)
 248 
 249   ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
 250   size_t dci = c-&gt;destination() ? sd.addr_to_region_idx(c-&gt;destination()) : 0;
 251   log_develop_trace(gc, compaction)(
 252       REGION_IDX_FORMAT &quot; &quot; PTR_FORMAT &quot; &quot;
 253       REGION_IDX_FORMAT &quot; &quot; PTR_FORMAT &quot; &quot;
 254       REGION_DATA_FORMAT &quot; &quot; REGION_DATA_FORMAT &quot; &quot;
 255       REGION_DATA_FORMAT &quot; &quot; REGION_IDX_FORMAT &quot; %d&quot;,
 256       i, p2i(c-&gt;data_location()), dci, p2i(c-&gt;destination()),
 257       c-&gt;partial_obj_size(), c-&gt;live_obj_size(),
 258       c-&gt;data_size(), c-&gt;source_region(), c-&gt;destination_count());
 259 
 260 #undef  REGION_IDX_FORMAT
 261 #undef  REGION_DATA_FORMAT
 262 }
 263 
 264 void
 265 print_generic_summary_data(ParallelCompactData&amp; summary_data,
 266                            HeapWord* const beg_addr,
 267                            HeapWord* const end_addr)
 268 {
 269   size_t total_words = 0;
 270   size_t i = summary_data.addr_to_region_idx(beg_addr);
 271   const size_t last = summary_data.addr_to_region_idx(end_addr);
 272   HeapWord* pdest = 0;
 273 
 274   while (i &lt; last) {
 275     ParallelCompactData::RegionData* c = summary_data.region(i);
 276     if (c-&gt;data_size() != 0 || c-&gt;destination() != pdest) {
 277       print_generic_summary_region(i, c);
 278       total_words += c-&gt;data_size();
 279       pdest = c-&gt;destination();
 280     }
 281     ++i;
 282   }
 283 
 284   log_develop_trace(gc, compaction)(&quot;summary_data_bytes=&quot; SIZE_FORMAT, total_words * HeapWordSize);
 285 }
 286 
 287 void
 288 PSParallelCompact::print_generic_summary_data(ParallelCompactData&amp; summary_data,
 289                                               HeapWord* const beg_addr,
 290                                               HeapWord* const end_addr) {
 291   ::print_generic_summary_data(summary_data,beg_addr, end_addr);
 292 }
 293 
 294 void
 295 print_generic_summary_data(ParallelCompactData&amp; summary_data,
 296                            SpaceInfo* space_info)
 297 {
 298   if (!log_develop_is_enabled(Trace, gc, compaction)) {
 299     return;
 300   }
 301 
 302   for (unsigned int id = 0; id &lt; PSParallelCompact::last_space_id; ++id) {
 303     const MutableSpace* space = space_info[id].space();
 304     print_generic_summary_data(summary_data, space-&gt;bottom(),
 305                                MAX2(space-&gt;top(), space_info[id].new_top()));
 306   }
 307 }
 308 
 309 void
 310 print_initial_summary_data(ParallelCompactData&amp; summary_data,
 311                            const MutableSpace* space) {
 312   if (space-&gt;top() == space-&gt;bottom()) {
 313     return;
 314   }
 315 
 316   const size_t region_size = ParallelCompactData::RegionSize;
 317   typedef ParallelCompactData::RegionData RegionData;
 318   HeapWord* const top_aligned_up = summary_data.region_align_up(space-&gt;top());
 319   const size_t end_region = summary_data.addr_to_region_idx(top_aligned_up);
 320   const RegionData* c = summary_data.region(end_region - 1);
 321   HeapWord* end_addr = c-&gt;destination() + c-&gt;data_size();
 322   const size_t live_in_space = pointer_delta(end_addr, space-&gt;bottom());
 323 
 324   // Print (and count) the full regions at the beginning of the space.
 325   size_t full_region_count = 0;
 326   size_t i = summary_data.addr_to_region_idx(space-&gt;bottom());
 327   while (i &lt; end_region &amp;&amp; summary_data.region(i)-&gt;data_size() == region_size) {
 328     ParallelCompactData::RegionData* c = summary_data.region(i);
 329     log_develop_trace(gc, compaction)(
 330         SIZE_FORMAT_W(5) &quot; &quot; PTR_FORMAT &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; %d&quot;,
 331         i, p2i(c-&gt;destination()),
 332         c-&gt;partial_obj_size(), c-&gt;live_obj_size(),
 333         c-&gt;data_size(), c-&gt;source_region(), c-&gt;destination_count());
 334     ++full_region_count;
 335     ++i;
 336   }
 337 
 338   size_t live_to_right = live_in_space - full_region_count * region_size;
 339 
 340   double max_reclaimed_ratio = 0.0;
 341   size_t max_reclaimed_ratio_region = 0;
 342   size_t max_dead_to_right = 0;
 343   size_t max_live_to_right = 0;
 344 
 345   // Print the &#39;reclaimed ratio&#39; for regions while there is something live in
 346   // the region or to the right of it.  The remaining regions are empty (and
 347   // uninteresting), and computing the ratio will result in division by 0.
 348   while (i &lt; end_region &amp;&amp; live_to_right &gt; 0) {
 349     c = summary_data.region(i);
 350     HeapWord* const region_addr = summary_data.region_to_addr(i);
 351     const size_t used_to_right = pointer_delta(space-&gt;top(), region_addr);
 352     const size_t dead_to_right = used_to_right - live_to_right;
 353     const double reclaimed_ratio = double(dead_to_right) / live_to_right;
 354 
 355     if (reclaimed_ratio &gt; max_reclaimed_ratio) {
 356             max_reclaimed_ratio = reclaimed_ratio;
 357             max_reclaimed_ratio_region = i;
 358             max_dead_to_right = dead_to_right;
 359             max_live_to_right = live_to_right;
 360     }
 361 
 362     ParallelCompactData::RegionData* c = summary_data.region(i);
 363     log_develop_trace(gc, compaction)(
 364         SIZE_FORMAT_W(5) &quot; &quot; PTR_FORMAT &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; %d&quot;
 365         &quot;%12.10f &quot; SIZE_FORMAT_W(10) &quot; &quot; SIZE_FORMAT_W(10),
 366         i, p2i(c-&gt;destination()),
 367         c-&gt;partial_obj_size(), c-&gt;live_obj_size(),
 368         c-&gt;data_size(), c-&gt;source_region(), c-&gt;destination_count(),
 369         reclaimed_ratio, dead_to_right, live_to_right);
 370 
 371 
 372     live_to_right -= c-&gt;data_size();
 373     ++i;
 374   }
 375 
 376   // Any remaining regions are empty.  Print one more if there is one.
 377   if (i &lt; end_region) {
 378     ParallelCompactData::RegionData* c = summary_data.region(i);
 379     log_develop_trace(gc, compaction)(
 380         SIZE_FORMAT_W(5) &quot; &quot; PTR_FORMAT &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; %d&quot;,
 381          i, p2i(c-&gt;destination()),
 382          c-&gt;partial_obj_size(), c-&gt;live_obj_size(),
 383          c-&gt;data_size(), c-&gt;source_region(), c-&gt;destination_count());
 384   }
 385 
 386   log_develop_trace(gc, compaction)(&quot;max:  &quot; SIZE_FORMAT_W(4) &quot; d2r=&quot; SIZE_FORMAT_W(10) &quot; l2r=&quot; SIZE_FORMAT_W(10) &quot; max_ratio=%14.12f&quot;,
 387                                     max_reclaimed_ratio_region, max_dead_to_right, max_live_to_right, max_reclaimed_ratio);
 388 }
 389 
 390 void
 391 print_initial_summary_data(ParallelCompactData&amp; summary_data,
 392                            SpaceInfo* space_info) {
 393   if (!log_develop_is_enabled(Trace, gc, compaction)) {
 394     return;
 395   }
 396 
 397   unsigned int id = PSParallelCompact::old_space_id;
 398   const MutableSpace* space;
 399   do {
 400     space = space_info[id].space();
 401     print_initial_summary_data(summary_data, space);
 402   } while (++id &lt; PSParallelCompact::eden_space_id);
 403 
 404   do {
 405     space = space_info[id].space();
 406     print_generic_summary_data(summary_data, space-&gt;bottom(), space-&gt;top());
 407   } while (++id &lt; PSParallelCompact::last_space_id);
 408 }
 409 #endif  // #ifndef PRODUCT
 410 
 411 #ifdef  ASSERT
 412 size_t add_obj_count;
 413 size_t add_obj_size;
 414 size_t mark_bitmap_count;
 415 size_t mark_bitmap_size;
 416 #endif  // #ifdef ASSERT
 417 
 418 ParallelCompactData::ParallelCompactData() :
 419   _region_start(NULL),
 420   DEBUG_ONLY(_region_end(NULL) COMMA)
 421   _region_vspace(NULL),
 422   _reserved_byte_size(0),
 423   _region_data(NULL),
 424   _region_count(0),
 425   _block_vspace(NULL),
 426   _block_data(NULL),
 427   _block_count(0) {}
 428 
 429 bool ParallelCompactData::initialize(MemRegion covered_region)
 430 {
 431   _region_start = covered_region.start();
 432   const size_t region_size = covered_region.word_size();
 433   DEBUG_ONLY(_region_end = _region_start + region_size;)
 434 
 435   assert(region_align_down(_region_start) == _region_start,
 436          &quot;region start not aligned&quot;);
 437   assert((region_size &amp; RegionSizeOffsetMask) == 0,
 438          &quot;region size not a multiple of RegionSize&quot;);
 439 
 440   bool result = initialize_region_data(region_size) &amp;&amp; initialize_block_data();
 441   return result;
 442 }
 443 
 444 PSVirtualSpace*
 445 ParallelCompactData::create_vspace(size_t count, size_t element_size)
 446 {
 447   const size_t raw_bytes = count * element_size;
 448   const size_t page_sz = os::page_size_for_region_aligned(raw_bytes, 10);
 449   const size_t granularity = os::vm_allocation_granularity();
 450   _reserved_byte_size = align_up(raw_bytes, MAX2(page_sz, granularity));
 451 
 452   const size_t rs_align = page_sz == (size_t) os::vm_page_size() ? 0 :
 453     MAX2(page_sz, granularity);
 454   ReservedSpace rs(_reserved_byte_size, rs_align, rs_align &gt; 0);
 455   os::trace_page_sizes(&quot;Parallel Compact Data&quot;, raw_bytes, raw_bytes, page_sz, rs.base(),
 456                        rs.size());
 457 
 458   MemTracker::record_virtual_memory_type((address)rs.base(), mtGC);
 459 
 460   PSVirtualSpace* vspace = new PSVirtualSpace(rs, page_sz);
 461   if (vspace != 0) {
 462     if (vspace-&gt;expand_by(_reserved_byte_size)) {
 463       return vspace;
 464     }
 465     delete vspace;
 466     // Release memory reserved in the space.
 467     rs.release();
 468   }
 469 
 470   return 0;
 471 }
 472 
 473 bool ParallelCompactData::initialize_region_data(size_t region_size)
 474 {
 475   const size_t count = (region_size + RegionSizeOffsetMask) &gt;&gt; Log2RegionSize;
 476   _region_vspace = create_vspace(count, sizeof(RegionData));
 477   if (_region_vspace != 0) {
 478     _region_data = (RegionData*)_region_vspace-&gt;reserved_low_addr();
 479     _region_count = count;
 480     return true;
 481   }
 482   return false;
 483 }
 484 
 485 bool ParallelCompactData::initialize_block_data()
 486 {
 487   assert(_region_count != 0, &quot;region data must be initialized first&quot;);
 488   const size_t count = _region_count &lt;&lt; Log2BlocksPerRegion;
 489   _block_vspace = create_vspace(count, sizeof(BlockData));
 490   if (_block_vspace != 0) {
 491     _block_data = (BlockData*)_block_vspace-&gt;reserved_low_addr();
 492     _block_count = count;
 493     return true;
 494   }
 495   return false;
 496 }
 497 
 498 void ParallelCompactData::clear()
 499 {
 500   memset(_region_data, 0, _region_vspace-&gt;committed_size());
 501   memset(_block_data, 0, _block_vspace-&gt;committed_size());
 502 }
 503 
 504 void ParallelCompactData::clear_range(size_t beg_region, size_t end_region) {
 505   assert(beg_region &lt;= _region_count, &quot;beg_region out of range&quot;);
 506   assert(end_region &lt;= _region_count, &quot;end_region out of range&quot;);
 507   assert(RegionSize % BlockSize == 0, &quot;RegionSize not a multiple of BlockSize&quot;);
 508 
 509   const size_t region_cnt = end_region - beg_region;
 510   memset(_region_data + beg_region, 0, region_cnt * sizeof(RegionData));
 511 
 512   const size_t beg_block = beg_region * BlocksPerRegion;
 513   const size_t block_cnt = region_cnt * BlocksPerRegion;
 514   memset(_block_data + beg_block, 0, block_cnt * sizeof(BlockData));
 515 }
 516 
 517 HeapWord* ParallelCompactData::partial_obj_end(size_t region_idx) const
 518 {
 519   const RegionData* cur_cp = region(region_idx);
 520   const RegionData* const end_cp = region(region_count() - 1);
 521 
 522   HeapWord* result = region_to_addr(region_idx);
 523   if (cur_cp &lt; end_cp) {
 524     do {
 525       result += cur_cp-&gt;partial_obj_size();
 526     } while (cur_cp-&gt;partial_obj_size() == RegionSize &amp;&amp; ++cur_cp &lt; end_cp);
 527   }
 528   return result;
 529 }
 530 
 531 void ParallelCompactData::add_obj(HeapWord* addr, size_t len)
 532 {
 533   const size_t obj_ofs = pointer_delta(addr, _region_start);
 534   const size_t beg_region = obj_ofs &gt;&gt; Log2RegionSize;
 535   const size_t end_region = (obj_ofs + len - 1) &gt;&gt; Log2RegionSize;
 536 
 537   DEBUG_ONLY(Atomic::inc(&amp;add_obj_count);)
 538   DEBUG_ONLY(Atomic::add(&amp;add_obj_size, len);)
 539 
 540   if (beg_region == end_region) {
 541     // All in one region.
 542     _region_data[beg_region].add_live_obj(len);
 543     return;
 544   }
 545 
 546   // First region.
 547   const size_t beg_ofs = region_offset(addr);
 548   _region_data[beg_region].add_live_obj(RegionSize - beg_ofs);
 549 
 550   Klass* klass = ((oop)addr)-&gt;klass();
 551   // Middle regions--completely spanned by this object.
 552   for (size_t region = beg_region + 1; region &lt; end_region; ++region) {
 553     _region_data[region].set_partial_obj_size(RegionSize);
 554     _region_data[region].set_partial_obj_addr(addr);
 555   }
 556 
 557   // Last region.
 558   const size_t end_ofs = region_offset(addr + len - 1);
 559   _region_data[end_region].set_partial_obj_size(end_ofs + 1);
 560   _region_data[end_region].set_partial_obj_addr(addr);
 561 }
 562 
 563 void
 564 ParallelCompactData::summarize_dense_prefix(HeapWord* beg, HeapWord* end)
 565 {
 566   assert(region_offset(beg) == 0, &quot;not RegionSize aligned&quot;);
 567   assert(region_offset(end) == 0, &quot;not RegionSize aligned&quot;);
 568 
 569   size_t cur_region = addr_to_region_idx(beg);
 570   const size_t end_region = addr_to_region_idx(end);
 571   HeapWord* addr = beg;
 572   while (cur_region &lt; end_region) {
 573     _region_data[cur_region].set_destination(addr);
 574     _region_data[cur_region].set_destination_count(0);
 575     _region_data[cur_region].set_source_region(cur_region);
 576     _region_data[cur_region].set_data_location(addr);
 577 
 578     // Update live_obj_size so the region appears completely full.
 579     size_t live_size = RegionSize - _region_data[cur_region].partial_obj_size();
 580     _region_data[cur_region].set_live_obj_size(live_size);
 581 
 582     ++cur_region;
 583     addr += RegionSize;
 584   }
 585 }
 586 
 587 // Find the point at which a space can be split and, if necessary, record the
 588 // split point.
 589 //
 590 // If the current src region (which overflowed the destination space) doesn&#39;t
 591 // have a partial object, the split point is at the beginning of the current src
 592 // region (an &quot;easy&quot; split, no extra bookkeeping required).
 593 //
 594 // If the current src region has a partial object, the split point is in the
 595 // region where that partial object starts (call it the split_region).  If
 596 // split_region has a partial object, then the split point is just after that
 597 // partial object (a &quot;hard&quot; split where we have to record the split data and
 598 // zero the partial_obj_size field).  With a &quot;hard&quot; split, we know that the
 599 // partial_obj ends within split_region because the partial object that caused
 600 // the overflow starts in split_region.  If split_region doesn&#39;t have a partial
 601 // obj, then the split is at the beginning of split_region (another &quot;easy&quot;
 602 // split).
 603 HeapWord*
 604 ParallelCompactData::summarize_split_space(size_t src_region,
 605                                            SplitInfo&amp; split_info,
 606                                            HeapWord* destination,
 607                                            HeapWord* target_end,
 608                                            HeapWord** target_next)
 609 {
 610   assert(destination &lt;= target_end, &quot;sanity&quot;);
 611   assert(destination + _region_data[src_region].data_size() &gt; target_end,
 612     &quot;region should not fit into target space&quot;);
 613   assert(is_region_aligned(target_end), &quot;sanity&quot;);
 614 
 615   size_t split_region = src_region;
 616   HeapWord* split_destination = destination;
 617   size_t partial_obj_size = _region_data[src_region].partial_obj_size();
 618 
 619   if (destination + partial_obj_size &gt; target_end) {
 620     // The split point is just after the partial object (if any) in the
 621     // src_region that contains the start of the object that overflowed the
 622     // destination space.
 623     //
 624     // Find the start of the &quot;overflow&quot; object and set split_region to the
 625     // region containing it.
 626     HeapWord* const overflow_obj = _region_data[src_region].partial_obj_addr();
 627     split_region = addr_to_region_idx(overflow_obj);
 628 
 629     // Clear the source_region field of all destination regions whose first word
 630     // came from data after the split point (a non-null source_region field
 631     // implies a region must be filled).
 632     //
 633     // An alternative to the simple loop below:  clear during post_compact(),
 634     // which uses memcpy instead of individual stores, and is easy to
 635     // parallelize.  (The downside is that it clears the entire RegionData
 636     // object as opposed to just one field.)
 637     //
 638     // post_compact() would have to clear the summary data up to the highest
 639     // address that was written during the summary phase, which would be
 640     //
 641     //         max(top, max(new_top, clear_top))
 642     //
 643     // where clear_top is a new field in SpaceInfo.  Would have to set clear_top
 644     // to target_end.
 645     const RegionData* const sr = region(split_region);
 646     const size_t beg_idx =
 647       addr_to_region_idx(region_align_up(sr-&gt;destination() +
 648                                          sr-&gt;partial_obj_size()));
 649     const size_t end_idx = addr_to_region_idx(target_end);
 650 
 651     log_develop_trace(gc, compaction)(&quot;split:  clearing source_region field in [&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;)&quot;, beg_idx, end_idx);
 652     for (size_t idx = beg_idx; idx &lt; end_idx; ++idx) {
 653       _region_data[idx].set_source_region(0);
 654     }
 655 
 656     // Set split_destination and partial_obj_size to reflect the split region.
 657     split_destination = sr-&gt;destination();
 658     partial_obj_size = sr-&gt;partial_obj_size();
 659   }
 660 
 661   // The split is recorded only if a partial object extends onto the region.
 662   if (partial_obj_size != 0) {
 663     _region_data[split_region].set_partial_obj_size(0);
 664     split_info.record(split_region, partial_obj_size, split_destination);
 665   }
 666 
 667   // Setup the continuation addresses.
 668   *target_next = split_destination + partial_obj_size;
 669   HeapWord* const source_next = region_to_addr(split_region) + partial_obj_size;
 670 
 671   if (log_develop_is_enabled(Trace, gc, compaction)) {
 672     const char * split_type = partial_obj_size == 0 ? &quot;easy&quot; : &quot;hard&quot;;
 673     log_develop_trace(gc, compaction)(&quot;%s split:  src=&quot; PTR_FORMAT &quot; src_c=&quot; SIZE_FORMAT &quot; pos=&quot; SIZE_FORMAT,
 674                                       split_type, p2i(source_next), split_region, partial_obj_size);
 675     log_develop_trace(gc, compaction)(&quot;%s split:  dst=&quot; PTR_FORMAT &quot; dst_c=&quot; SIZE_FORMAT &quot; tn=&quot; PTR_FORMAT,
 676                                       split_type, p2i(split_destination),
 677                                       addr_to_region_idx(split_destination),
 678                                       p2i(*target_next));
 679 
 680     if (partial_obj_size != 0) {
 681       HeapWord* const po_beg = split_info.destination();
 682       HeapWord* const po_end = po_beg + split_info.partial_obj_size();
 683       log_develop_trace(gc, compaction)(&quot;%s split:  po_beg=&quot; PTR_FORMAT &quot; &quot; SIZE_FORMAT &quot; po_end=&quot; PTR_FORMAT &quot; &quot; SIZE_FORMAT,
 684                                         split_type,
 685                                         p2i(po_beg), addr_to_region_idx(po_beg),
 686                                         p2i(po_end), addr_to_region_idx(po_end));
 687     }
 688   }
 689 
 690   return source_next;
 691 }
 692 
 693 bool ParallelCompactData::summarize(SplitInfo&amp; split_info,
 694                                     HeapWord* source_beg, HeapWord* source_end,
 695                                     HeapWord** source_next,
 696                                     HeapWord* target_beg, HeapWord* target_end,
 697                                     HeapWord** target_next)
 698 {
 699   HeapWord* const source_next_val = source_next == NULL ? NULL : *source_next;
 700   log_develop_trace(gc, compaction)(
 701       &quot;sb=&quot; PTR_FORMAT &quot; se=&quot; PTR_FORMAT &quot; sn=&quot; PTR_FORMAT
 702       &quot;tb=&quot; PTR_FORMAT &quot; te=&quot; PTR_FORMAT &quot; tn=&quot; PTR_FORMAT,
 703       p2i(source_beg), p2i(source_end), p2i(source_next_val),
 704       p2i(target_beg), p2i(target_end), p2i(*target_next));
 705 
 706   size_t cur_region = addr_to_region_idx(source_beg);
 707   const size_t end_region = addr_to_region_idx(region_align_up(source_end));
 708 
 709   HeapWord *dest_addr = target_beg;
 710   while (cur_region &lt; end_region) {
 711     // The destination must be set even if the region has no data.
 712     _region_data[cur_region].set_destination(dest_addr);
 713 
 714     size_t words = _region_data[cur_region].data_size();
 715     if (words &gt; 0) {
 716       // If cur_region does not fit entirely into the target space, find a point
 717       // at which the source space can be &#39;split&#39; so that part is copied to the
 718       // target space and the rest is copied elsewhere.
 719       if (dest_addr + words &gt; target_end) {
 720         assert(source_next != NULL, &quot;source_next is NULL when splitting&quot;);
 721         *source_next = summarize_split_space(cur_region, split_info, dest_addr,
 722                                              target_end, target_next);
 723         return false;
 724       }
 725 
 726       // Compute the destination_count for cur_region, and if necessary, update
 727       // source_region for a destination region.  The source_region field is
 728       // updated if cur_region is the first (left-most) region to be copied to a
 729       // destination region.
 730       //
 731       // The destination_count calculation is a bit subtle.  A region that has
 732       // data that compacts into itself does not count itself as a destination.
 733       // This maintains the invariant that a zero count means the region is
 734       // available and can be claimed and then filled.
 735       uint destination_count = 0;
 736       if (split_info.is_split(cur_region)) {
 737         // The current region has been split:  the partial object will be copied
 738         // to one destination space and the remaining data will be copied to
 739         // another destination space.  Adjust the initial destination_count and,
 740         // if necessary, set the source_region field if the partial object will
 741         // cross a destination region boundary.
 742         destination_count = split_info.destination_count();
 743         if (destination_count == 2) {
 744           size_t dest_idx = addr_to_region_idx(split_info.dest_region_addr());
 745           _region_data[dest_idx].set_source_region(cur_region);
 746         }
 747       }
 748 
 749       HeapWord* const last_addr = dest_addr + words - 1;
 750       const size_t dest_region_1 = addr_to_region_idx(dest_addr);
 751       const size_t dest_region_2 = addr_to_region_idx(last_addr);
 752 
 753       // Initially assume that the destination regions will be the same and
 754       // adjust the value below if necessary.  Under this assumption, if
 755       // cur_region == dest_region_2, then cur_region will be compacted
 756       // completely into itself.
 757       destination_count += cur_region == dest_region_2 ? 0 : 1;
 758       if (dest_region_1 != dest_region_2) {
 759         // Destination regions differ; adjust destination_count.
 760         destination_count += 1;
 761         // Data from cur_region will be copied to the start of dest_region_2.
 762         _region_data[dest_region_2].set_source_region(cur_region);
 763       } else if (region_offset(dest_addr) == 0) {
 764         // Data from cur_region will be copied to the start of the destination
 765         // region.
 766         _region_data[dest_region_1].set_source_region(cur_region);
 767       }
 768 
 769       _region_data[cur_region].set_destination_count(destination_count);
 770       _region_data[cur_region].set_data_location(region_to_addr(cur_region));
 771       dest_addr += words;
 772     }
 773 
 774     ++cur_region;
 775   }
 776 
 777   *target_next = dest_addr;
 778   return true;
 779 }
 780 
 781 HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) {
 782   assert(addr != NULL, &quot;Should detect NULL oop earlier&quot;);
 783   assert(ParallelScavengeHeap::heap()-&gt;is_in(addr), &quot;not in heap&quot;);
 784   assert(PSParallelCompact::mark_bitmap()-&gt;is_marked(addr), &quot;not marked&quot;);
 785 
 786   // Region covering the object.
 787   RegionData* const region_ptr = addr_to_region_ptr(addr);
 788   HeapWord* result = region_ptr-&gt;destination();
 789 
 790   // If the entire Region is live, the new location is region-&gt;destination + the
 791   // offset of the object within in the Region.
 792 
 793   // Run some performance tests to determine if this special case pays off.  It
 794   // is worth it for pointers into the dense prefix.  If the optimization to
 795   // avoid pointer updates in regions that only point to the dense prefix is
 796   // ever implemented, this should be revisited.
 797   if (region_ptr-&gt;data_size() == RegionSize) {
 798     result += region_offset(addr);
 799     return result;
 800   }
 801 
 802   // Otherwise, the new location is region-&gt;destination + block offset + the
 803   // number of live words in the Block that are (a) to the left of addr and (b)
 804   // due to objects that start in the Block.
 805 
 806   // Fill in the block table if necessary.  This is unsynchronized, so multiple
 807   // threads may fill the block table for a region (harmless, since it is
 808   // idempotent).
 809   if (!region_ptr-&gt;blocks_filled()) {
 810     PSParallelCompact::fill_blocks(addr_to_region_idx(addr));
 811     region_ptr-&gt;set_blocks_filled();
 812   }
 813 
 814   HeapWord* const search_start = block_align_down(addr);
 815   const size_t block_offset = addr_to_block_ptr(addr)-&gt;offset();
 816 
 817   const ParMarkBitMap* bitmap = PSParallelCompact::mark_bitmap();
 818   const size_t live = bitmap-&gt;live_words_in_range(cm, search_start, oop(addr));
 819   result += block_offset + live;
 820   DEBUG_ONLY(PSParallelCompact::check_new_location(addr, result));
 821   return result;
 822 }
 823 
 824 #ifdef ASSERT
 825 void ParallelCompactData::verify_clear(const PSVirtualSpace* vspace)
 826 {
 827   const size_t* const beg = (const size_t*)vspace-&gt;committed_low_addr();
 828   const size_t* const end = (const size_t*)vspace-&gt;committed_high_addr();
 829   for (const size_t* p = beg; p &lt; end; ++p) {
 830     assert(*p == 0, &quot;not zero&quot;);
 831   }
 832 }
 833 
 834 void ParallelCompactData::verify_clear()
 835 {
 836   verify_clear(_region_vspace);
 837   verify_clear(_block_vspace);
 838 }
 839 #endif  // #ifdef ASSERT
 840 
 841 STWGCTimer          PSParallelCompact::_gc_timer;
 842 ParallelOldTracer   PSParallelCompact::_gc_tracer;
 843 elapsedTimer        PSParallelCompact::_accumulated_time;
 844 unsigned int        PSParallelCompact::_total_invocations = 0;
 845 unsigned int        PSParallelCompact::_maximum_compaction_gc_num = 0;
 846 jlong               PSParallelCompact::_time_of_last_gc = 0;
 847 CollectorCounters*  PSParallelCompact::_counters = NULL;
 848 ParMarkBitMap       PSParallelCompact::_mark_bitmap;
 849 ParallelCompactData PSParallelCompact::_summary_data;
 850 
 851 PSParallelCompact::IsAliveClosure PSParallelCompact::_is_alive_closure;
 852 
 853 bool PSParallelCompact::IsAliveClosure::do_object_b(oop p) { return mark_bitmap()-&gt;is_marked(p); }
 854 
 855 class PCReferenceProcessor: public ReferenceProcessor {
 856 public:
 857   PCReferenceProcessor(
 858     BoolObjectClosure* is_subject_to_discovery,
 859     BoolObjectClosure* is_alive_non_header) :
 860       ReferenceProcessor(is_subject_to_discovery,
 861       ParallelRefProcEnabled &amp;&amp; (ParallelGCThreads &gt; 1), // mt processing
 862       ParallelGCThreads,   // mt processing degree
 863       true,                // mt discovery
 864       ParallelGCThreads,   // mt discovery degree
 865       true,                // atomic_discovery
 866       is_alive_non_header) {
 867   }
 868 
 869   template&lt;typename T&gt; bool discover(oop obj, ReferenceType type) {
 870     T* referent_addr = (T*) java_lang_ref_Reference::referent_addr_raw(obj);
 871     T heap_oop = RawAccess&lt;&gt;::oop_load(referent_addr);
 872     oop referent = CompressedOops::decode_not_null(heap_oop);
 873     return PSParallelCompact::mark_bitmap()-&gt;is_unmarked(referent)
 874         &amp;&amp; ReferenceProcessor::discover_reference(obj, type);
 875   }
 876   virtual bool discover_reference(oop obj, ReferenceType type) {
 877     if (UseCompressedOops) {
 878       return discover&lt;narrowOop&gt;(obj, type);
 879     } else {
 880       return discover&lt;oop&gt;(obj, type);
 881     }
 882   }
 883 };
 884 
 885 void PSParallelCompact::post_initialize() {
 886   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 887   _span_based_discoverer.set_span(heap-&gt;reserved_region());
 888   _ref_processor =
 889     new PCReferenceProcessor(&amp;_span_based_discoverer,
 890                              &amp;_is_alive_closure); // non-header is alive closure
 891 
 892   _counters = new CollectorCounters(&quot;Parallel full collection pauses&quot;, 1);
 893 
 894   // Initialize static fields in ParCompactionManager.
 895   ParCompactionManager::initialize(mark_bitmap());
 896 }
 897 
 898 bool PSParallelCompact::initialize() {
 899   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 900   MemRegion mr = heap-&gt;reserved_region();
 901 
 902   // Was the old gen get allocated successfully?
 903   if (!heap-&gt;old_gen()-&gt;is_allocated()) {
 904     return false;
 905   }
 906 
 907   initialize_space_info();
 908   initialize_dead_wood_limiter();
 909 
 910   if (!_mark_bitmap.initialize(mr)) {
 911     vm_shutdown_during_initialization(
 912       err_msg(&quot;Unable to allocate &quot; SIZE_FORMAT &quot;KB bitmaps for parallel &quot;
 913       &quot;garbage collection for the requested &quot; SIZE_FORMAT &quot;KB heap.&quot;,
 914       _mark_bitmap.reserved_byte_size()/K, mr.byte_size()/K));
 915     return false;
 916   }
 917 
 918   if (!_summary_data.initialize(mr)) {
 919     vm_shutdown_during_initialization(
 920       err_msg(&quot;Unable to allocate &quot; SIZE_FORMAT &quot;KB card tables for parallel &quot;
 921       &quot;garbage collection for the requested &quot; SIZE_FORMAT &quot;KB heap.&quot;,
 922       _summary_data.reserved_byte_size()/K, mr.byte_size()/K));
 923     return false;
 924   }
 925 
 926   return true;
 927 }
 928 
 929 void PSParallelCompact::initialize_space_info()
 930 {
 931   memset(&amp;_space_info, 0, sizeof(_space_info));
 932 
 933   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 934   PSYoungGen* young_gen = heap-&gt;young_gen();
 935 
 936   _space_info[old_space_id].set_space(heap-&gt;old_gen()-&gt;object_space());
 937   _space_info[eden_space_id].set_space(young_gen-&gt;eden_space());
 938   _space_info[from_space_id].set_space(young_gen-&gt;from_space());
 939   _space_info[to_space_id].set_space(young_gen-&gt;to_space());
 940 
 941   _space_info[old_space_id].set_start_array(heap-&gt;old_gen()-&gt;start_array());
 942 }
 943 
 944 void PSParallelCompact::initialize_dead_wood_limiter()
 945 {
 946   const size_t max = 100;
 947   _dwl_mean = double(MIN2(ParallelOldDeadWoodLimiterMean, max)) / 100.0;
 948   _dwl_std_dev = double(MIN2(ParallelOldDeadWoodLimiterStdDev, max)) / 100.0;
 949   _dwl_first_term = 1.0 / (sqrt(2.0 * M_PI) * _dwl_std_dev);
 950   DEBUG_ONLY(_dwl_initialized = true;)
 951   _dwl_adjustment = normal_distribution(1.0);
 952 }
 953 
 954 void
 955 PSParallelCompact::clear_data_covering_space(SpaceId id)
 956 {
 957   // At this point, top is the value before GC, new_top() is the value that will
 958   // be set at the end of GC.  The marking bitmap is cleared to top; nothing
 959   // should be marked above top.  The summary data is cleared to the larger of
 960   // top &amp; new_top.
 961   MutableSpace* const space = _space_info[id].space();
 962   HeapWord* const bot = space-&gt;bottom();
 963   HeapWord* const top = space-&gt;top();
 964   HeapWord* const max_top = MAX2(top, _space_info[id].new_top());
 965 
 966   const idx_t beg_bit = _mark_bitmap.addr_to_bit(bot);
 967   const idx_t end_bit = _mark_bitmap.align_range_end(_mark_bitmap.addr_to_bit(top));
 968   _mark_bitmap.clear_range(beg_bit, end_bit);
 969 
 970   const size_t beg_region = _summary_data.addr_to_region_idx(bot);
 971   const size_t end_region =
 972     _summary_data.addr_to_region_idx(_summary_data.region_align_up(max_top));
 973   _summary_data.clear_range(beg_region, end_region);
 974 
 975   // Clear the data used to &#39;split&#39; regions.
 976   SplitInfo&amp; split_info = _space_info[id].split_info();
 977   if (split_info.is_valid()) {
 978     split_info.clear();
 979   }
 980   DEBUG_ONLY(split_info.verify_clear();)
 981 }
 982 
 983 void PSParallelCompact::pre_compact()
 984 {
 985   // Update the from &amp; to space pointers in space_info, since they are swapped
 986   // at each young gen gc.  Do the update unconditionally (even though a
 987   // promotion failure does not swap spaces) because an unknown number of young
 988   // collections will have swapped the spaces an unknown number of times.
 989   GCTraceTime(Debug, gc, phases) tm(&quot;Pre Compact&quot;, &amp;_gc_timer);
 990   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 991   _space_info[from_space_id].set_space(heap-&gt;young_gen()-&gt;from_space());
 992   _space_info[to_space_id].set_space(heap-&gt;young_gen()-&gt;to_space());
 993 
 994   DEBUG_ONLY(add_obj_count = add_obj_size = 0;)
 995   DEBUG_ONLY(mark_bitmap_count = mark_bitmap_size = 0;)
 996 
 997   // Increment the invocation count
 998   heap-&gt;increment_total_collections(true);
 999 
1000   CodeCache::increment_marking_cycle();
1001 
1002   // We need to track unique mark sweep invocations as well.
1003   _total_invocations++;
1004 
1005   heap-&gt;print_heap_before_gc();
1006   heap-&gt;trace_heap_before_gc(&amp;_gc_tracer);
1007 
1008   // Fill in TLABs
1009   heap-&gt;ensure_parsability(true);  // retire TLABs
1010 
1011   if (VerifyBeforeGC &amp;&amp; heap-&gt;total_collections() &gt;= VerifyGCStartAt) {
1012     HandleMark hm;  // Discard invalid handles created during verification
1013     Universe::verify(&quot;Before GC&quot;);
1014   }
1015 
1016   // Verify object start arrays
1017   if (VerifyObjectStartArray &amp;&amp;
1018       VerifyBeforeGC) {
1019     heap-&gt;old_gen()-&gt;verify_object_start_array();
1020   }
1021 
1022   DEBUG_ONLY(mark_bitmap()-&gt;verify_clear();)
1023   DEBUG_ONLY(summary_data().verify_clear();)
1024 
1025   ParCompactionManager::reset_all_bitmap_query_caches();
1026 }
1027 
1028 void PSParallelCompact::post_compact()
1029 {
1030   GCTraceTime(Info, gc, phases) tm(&quot;Post Compact&quot;, &amp;_gc_timer);
1031   ParCompactionManager::remove_all_shadow_regions();
1032 
1033   CodeCache::increment_marking_cycle();
1034 
1035   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
1036     // Clear the marking bitmap, summary data and split info.
1037     clear_data_covering_space(SpaceId(id));
1038     // Update top().  Must be done after clearing the bitmap and summary data.
1039     _space_info[id].publish_new_top();
1040   }
1041 
1042   MutableSpace* const eden_space = _space_info[eden_space_id].space();
1043   MutableSpace* const from_space = _space_info[from_space_id].space();
1044   MutableSpace* const to_space   = _space_info[to_space_id].space();
1045 
1046   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
1047   bool eden_empty = eden_space-&gt;is_empty();
1048 
1049   // Update heap occupancy information which is used as input to the soft ref
1050   // clearing policy at the next gc.
1051   Universe::update_heap_info_at_gc();
1052 
1053   bool young_gen_empty = eden_empty &amp;&amp; from_space-&gt;is_empty() &amp;&amp;
1054     to_space-&gt;is_empty();
1055 
1056   PSCardTable* ct = heap-&gt;card_table();
1057   MemRegion old_mr = heap-&gt;old_gen()-&gt;reserved();
1058   if (young_gen_empty) {
1059     ct-&gt;clear(MemRegion(old_mr.start(), old_mr.end()));
1060   } else {
1061     ct-&gt;invalidate(MemRegion(old_mr.start(), old_mr.end()));
1062   }
1063 
1064   // Delete metaspaces for unloaded class loaders and clean up loader_data graph
1065   ClassLoaderDataGraph::purge();
1066   MetaspaceUtils::verify_metrics();
1067 
1068   heap-&gt;prune_scavengable_nmethods();
1069 
1070 #if COMPILER2_OR_JVMCI
1071   DerivedPointerTable::update_pointers();
1072 #endif
1073 
1074   if (ZapUnusedHeapArea) {
1075     heap-&gt;gen_mangle_unused_area();
1076   }
1077 
1078   // Update time of last GC
1079   reset_millis_since_last_gc();
1080 }
1081 
1082 HeapWord*
1083 PSParallelCompact::compute_dense_prefix_via_density(const SpaceId id,
1084                                                     bool maximum_compaction)
1085 {
1086   const size_t region_size = ParallelCompactData::RegionSize;
1087   const ParallelCompactData&amp; sd = summary_data();
1088 
1089   const MutableSpace* const space = _space_info[id].space();
1090   HeapWord* const top_aligned_up = sd.region_align_up(space-&gt;top());
1091   const RegionData* const beg_cp = sd.addr_to_region_ptr(space-&gt;bottom());
1092   const RegionData* const end_cp = sd.addr_to_region_ptr(top_aligned_up);
1093 
1094   // Skip full regions at the beginning of the space--they are necessarily part
1095   // of the dense prefix.
1096   size_t full_count = 0;
1097   const RegionData* cp;
1098   for (cp = beg_cp; cp &lt; end_cp &amp;&amp; cp-&gt;data_size() == region_size; ++cp) {
1099     ++full_count;
1100   }
1101 
1102   assert(total_invocations() &gt;= _maximum_compaction_gc_num, &quot;sanity&quot;);
1103   const size_t gcs_since_max = total_invocations() - _maximum_compaction_gc_num;
1104   const bool interval_ended = gcs_since_max &gt; HeapMaximumCompactionInterval;
1105   if (maximum_compaction || cp == end_cp || interval_ended) {
1106     _maximum_compaction_gc_num = total_invocations();
1107     return sd.region_to_addr(cp);
1108   }
1109 
1110   HeapWord* const new_top = _space_info[id].new_top();
1111   const size_t space_live = pointer_delta(new_top, space-&gt;bottom());
1112   const size_t space_used = space-&gt;used_in_words();
1113   const size_t space_capacity = space-&gt;capacity_in_words();
1114 
1115   const double cur_density = double(space_live) / space_capacity;
1116   const double deadwood_density =
1117     (1.0 - cur_density) * (1.0 - cur_density) * cur_density * cur_density;
1118   const size_t deadwood_goal = size_t(space_capacity * deadwood_density);
1119 
1120   log_develop_debug(gc, compaction)(
1121       &quot;cur_dens=%5.3f dw_dens=%5.3f dw_goal=&quot; SIZE_FORMAT,
1122       cur_density, deadwood_density, deadwood_goal);
1123   log_develop_debug(gc, compaction)(
1124       &quot;space_live=&quot; SIZE_FORMAT &quot; space_used=&quot; SIZE_FORMAT &quot; &quot;
1125       &quot;space_cap=&quot; SIZE_FORMAT,
1126       space_live, space_used,
1127       space_capacity);
1128 
1129   // XXX - Use binary search?
1130   HeapWord* dense_prefix = sd.region_to_addr(cp);
1131   const RegionData* full_cp = cp;
1132   const RegionData* const top_cp = sd.addr_to_region_ptr(space-&gt;top() - 1);
1133   while (cp &lt; end_cp) {
1134     HeapWord* region_destination = cp-&gt;destination();
1135     const size_t cur_deadwood = pointer_delta(dense_prefix, region_destination);
1136 
1137     log_develop_trace(gc, compaction)(
1138         &quot;c#=&quot; SIZE_FORMAT_W(4) &quot; dst=&quot; PTR_FORMAT &quot; &quot;
1139         &quot;dp=&quot; PTR_FORMAT &quot; cdw=&quot; SIZE_FORMAT_W(8),
1140         sd.region(cp), p2i(region_destination),
1141         p2i(dense_prefix), cur_deadwood);
1142 
1143     if (cur_deadwood &gt;= deadwood_goal) {
1144       // Found the region that has the correct amount of deadwood to the left.
1145       // This typically occurs after crossing a fairly sparse set of regions, so
1146       // iterate backwards over those sparse regions, looking for the region
1147       // that has the lowest density of live objects &#39;to the right.&#39;
1148       size_t space_to_left = sd.region(cp) * region_size;
1149       size_t live_to_left = space_to_left - cur_deadwood;
1150       size_t space_to_right = space_capacity - space_to_left;
1151       size_t live_to_right = space_live - live_to_left;
1152       double density_to_right = double(live_to_right) / space_to_right;
1153       while (cp &gt; full_cp) {
1154         --cp;
1155         const size_t prev_region_live_to_right = live_to_right -
1156           cp-&gt;data_size();
1157         const size_t prev_region_space_to_right = space_to_right + region_size;
1158         double prev_region_density_to_right =
1159           double(prev_region_live_to_right) / prev_region_space_to_right;
1160         if (density_to_right &lt;= prev_region_density_to_right) {
1161           return dense_prefix;
1162         }
1163 
1164         log_develop_trace(gc, compaction)(
1165             &quot;backing up from c=&quot; SIZE_FORMAT_W(4) &quot; d2r=%10.8f &quot;
1166             &quot;pc_d2r=%10.8f&quot;,
1167             sd.region(cp), density_to_right,
1168             prev_region_density_to_right);
1169 
1170         dense_prefix -= region_size;
1171         live_to_right = prev_region_live_to_right;
1172         space_to_right = prev_region_space_to_right;
1173         density_to_right = prev_region_density_to_right;
1174       }
1175       return dense_prefix;
1176     }
1177 
1178     dense_prefix += region_size;
1179     ++cp;
1180   }
1181 
1182   return dense_prefix;
1183 }
1184 
1185 #ifndef PRODUCT
1186 void PSParallelCompact::print_dense_prefix_stats(const char* const algorithm,
1187                                                  const SpaceId id,
1188                                                  const bool maximum_compaction,
1189                                                  HeapWord* const addr)
1190 {
1191   const size_t region_idx = summary_data().addr_to_region_idx(addr);
1192   RegionData* const cp = summary_data().region(region_idx);
1193   const MutableSpace* const space = _space_info[id].space();
1194   HeapWord* const new_top = _space_info[id].new_top();
1195 
1196   const size_t space_live = pointer_delta(new_top, space-&gt;bottom());
1197   const size_t dead_to_left = pointer_delta(addr, cp-&gt;destination());
1198   const size_t space_cap = space-&gt;capacity_in_words();
1199   const double dead_to_left_pct = double(dead_to_left) / space_cap;
1200   const size_t live_to_right = new_top - cp-&gt;destination();
1201   const size_t dead_to_right = space-&gt;top() - addr - live_to_right;
1202 
1203   log_develop_debug(gc, compaction)(
1204       &quot;%s=&quot; PTR_FORMAT &quot; dpc=&quot; SIZE_FORMAT_W(5) &quot; &quot;
1205       &quot;spl=&quot; SIZE_FORMAT &quot; &quot;
1206       &quot;d2l=&quot; SIZE_FORMAT &quot; d2l%%=%6.4f &quot;
1207       &quot;d2r=&quot; SIZE_FORMAT &quot; l2r=&quot; SIZE_FORMAT &quot; &quot;
1208       &quot;ratio=%10.8f&quot;,
1209       algorithm, p2i(addr), region_idx,
1210       space_live,
1211       dead_to_left, dead_to_left_pct,
1212       dead_to_right, live_to_right,
1213       double(dead_to_right) / live_to_right);
1214 }
1215 #endif  // #ifndef PRODUCT
1216 
1217 // Return a fraction indicating how much of the generation can be treated as
1218 // &quot;dead wood&quot; (i.e., not reclaimed).  The function uses a normal distribution
1219 // based on the density of live objects in the generation to determine a limit,
1220 // which is then adjusted so the return value is min_percent when the density is
1221 // 1.
1222 //
1223 // The following table shows some return values for a different values of the
1224 // standard deviation (ParallelOldDeadWoodLimiterStdDev); the mean is 0.5 and
1225 // min_percent is 1.
1226 //
1227 //                          fraction allowed as dead wood
1228 //         -----------------------------------------------------------------
1229 // density std_dev=70 std_dev=75 std_dev=80 std_dev=85 std_dev=90 std_dev=95
1230 // ------- ---------- ---------- ---------- ---------- ---------- ----------
1231 // 0.00000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000
1232 // 0.05000 0.03193096 0.02836880 0.02550828 0.02319280 0.02130337 0.01974941
1233 // 0.10000 0.05247504 0.04547452 0.03988045 0.03537016 0.03170171 0.02869272
1234 // 0.15000 0.07135702 0.06111390 0.05296419 0.04641639 0.04110601 0.03676066
1235 // 0.20000 0.08831616 0.07509618 0.06461766 0.05622444 0.04943437 0.04388975
1236 // 0.25000 0.10311208 0.08724696 0.07471205 0.06469760 0.05661313 0.05002313
1237 // 0.30000 0.11553050 0.09741183 0.08313394 0.07175114 0.06257797 0.05511132
1238 // 0.35000 0.12538832 0.10545958 0.08978741 0.07731366 0.06727491 0.05911289
1239 // 0.40000 0.13253818 0.11128511 0.09459590 0.08132834 0.07066107 0.06199500
1240 // 0.45000 0.13687208 0.11481163 0.09750361 0.08375387 0.07270534 0.06373386
1241 // 0.50000 0.13832410 0.11599237 0.09847664 0.08456518 0.07338887 0.06431510
1242 // 0.55000 0.13687208 0.11481163 0.09750361 0.08375387 0.07270534 0.06373386
1243 // 0.60000 0.13253818 0.11128511 0.09459590 0.08132834 0.07066107 0.06199500
1244 // 0.65000 0.12538832 0.10545958 0.08978741 0.07731366 0.06727491 0.05911289
1245 // 0.70000 0.11553050 0.09741183 0.08313394 0.07175114 0.06257797 0.05511132
1246 // 0.75000 0.10311208 0.08724696 0.07471205 0.06469760 0.05661313 0.05002313
1247 // 0.80000 0.08831616 0.07509618 0.06461766 0.05622444 0.04943437 0.04388975
1248 // 0.85000 0.07135702 0.06111390 0.05296419 0.04641639 0.04110601 0.03676066
1249 // 0.90000 0.05247504 0.04547452 0.03988045 0.03537016 0.03170171 0.02869272
1250 // 0.95000 0.03193096 0.02836880 0.02550828 0.02319280 0.02130337 0.01974941
1251 // 1.00000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000
1252 
1253 double PSParallelCompact::dead_wood_limiter(double density, size_t min_percent)
1254 {
1255   assert(_dwl_initialized, &quot;uninitialized&quot;);
1256 
1257   // The raw limit is the value of the normal distribution at x = density.
1258   const double raw_limit = normal_distribution(density);
1259 
1260   // Adjust the raw limit so it becomes the minimum when the density is 1.
1261   //
1262   // First subtract the adjustment value (which is simply the precomputed value
1263   // normal_distribution(1.0)); this yields a value of 0 when the density is 1.
1264   // Then add the minimum value, so the minimum is returned when the density is
1265   // 1.  Finally, prevent negative values, which occur when the mean is not 0.5.
1266   const double min = double(min_percent) / 100.0;
1267   const double limit = raw_limit - _dwl_adjustment + min;
1268   return MAX2(limit, 0.0);
1269 }
1270 
1271 ParallelCompactData::RegionData*
1272 PSParallelCompact::first_dead_space_region(const RegionData* beg,
1273                                            const RegionData* end)
1274 {
1275   const size_t region_size = ParallelCompactData::RegionSize;
1276   ParallelCompactData&amp; sd = summary_data();
1277   size_t left = sd.region(beg);
1278   size_t right = end &gt; beg ? sd.region(end) - 1 : left;
1279 
1280   // Binary search.
1281   while (left &lt; right) {
1282     // Equivalent to (left + right) / 2, but does not overflow.
1283     const size_t middle = left + (right - left) / 2;
1284     RegionData* const middle_ptr = sd.region(middle);
1285     HeapWord* const dest = middle_ptr-&gt;destination();
1286     HeapWord* const addr = sd.region_to_addr(middle);
1287     assert(dest != NULL, &quot;sanity&quot;);
1288     assert(dest &lt;= addr, &quot;must move left&quot;);
1289 
1290     if (middle &gt; left &amp;&amp; dest &lt; addr) {
1291       right = middle - 1;
1292     } else if (middle &lt; right &amp;&amp; middle_ptr-&gt;data_size() == region_size) {
1293       left = middle + 1;
1294     } else {
1295       return middle_ptr;
1296     }
1297   }
1298   return sd.region(left);
1299 }
1300 
1301 ParallelCompactData::RegionData*
1302 PSParallelCompact::dead_wood_limit_region(const RegionData* beg,
1303                                           const RegionData* end,
1304                                           size_t dead_words)
1305 {
1306   ParallelCompactData&amp; sd = summary_data();
1307   size_t left = sd.region(beg);
1308   size_t right = end &gt; beg ? sd.region(end) - 1 : left;
1309 
1310   // Binary search.
1311   while (left &lt; right) {
1312     // Equivalent to (left + right) / 2, but does not overflow.
1313     const size_t middle = left + (right - left) / 2;
1314     RegionData* const middle_ptr = sd.region(middle);
1315     HeapWord* const dest = middle_ptr-&gt;destination();
1316     HeapWord* const addr = sd.region_to_addr(middle);
1317     assert(dest != NULL, &quot;sanity&quot;);
1318     assert(dest &lt;= addr, &quot;must move left&quot;);
1319 
1320     const size_t dead_to_left = pointer_delta(addr, dest);
1321     if (middle &gt; left &amp;&amp; dead_to_left &gt; dead_words) {
1322       right = middle - 1;
1323     } else if (middle &lt; right &amp;&amp; dead_to_left &lt; dead_words) {
1324       left = middle + 1;
1325     } else {
1326       return middle_ptr;
1327     }
1328   }
1329   return sd.region(left);
1330 }
1331 
1332 // The result is valid during the summary phase, after the initial summarization
1333 // of each space into itself, and before final summarization.
1334 inline double
1335 PSParallelCompact::reclaimed_ratio(const RegionData* const cp,
1336                                    HeapWord* const bottom,
1337                                    HeapWord* const top,
1338                                    HeapWord* const new_top)
1339 {
1340   ParallelCompactData&amp; sd = summary_data();
1341 
1342   assert(cp != NULL, &quot;sanity&quot;);
1343   assert(bottom != NULL, &quot;sanity&quot;);
1344   assert(top != NULL, &quot;sanity&quot;);
1345   assert(new_top != NULL, &quot;sanity&quot;);
1346   assert(top &gt;= new_top, &quot;summary data problem?&quot;);
1347   assert(new_top &gt; bottom, &quot;space is empty; should not be here&quot;);
1348   assert(new_top &gt;= cp-&gt;destination(), &quot;sanity&quot;);
1349   assert(top &gt;= sd.region_to_addr(cp), &quot;sanity&quot;);
1350 
1351   HeapWord* const destination = cp-&gt;destination();
1352   const size_t dense_prefix_live  = pointer_delta(destination, bottom);
1353   const size_t compacted_region_live = pointer_delta(new_top, destination);
1354   const size_t compacted_region_used = pointer_delta(top,
1355                                                      sd.region_to_addr(cp));
1356   const size_t reclaimable = compacted_region_used - compacted_region_live;
1357 
1358   const double divisor = dense_prefix_live + 1.25 * compacted_region_live;
1359   return double(reclaimable) / divisor;
1360 }
1361 
1362 // Return the address of the end of the dense prefix, a.k.a. the start of the
1363 // compacted region.  The address is always on a region boundary.
1364 //
1365 // Completely full regions at the left are skipped, since no compaction can
1366 // occur in those regions.  Then the maximum amount of dead wood to allow is
1367 // computed, based on the density (amount live / capacity) of the generation;
1368 // the region with approximately that amount of dead space to the left is
1369 // identified as the limit region.  Regions between the last completely full
1370 // region and the limit region are scanned and the one that has the best
1371 // (maximum) reclaimed_ratio() is selected.
1372 HeapWord*
1373 PSParallelCompact::compute_dense_prefix(const SpaceId id,
1374                                         bool maximum_compaction)
1375 {
1376   const size_t region_size = ParallelCompactData::RegionSize;
1377   const ParallelCompactData&amp; sd = summary_data();
1378 
1379   const MutableSpace* const space = _space_info[id].space();
1380   HeapWord* const top = space-&gt;top();
1381   HeapWord* const top_aligned_up = sd.region_align_up(top);
1382   HeapWord* const new_top = _space_info[id].new_top();
1383   HeapWord* const new_top_aligned_up = sd.region_align_up(new_top);
1384   HeapWord* const bottom = space-&gt;bottom();
1385   const RegionData* const beg_cp = sd.addr_to_region_ptr(bottom);
1386   const RegionData* const top_cp = sd.addr_to_region_ptr(top_aligned_up);
1387   const RegionData* const new_top_cp =
1388     sd.addr_to_region_ptr(new_top_aligned_up);
1389 
1390   // Skip full regions at the beginning of the space--they are necessarily part
1391   // of the dense prefix.
1392   const RegionData* const full_cp = first_dead_space_region(beg_cp, new_top_cp);
1393   assert(full_cp-&gt;destination() == sd.region_to_addr(full_cp) ||
1394          space-&gt;is_empty(), &quot;no dead space allowed to the left&quot;);
1395   assert(full_cp-&gt;data_size() &lt; region_size || full_cp == new_top_cp - 1,
1396          &quot;region must have dead space&quot;);
1397 
1398   // The gc number is saved whenever a maximum compaction is done, and used to
1399   // determine when the maximum compaction interval has expired.  This avoids
1400   // successive max compactions for different reasons.
1401   assert(total_invocations() &gt;= _maximum_compaction_gc_num, &quot;sanity&quot;);
1402   const size_t gcs_since_max = total_invocations() - _maximum_compaction_gc_num;
1403   const bool interval_ended = gcs_since_max &gt; HeapMaximumCompactionInterval ||
1404     total_invocations() == HeapFirstMaximumCompactionCount;
1405   if (maximum_compaction || full_cp == top_cp || interval_ended) {
1406     _maximum_compaction_gc_num = total_invocations();
1407     return sd.region_to_addr(full_cp);
1408   }
1409 
1410   const size_t space_live = pointer_delta(new_top, bottom);
1411   const size_t space_used = space-&gt;used_in_words();
1412   const size_t space_capacity = space-&gt;capacity_in_words();
1413 
1414   const double density = double(space_live) / double(space_capacity);
1415   const size_t min_percent_free = MarkSweepDeadRatio;
1416   const double limiter = dead_wood_limiter(density, min_percent_free);
1417   const size_t dead_wood_max = space_used - space_live;
1418   const size_t dead_wood_limit = MIN2(size_t(space_capacity * limiter),
1419                                       dead_wood_max);
1420 
1421   log_develop_debug(gc, compaction)(
1422       &quot;space_live=&quot; SIZE_FORMAT &quot; space_used=&quot; SIZE_FORMAT &quot; &quot;
1423       &quot;space_cap=&quot; SIZE_FORMAT,
1424       space_live, space_used,
1425       space_capacity);
1426   log_develop_debug(gc, compaction)(
1427       &quot;dead_wood_limiter(%6.4f, &quot; SIZE_FORMAT &quot;)=%6.4f &quot;
1428       &quot;dead_wood_max=&quot; SIZE_FORMAT &quot; dead_wood_limit=&quot; SIZE_FORMAT,
1429       density, min_percent_free, limiter,
1430       dead_wood_max, dead_wood_limit);
1431 
1432   // Locate the region with the desired amount of dead space to the left.
1433   const RegionData* const limit_cp =
1434     dead_wood_limit_region(full_cp, top_cp, dead_wood_limit);
1435 
1436   // Scan from the first region with dead space to the limit region and find the
1437   // one with the best (largest) reclaimed ratio.
1438   double best_ratio = 0.0;
1439   const RegionData* best_cp = full_cp;
1440   for (const RegionData* cp = full_cp; cp &lt; limit_cp; ++cp) {
1441     double tmp_ratio = reclaimed_ratio(cp, bottom, top, new_top);
1442     if (tmp_ratio &gt; best_ratio) {
1443       best_cp = cp;
1444       best_ratio = tmp_ratio;
1445     }
1446   }
1447 
1448   return sd.region_to_addr(best_cp);
1449 }
1450 
1451 void PSParallelCompact::summarize_spaces_quick()
1452 {
1453   for (unsigned int i = 0; i &lt; last_space_id; ++i) {
1454     const MutableSpace* space = _space_info[i].space();
1455     HeapWord** nta = _space_info[i].new_top_addr();
1456     bool result = _summary_data.summarize(_space_info[i].split_info(),
1457                                           space-&gt;bottom(), space-&gt;top(), NULL,
1458                                           space-&gt;bottom(), space-&gt;end(), nta);
1459     assert(result, &quot;space must fit into itself&quot;);
1460     _space_info[i].set_dense_prefix(space-&gt;bottom());
1461   }
1462 }
1463 
1464 void PSParallelCompact::fill_dense_prefix_end(SpaceId id)
1465 {
1466   HeapWord* const dense_prefix_end = dense_prefix(id);
1467   const RegionData* region = _summary_data.addr_to_region_ptr(dense_prefix_end);
1468   const idx_t dense_prefix_bit = _mark_bitmap.addr_to_bit(dense_prefix_end);
1469   if (dead_space_crosses_boundary(region, dense_prefix_bit)) {
1470     // Only enough dead space is filled so that any remaining dead space to the
1471     // left is larger than the minimum filler object.  (The remainder is filled
1472     // during the copy/update phase.)
1473     //
1474     // The size of the dead space to the right of the boundary is not a
1475     // concern, since compaction will be able to use whatever space is
1476     // available.
1477     //
1478     // Here &#39;||&#39; is the boundary, &#39;x&#39; represents a don&#39;t care bit and a box
1479     // surrounds the space to be filled with an object.
1480     //
1481     // In the 32-bit VM, each bit represents two 32-bit words:
1482     //                              +---+
1483     // a) beg_bits:  ...  x   x   x | 0 | ||   0   x  x  ...
1484     //    end_bits:  ...  x   x   x | 0 | ||   0   x  x  ...
1485     //                              +---+
1486     //
1487     // In the 64-bit VM, each bit represents one 64-bit word:
1488     //                              +------------+
1489     // b) beg_bits:  ...  x   x   x | 0   ||   0 | x  x  ...
1490     //    end_bits:  ...  x   x   1 | 0   ||   0 | x  x  ...
1491     //                              +------------+
1492     //                          +-------+
1493     // c) beg_bits:  ...  x   x | 0   0 | ||   0   x  x  ...
1494     //    end_bits:  ...  x   1 | 0   0 | ||   0   x  x  ...
1495     //                          +-------+
1496     //                      +-----------+
1497     // d) beg_bits:  ...  x | 0   0   0 | ||   0   x  x  ...
1498     //    end_bits:  ...  1 | 0   0   0 | ||   0   x  x  ...
1499     //                      +-----------+
1500     //                          +-------+
1501     // e) beg_bits:  ...  0   0 | 0   0 | ||   0   x  x  ...
1502     //    end_bits:  ...  0   0 | 0   0 | ||   0   x  x  ...
1503     //                          +-------+
1504 
1505     // Initially assume case a, c or e will apply.
1506     size_t obj_len = CollectedHeap::min_fill_size();
1507     HeapWord* obj_beg = dense_prefix_end - obj_len;
1508 
1509 #ifdef  _LP64
1510     if (MinObjAlignment &gt; 1) { // object alignment &gt; heap word size
1511       // Cases a, c or e.
1512     } else if (_mark_bitmap.is_obj_end(dense_prefix_bit - 2)) {
1513       // Case b above.
1514       obj_beg = dense_prefix_end - 1;
1515     } else if (!_mark_bitmap.is_obj_end(dense_prefix_bit - 3) &amp;&amp;
1516                _mark_bitmap.is_obj_end(dense_prefix_bit - 4)) {
1517       // Case d above.
1518       obj_beg = dense_prefix_end - 3;
1519       obj_len = 3;
1520     }
1521 #endif  // #ifdef _LP64
1522 
1523     CollectedHeap::fill_with_object(obj_beg, obj_len);
1524     _mark_bitmap.mark_obj(obj_beg, obj_len);
1525     _summary_data.add_obj(obj_beg, obj_len);
1526     assert(start_array(id) != NULL, &quot;sanity&quot;);
1527     start_array(id)-&gt;allocate_block(obj_beg);
1528   }
1529 }
1530 
1531 void
1532 PSParallelCompact::summarize_space(SpaceId id, bool maximum_compaction)
1533 {
1534   assert(id &lt; last_space_id, &quot;id out of range&quot;);
1535   assert(_space_info[id].dense_prefix() == _space_info[id].space()-&gt;bottom(),
1536          &quot;should have been reset in summarize_spaces_quick()&quot;);
1537 
1538   const MutableSpace* space = _space_info[id].space();
1539   if (_space_info[id].new_top() != space-&gt;bottom()) {
1540     HeapWord* dense_prefix_end = compute_dense_prefix(id, maximum_compaction);
1541     _space_info[id].set_dense_prefix(dense_prefix_end);
1542 
1543 #ifndef PRODUCT
1544     if (log_is_enabled(Debug, gc, compaction)) {
1545       print_dense_prefix_stats(&quot;ratio&quot;, id, maximum_compaction,
1546                                dense_prefix_end);
1547       HeapWord* addr = compute_dense_prefix_via_density(id, maximum_compaction);
1548       print_dense_prefix_stats(&quot;density&quot;, id, maximum_compaction, addr);
1549     }
1550 #endif  // #ifndef PRODUCT
1551 
1552     // Recompute the summary data, taking into account the dense prefix.  If
1553     // every last byte will be reclaimed, then the existing summary data which
1554     // compacts everything can be left in place.
1555     if (!maximum_compaction &amp;&amp; dense_prefix_end != space-&gt;bottom()) {
1556       // If dead space crosses the dense prefix boundary, it is (at least
1557       // partially) filled with a dummy object, marked live and added to the
1558       // summary data.  This simplifies the copy/update phase and must be done
1559       // before the final locations of objects are determined, to prevent
1560       // leaving a fragment of dead space that is too small to fill.
1561       fill_dense_prefix_end(id);
1562 
1563       // Compute the destination of each Region, and thus each object.
1564       _summary_data.summarize_dense_prefix(space-&gt;bottom(), dense_prefix_end);
1565       _summary_data.summarize(_space_info[id].split_info(),
1566                               dense_prefix_end, space-&gt;top(), NULL,
1567                               dense_prefix_end, space-&gt;end(),
1568                               _space_info[id].new_top_addr());
1569     }
1570   }
1571 
1572   if (log_develop_is_enabled(Trace, gc, compaction)) {
1573     const size_t region_size = ParallelCompactData::RegionSize;
1574     HeapWord* const dense_prefix_end = _space_info[id].dense_prefix();
1575     const size_t dp_region = _summary_data.addr_to_region_idx(dense_prefix_end);
1576     const size_t dp_words = pointer_delta(dense_prefix_end, space-&gt;bottom());
1577     HeapWord* const new_top = _space_info[id].new_top();
1578     const HeapWord* nt_aligned_up = _summary_data.region_align_up(new_top);
1579     const size_t cr_words = pointer_delta(nt_aligned_up, dense_prefix_end);
1580     log_develop_trace(gc, compaction)(
1581         &quot;id=%d cap=&quot; SIZE_FORMAT &quot; dp=&quot; PTR_FORMAT &quot; &quot;
1582         &quot;dp_region=&quot; SIZE_FORMAT &quot; &quot; &quot;dp_count=&quot; SIZE_FORMAT &quot; &quot;
1583         &quot;cr_count=&quot; SIZE_FORMAT &quot; &quot; &quot;nt=&quot; PTR_FORMAT,
1584         id, space-&gt;capacity_in_words(), p2i(dense_prefix_end),
1585         dp_region, dp_words / region_size,
1586         cr_words / region_size, p2i(new_top));
1587   }
1588 }
1589 
1590 #ifndef PRODUCT
1591 void PSParallelCompact::summary_phase_msg(SpaceId dst_space_id,
1592                                           HeapWord* dst_beg, HeapWord* dst_end,
1593                                           SpaceId src_space_id,
1594                                           HeapWord* src_beg, HeapWord* src_end)
1595 {
1596   log_develop_trace(gc, compaction)(
1597       &quot;Summarizing %d [%s] into %d [%s]:  &quot;
1598       &quot;src=&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot; &quot;
1599       SIZE_FORMAT &quot;-&quot; SIZE_FORMAT &quot; &quot;
1600       &quot;dst=&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot; &quot;
1601       SIZE_FORMAT &quot;-&quot; SIZE_FORMAT,
1602       src_space_id, space_names[src_space_id],
1603       dst_space_id, space_names[dst_space_id],
1604       p2i(src_beg), p2i(src_end),
1605       _summary_data.addr_to_region_idx(src_beg),
1606       _summary_data.addr_to_region_idx(src_end),
1607       p2i(dst_beg), p2i(dst_end),
1608       _summary_data.addr_to_region_idx(dst_beg),
1609       _summary_data.addr_to_region_idx(dst_end));
1610 }
1611 #endif  // #ifndef PRODUCT
1612 
1613 void PSParallelCompact::summary_phase(ParCompactionManager* cm,
1614                                       bool maximum_compaction)
1615 {
1616   GCTraceTime(Info, gc, phases) tm(&quot;Summary Phase&quot;, &amp;_gc_timer);
1617 
1618   log_develop_debug(gc, marking)(
1619       &quot;add_obj_count=&quot; SIZE_FORMAT &quot; &quot;
1620       &quot;add_obj_bytes=&quot; SIZE_FORMAT,
1621       add_obj_count,
1622       add_obj_size * HeapWordSize);
1623   log_develop_debug(gc, marking)(
1624       &quot;mark_bitmap_count=&quot; SIZE_FORMAT &quot; &quot;
1625       &quot;mark_bitmap_bytes=&quot; SIZE_FORMAT,
1626       mark_bitmap_count,
1627       mark_bitmap_size * HeapWordSize);
1628 
1629   // Quick summarization of each space into itself, to see how much is live.
1630   summarize_spaces_quick();
1631 
1632   log_develop_trace(gc, compaction)(&quot;summary phase:  after summarizing each space to self&quot;);
1633   NOT_PRODUCT(print_region_ranges());
1634   NOT_PRODUCT(print_initial_summary_data(_summary_data, _space_info));
1635 
1636   // The amount of live data that will end up in old space (assuming it fits).
1637   size_t old_space_total_live = 0;
1638   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
1639     old_space_total_live += pointer_delta(_space_info[id].new_top(),
1640                                           _space_info[id].space()-&gt;bottom());
1641   }
1642 
1643   MutableSpace* const old_space = _space_info[old_space_id].space();
1644   const size_t old_capacity = old_space-&gt;capacity_in_words();
1645   if (old_space_total_live &gt; old_capacity) {
1646     // XXX - should also try to expand
1647     maximum_compaction = true;
1648   }
1649 
1650   // Old generations.
1651   summarize_space(old_space_id, maximum_compaction);
1652 
1653   // Summarize the remaining spaces in the young gen.  The initial target space
1654   // is the old gen.  If a space does not fit entirely into the target, then the
1655   // remainder is compacted into the space itself and that space becomes the new
1656   // target.
1657   SpaceId dst_space_id = old_space_id;
1658   HeapWord* dst_space_end = old_space-&gt;end();
1659   HeapWord** new_top_addr = _space_info[dst_space_id].new_top_addr();
1660   for (unsigned int id = eden_space_id; id &lt; last_space_id; ++id) {
1661     const MutableSpace* space = _space_info[id].space();
1662     const size_t live = pointer_delta(_space_info[id].new_top(),
1663                                       space-&gt;bottom());
1664     const size_t available = pointer_delta(dst_space_end, *new_top_addr);
1665 
1666     NOT_PRODUCT(summary_phase_msg(dst_space_id, *new_top_addr, dst_space_end,
1667                                   SpaceId(id), space-&gt;bottom(), space-&gt;top());)
1668     if (live &gt; 0 &amp;&amp; live &lt;= available) {
1669       // All the live data will fit.
1670       bool done = _summary_data.summarize(_space_info[id].split_info(),
1671                                           space-&gt;bottom(), space-&gt;top(),
1672                                           NULL,
1673                                           *new_top_addr, dst_space_end,
1674                                           new_top_addr);
1675       assert(done, &quot;space must fit into old gen&quot;);
1676 
1677       // Reset the new_top value for the space.
1678       _space_info[id].set_new_top(space-&gt;bottom());
1679     } else if (live &gt; 0) {
1680       // Attempt to fit part of the source space into the target space.
1681       HeapWord* next_src_addr = NULL;
1682       bool done = _summary_data.summarize(_space_info[id].split_info(),
1683                                           space-&gt;bottom(), space-&gt;top(),
1684                                           &amp;next_src_addr,
1685                                           *new_top_addr, dst_space_end,
1686                                           new_top_addr);
1687       assert(!done, &quot;space should not fit into old gen&quot;);
1688       assert(next_src_addr != NULL, &quot;sanity&quot;);
1689 
1690       // The source space becomes the new target, so the remainder is compacted
1691       // within the space itself.
1692       dst_space_id = SpaceId(id);
1693       dst_space_end = space-&gt;end();
1694       new_top_addr = _space_info[id].new_top_addr();
1695       NOT_PRODUCT(summary_phase_msg(dst_space_id,
1696                                     space-&gt;bottom(), dst_space_end,
1697                                     SpaceId(id), next_src_addr, space-&gt;top());)
1698       done = _summary_data.summarize(_space_info[id].split_info(),
1699                                      next_src_addr, space-&gt;top(),
1700                                      NULL,
1701                                      space-&gt;bottom(), dst_space_end,
1702                                      new_top_addr);
1703       assert(done, &quot;space must fit when compacted into itself&quot;);
1704       assert(*new_top_addr &lt;= space-&gt;top(), &quot;usage should not grow&quot;);
1705     }
1706   }
1707 
1708   log_develop_trace(gc, compaction)(&quot;Summary_phase:  after final summarization&quot;);
1709   NOT_PRODUCT(print_region_ranges());
1710   NOT_PRODUCT(print_initial_summary_data(_summary_data, _space_info));
1711 }
1712 
1713 // This method should contain all heap-specific policy for invoking a full
1714 // collection.  invoke_no_policy() will only attempt to compact the heap; it
1715 // will do nothing further.  If we need to bail out for policy reasons, scavenge
1716 // before full gc, or any other specialized behavior, it needs to be added here.
1717 //
1718 // Note that this method should only be called from the vm_thread while at a
1719 // safepoint.
1720 //
1721 // Note that the all_soft_refs_clear flag in the soft ref policy
1722 // may be true because this method can be called without intervening
1723 // activity.  For example when the heap space is tight and full measure
1724 // are being taken to free space.
1725 void PSParallelCompact::invoke(bool maximum_heap_compaction) {
1726   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
1727   assert(Thread::current() == (Thread*)VMThread::vm_thread(),
1728          &quot;should be in vm thread&quot;);
1729 
1730   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
1731   GCCause::Cause gc_cause = heap-&gt;gc_cause();
1732   assert(!heap-&gt;is_gc_active(), &quot;not reentrant&quot;);
1733 
1734   PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
1735   IsGCActiveMark mark;
1736 
1737   if (ScavengeBeforeFullGC) {
1738     PSScavenge::invoke_no_policy();
1739   }
1740 
1741   const bool clear_all_soft_refs =
1742     heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs();
1743 
1744   PSParallelCompact::invoke_no_policy(clear_all_soft_refs ||
1745                                       maximum_heap_compaction);
1746 }
1747 
1748 // This method contains no policy. You should probably
1749 // be calling invoke() instead.
1750 bool PSParallelCompact::invoke_no_policy(bool maximum_heap_compaction) {
1751   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at a safepoint&quot;);
1752   assert(ref_processor() != NULL, &quot;Sanity&quot;);
1753 
1754   if (GCLocker::check_active_before_gc()) {
1755     return false;
1756   }
1757 
1758   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
1759 
1760   GCIdMark gc_id_mark;
1761   _gc_timer.register_gc_start();
1762   _gc_tracer.report_gc_start(heap-&gt;gc_cause(), _gc_timer.gc_start());
1763 
1764   TimeStamp marking_start;
1765   TimeStamp compaction_start;
1766   TimeStamp collection_exit;
1767 
1768   GCCause::Cause gc_cause = heap-&gt;gc_cause();
1769   PSYoungGen* young_gen = heap-&gt;young_gen();
1770   PSOldGen* old_gen = heap-&gt;old_gen();
1771   PSAdaptiveSizePolicy* size_policy = heap-&gt;size_policy();
1772 
1773   // The scope of casr should end after code that can change
1774   // SoftRefPolicy::_should_clear_all_soft_refs.
1775   ClearedAllSoftRefs casr(maximum_heap_compaction,
1776                           heap-&gt;soft_ref_policy());
1777 
1778   if (ZapUnusedHeapArea) {
1779     // Save information needed to minimize mangling
1780     heap-&gt;record_gen_tops_before_GC();
1781   }
1782 
1783   // Make sure data structures are sane, make the heap parsable, and do other
1784   // miscellaneous bookkeeping.
1785   pre_compact();
1786 
1787   const PreGenGCValues pre_gc_values = heap-&gt;get_pre_gc_values();
1788 
1789   // Get the compaction manager reserved for the VM thread.
1790   ParCompactionManager* const vmthread_cm =
1791     ParCompactionManager::manager_array(ParallelScavengeHeap::heap()-&gt;workers().total_workers());
1792 
1793   {
1794     ResourceMark rm;
1795     HandleMark hm;
1796 
1797     const uint active_workers =
1798       WorkerPolicy::calc_active_workers(ParallelScavengeHeap::heap()-&gt;workers().total_workers(),
1799                                         ParallelScavengeHeap::heap()-&gt;workers().active_workers(),
1800                                         Threads::number_of_non_daemon_threads());
1801     ParallelScavengeHeap::heap()-&gt;workers().update_active_workers(active_workers);
1802 
1803     GCTraceCPUTime tcpu;
1804     GCTraceTime(Info, gc) tm(&quot;Pause Full&quot;, NULL, gc_cause, true);
1805 
1806     heap-&gt;pre_full_gc_dump(&amp;_gc_timer);
1807 
1808     TraceCollectorStats tcs(counters());
1809     TraceMemoryManagerStats tms(heap-&gt;old_gc_manager(), gc_cause);
1810 
1811     if (log_is_enabled(Debug, gc, heap, exit)) {
1812       accumulated_time()-&gt;start();
1813     }
1814 
1815     // Let the size policy know we&#39;re starting
1816     size_policy-&gt;major_collection_begin();
1817 
1818 #if COMPILER2_OR_JVMCI
1819     DerivedPointerTable::clear();
1820 #endif
1821 
1822     ref_processor()-&gt;enable_discovery();
1823     ref_processor()-&gt;setup_policy(maximum_heap_compaction);
1824 
1825     bool marked_for_unloading = false;
1826 
1827     marking_start.update();
1828     marking_phase(vmthread_cm, maximum_heap_compaction, &amp;_gc_tracer);
1829 
1830     bool max_on_system_gc = UseMaximumCompactionOnSystemGC
1831       &amp;&amp; GCCause::is_user_requested_gc(gc_cause);
1832     summary_phase(vmthread_cm, maximum_heap_compaction || max_on_system_gc);
1833 
1834 #if COMPILER2_OR_JVMCI
1835     assert(DerivedPointerTable::is_active(), &quot;Sanity&quot;);
1836     DerivedPointerTable::set_active(false);
1837 #endif
1838 
1839     // adjust_roots() updates Universe::_intArrayKlassObj which is
1840     // needed by the compaction for filling holes in the dense prefix.
1841     adjust_roots(vmthread_cm);
1842 
1843     compaction_start.update();
1844     compact();
1845 
1846     // Reset the mark bitmap, summary data, and do other bookkeeping.  Must be
1847     // done before resizing.
1848     post_compact();
1849 
1850     // Let the size policy know we&#39;re done
1851     size_policy-&gt;major_collection_end(old_gen-&gt;used_in_bytes(), gc_cause);
1852 
1853     if (UseAdaptiveSizePolicy) {
1854       log_debug(gc, ergo)(&quot;AdaptiveSizeStart: collection: %d &quot;, heap-&gt;total_collections());
1855       log_trace(gc, ergo)(&quot;old_gen_capacity: &quot; SIZE_FORMAT &quot; young_gen_capacity: &quot; SIZE_FORMAT,
1856                           old_gen-&gt;capacity_in_bytes(), young_gen-&gt;capacity_in_bytes());
1857 
1858       // Don&#39;t check if the size_policy is ready here.  Let
1859       // the size_policy check that internally.
1860       if (UseAdaptiveGenerationSizePolicyAtMajorCollection &amp;&amp;
1861           AdaptiveSizePolicy::should_update_promo_stats(gc_cause)) {
1862         // Swap the survivor spaces if from_space is empty. The
1863         // resize_young_gen() called below is normally used after
1864         // a successful young GC and swapping of survivor spaces;
1865         // otherwise, it will fail to resize the young gen with
1866         // the current implementation.
1867         if (young_gen-&gt;from_space()-&gt;is_empty()) {
1868           young_gen-&gt;from_space()-&gt;clear(SpaceDecorator::Mangle);
1869           young_gen-&gt;swap_spaces();
1870         }
1871 
1872         // Calculate optimal free space amounts
1873         assert(young_gen-&gt;max_gen_size() &gt;
1874           young_gen-&gt;from_space()-&gt;capacity_in_bytes() +
1875           young_gen-&gt;to_space()-&gt;capacity_in_bytes(),
1876           &quot;Sizes of space in young gen are out-of-bounds&quot;);
1877 
1878         size_t young_live = young_gen-&gt;used_in_bytes();
1879         size_t eden_live = young_gen-&gt;eden_space()-&gt;used_in_bytes();
1880         size_t old_live = old_gen-&gt;used_in_bytes();
1881         size_t cur_eden = young_gen-&gt;eden_space()-&gt;capacity_in_bytes();
1882         size_t max_old_gen_size = old_gen-&gt;max_gen_size();
1883         size_t max_eden_size = young_gen-&gt;max_gen_size() -
1884           young_gen-&gt;from_space()-&gt;capacity_in_bytes() -
1885           young_gen-&gt;to_space()-&gt;capacity_in_bytes();
1886 
1887         // Used for diagnostics
1888         size_policy-&gt;clear_generation_free_space_flags();
1889 
1890         size_policy-&gt;compute_generations_free_space(young_live,
1891                                                     eden_live,
1892                                                     old_live,
1893                                                     cur_eden,
1894                                                     max_old_gen_size,
1895                                                     max_eden_size,
1896                                                     true /* full gc*/);
1897 
1898         size_policy-&gt;check_gc_overhead_limit(eden_live,
1899                                              max_old_gen_size,
1900                                              max_eden_size,
1901                                              true /* full gc*/,
1902                                              gc_cause,
1903                                              heap-&gt;soft_ref_policy());
1904 
1905         size_policy-&gt;decay_supplemental_growth(true /* full gc*/);
1906 
1907         heap-&gt;resize_old_gen(
1908           size_policy-&gt;calculated_old_free_size_in_bytes());
1909 
1910         heap-&gt;resize_young_gen(size_policy-&gt;calculated_eden_size_in_bytes(),
1911                                size_policy-&gt;calculated_survivor_size_in_bytes());
1912       }
1913 
1914       log_debug(gc, ergo)(&quot;AdaptiveSizeStop: collection: %d &quot;, heap-&gt;total_collections());
1915     }
1916 
1917     if (UsePerfData) {
1918       PSGCAdaptivePolicyCounters* const counters = heap-&gt;gc_policy_counters();
1919       counters-&gt;update_counters();
1920       counters-&gt;update_old_capacity(old_gen-&gt;capacity_in_bytes());
1921       counters-&gt;update_young_capacity(young_gen-&gt;capacity_in_bytes());
1922     }
1923 
1924     heap-&gt;resize_all_tlabs();
1925 
1926     // Resize the metaspace capacity after a collection
1927     MetaspaceGC::compute_new_size();
1928 
1929     if (log_is_enabled(Debug, gc, heap, exit)) {
1930       accumulated_time()-&gt;stop();
1931     }
1932 
1933     heap-&gt;print_heap_change(pre_gc_values);
1934 
1935     // Track memory usage and detect low memory
1936     MemoryService::track_memory_usage();
1937     heap-&gt;update_counters();
1938 
1939     heap-&gt;post_full_gc_dump(&amp;_gc_timer);
1940   }
1941 
1942 #ifdef ASSERT
1943   for (size_t i = 0; i &lt; ParallelGCThreads + 1; ++i) {
1944     ParCompactionManager* const cm =
1945       ParCompactionManager::manager_array(int(i));
1946     assert(cm-&gt;marking_stack()-&gt;is_empty(),       &quot;should be empty&quot;);
1947     assert(cm-&gt;region_stack()-&gt;is_empty(), &quot;Region stack &quot; SIZE_FORMAT &quot; is not empty&quot;, i);
1948   }
1949 #endif // ASSERT
1950 
1951   if (VerifyAfterGC &amp;&amp; heap-&gt;total_collections() &gt;= VerifyGCStartAt) {
1952     HandleMark hm;  // Discard invalid handles created during verification
1953     Universe::verify(&quot;After GC&quot;);
1954   }
1955 
1956   // Re-verify object start arrays
1957   if (VerifyObjectStartArray &amp;&amp;
1958       VerifyAfterGC) {
1959     old_gen-&gt;verify_object_start_array();
1960   }
1961 
1962   if (ZapUnusedHeapArea) {
1963     old_gen-&gt;object_space()-&gt;check_mangled_unused_area_complete();
1964   }
1965 
1966   NOT_PRODUCT(ref_processor()-&gt;verify_no_references_recorded());
1967 
1968   collection_exit.update();
1969 
1970   heap-&gt;print_heap_after_gc();
1971   heap-&gt;trace_heap_after_gc(&amp;_gc_tracer);
1972 
1973   log_debug(gc, task, time)(&quot;VM-Thread &quot; JLONG_FORMAT &quot; &quot; JLONG_FORMAT &quot; &quot; JLONG_FORMAT,
1974                          marking_start.ticks(), compaction_start.ticks(),
1975                          collection_exit.ticks());
1976 
1977   AdaptiveSizePolicyOutput::print(size_policy, heap-&gt;total_collections());
1978 
1979   _gc_timer.register_gc_end();
1980 
1981   _gc_tracer.report_dense_prefix(dense_prefix(old_space_id));
1982   _gc_tracer.report_gc_end(_gc_timer.gc_end(), _gc_timer.time_partitions());
1983 
1984   return true;
1985 }
1986 
1987 class PCAddThreadRootsMarkingTaskClosure : public ThreadClosure {
1988 private:
1989   uint _worker_id;
1990 
1991 public:
1992   PCAddThreadRootsMarkingTaskClosure(uint worker_id) : _worker_id(worker_id) { }
1993   void do_thread(Thread* thread) {
1994     assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);
1995 
1996     ResourceMark rm;
1997 
1998     ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(_worker_id);
1999 
2000     PCMarkAndPushClosure mark_and_push_closure(cm);
<a name="1" id="anc1"></a><span class="line-modified">2001     MarkingCodeBlobClosure mark_and_push_in_blobs(&amp;mark_and_push_closure, !CodeBlobToOopClosure::FixRelocations, true /* keepalive nmethods */);</span>
2002 
2003     thread-&gt;oops_do(&amp;mark_and_push_closure, &amp;mark_and_push_in_blobs);
2004 
2005     // Do the real work
2006     cm-&gt;follow_marking_stacks();
2007   }
2008 };
2009 
2010 static void mark_from_roots_work(ParallelRootType::Value root_type, uint worker_id) {
2011   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);
2012 
2013   ParCompactionManager* cm =
2014     ParCompactionManager::gc_thread_compaction_manager(worker_id);
2015   PCMarkAndPushClosure mark_and_push_closure(cm);
2016 
2017   switch (root_type) {
2018     case ParallelRootType::universe:
2019       Universe::oops_do(&amp;mark_and_push_closure);
2020       break;
2021 
2022     case ParallelRootType::object_synchronizer:
2023       ObjectSynchronizer::oops_do(&amp;mark_and_push_closure);
2024       break;
2025 
2026     case ParallelRootType::class_loader_data:
2027       {
2028         CLDToOopClosure cld_closure(&amp;mark_and_push_closure, ClassLoaderData::_claim_strong);
2029         ClassLoaderDataGraph::always_strong_cld_do(&amp;cld_closure);
2030       }
2031       break;
2032 
2033     case ParallelRootType::code_cache:
2034       // Do not treat nmethods as strong roots for mark/sweep, since we can unload them.
2035       //ScavengableNMethods::scavengable_nmethods_do(CodeBlobToOopClosure(&amp;mark_and_push_closure));
2036       AOTLoader::oops_do(&amp;mark_and_push_closure);
2037       break;
2038 
2039     case ParallelRootType::sentinel:
2040     DEBUG_ONLY(default:) // DEBUG_ONLY hack will create compile error on release builds (-Wswitch) and runtime check on debug builds
2041       fatal(&quot;Bad enumeration value: %u&quot;, root_type);
2042       break;
2043   }
2044 
2045   // Do the real work
2046   cm-&gt;follow_marking_stacks();
2047 }
2048 
2049 static void steal_marking_work(TaskTerminator&amp; terminator, uint worker_id) {
2050   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);
2051 
2052   ParCompactionManager* cm =
2053     ParCompactionManager::gc_thread_compaction_manager(worker_id);
2054 
2055   oop obj = NULL;
2056   ObjArrayTask task;
2057   do {
2058     while (ParCompactionManager::steal_objarray(worker_id,  task)) {
2059       cm-&gt;follow_array((objArrayOop)task.obj(), task.index());
2060       cm-&gt;follow_marking_stacks();
2061     }
2062     while (ParCompactionManager::steal(worker_id, obj)) {
2063       cm-&gt;follow_contents(obj);
2064       cm-&gt;follow_marking_stacks();
2065     }
2066   } while (!terminator.offer_termination());
2067 }
2068 
2069 class MarkFromRootsTask : public AbstractGangTask {
2070   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;
2071   StrongRootsScope _strong_roots_scope; // needed for Threads::possibly_parallel_threads_do
2072   OopStorageSetStrongParState&lt;false /* concurrent */, false /* is_const */&gt; _oop_storage_set_par_state;
2073   SequentialSubTasksDone _subtasks;
2074   TaskTerminator _terminator;
2075   uint _active_workers;
2076 
2077 public:
2078   MarkFromRootsTask(uint active_workers) :
2079       AbstractGangTask(&quot;MarkFromRootsTask&quot;),
2080       _strong_roots_scope(active_workers),
2081       _subtasks(),
2082       _terminator(active_workers, ParCompactionManager::oop_task_queues()),
2083       _active_workers(active_workers) {
2084     _subtasks.set_n_threads(active_workers);
2085     _subtasks.set_n_tasks(ParallelRootType::sentinel);
2086   }
2087 
2088   virtual void work(uint worker_id) {
2089     for (uint task = 0; _subtasks.try_claim_task(task); /*empty*/ ) {
2090       mark_from_roots_work(static_cast&lt;ParallelRootType::Value&gt;(task), worker_id);
2091     }
2092     _subtasks.all_tasks_completed();
2093 
2094     PCAddThreadRootsMarkingTaskClosure closure(worker_id);
2095     Threads::possibly_parallel_threads_do(true /*parallel */, &amp;closure);
2096 
2097     // Mark from OopStorages
2098     {
2099       ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);
2100       PCMarkAndPushClosure closure(cm);
2101       _oop_storage_set_par_state.oops_do(&amp;closure);
2102       // Do the real work
2103       cm-&gt;follow_marking_stacks();
2104     }
2105 
2106     if (_active_workers &gt; 1) {
2107       steal_marking_work(_terminator, worker_id);
2108     }
2109   }
2110 };
2111 
2112 class PCRefProcTask : public AbstractGangTask {
2113   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;
2114   ProcessTask&amp; _task;
2115   uint _ergo_workers;
2116   TaskTerminator _terminator;
2117 
2118 public:
2119   PCRefProcTask(ProcessTask&amp; task, uint ergo_workers) :
2120       AbstractGangTask(&quot;PCRefProcTask&quot;),
2121       _task(task),
2122       _ergo_workers(ergo_workers),
2123       _terminator(_ergo_workers, ParCompactionManager::oop_task_queues()) {
2124   }
2125 
2126   virtual void work(uint worker_id) {
2127     ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
2128     assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);
2129 
2130     ParCompactionManager* cm =
2131       ParCompactionManager::gc_thread_compaction_manager(worker_id);
2132     PCMarkAndPushClosure mark_and_push_closure(cm);
2133     ParCompactionManager::FollowStackClosure follow_stack_closure(cm);
2134     _task.work(worker_id, *PSParallelCompact::is_alive_closure(),
2135                mark_and_push_closure, follow_stack_closure);
2136 
2137     steal_marking_work(_terminator, worker_id);
2138   }
2139 };
2140 
2141 class RefProcTaskExecutor: public AbstractRefProcTaskExecutor {
2142   void execute(ProcessTask&amp; process_task, uint ergo_workers) {
2143     assert(ParallelScavengeHeap::heap()-&gt;workers().active_workers() == ergo_workers,
2144            &quot;Ergonomically chosen workers (%u) must be equal to active workers (%u)&quot;,
2145            ergo_workers, ParallelScavengeHeap::heap()-&gt;workers().active_workers());
2146 
2147     PCRefProcTask task(process_task, ergo_workers);
2148     ParallelScavengeHeap::heap()-&gt;workers().run_task(&amp;task);
2149   }
2150 };
2151 
2152 void PSParallelCompact::marking_phase(ParCompactionManager* cm,
2153                                       bool maximum_heap_compaction,
2154                                       ParallelOldTracer *gc_tracer) {
2155   // Recursively traverse all live objects and mark them
2156   GCTraceTime(Info, gc, phases) tm(&quot;Marking Phase&quot;, &amp;_gc_timer);
2157 
2158   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
2159   uint active_gc_threads = ParallelScavengeHeap::heap()-&gt;workers().active_workers();
2160 
2161   PCMarkAndPushClosure mark_and_push_closure(cm);
2162   ParCompactionManager::FollowStackClosure follow_stack_closure(cm);
2163 
2164   // Need new claim bits before marking starts.
2165   ClassLoaderDataGraph::clear_claimed_marks();
2166 
2167   {
2168     GCTraceTime(Debug, gc, phases) tm(&quot;Par Mark&quot;, &amp;_gc_timer);
2169 
2170     MarkFromRootsTask task(active_gc_threads);
2171     ParallelScavengeHeap::heap()-&gt;workers().run_task(&amp;task);
2172   }
2173 
2174   // Process reference objects found during marking
2175   {
2176     GCTraceTime(Debug, gc, phases) tm(&quot;Reference Processing&quot;, &amp;_gc_timer);
2177 
2178     ReferenceProcessorStats stats;
2179     ReferenceProcessorPhaseTimes pt(&amp;_gc_timer, ref_processor()-&gt;max_num_queues());
2180 
2181     if (ref_processor()-&gt;processing_is_mt()) {
2182       ref_processor()-&gt;set_active_mt_degree(active_gc_threads);
2183 
2184       RefProcTaskExecutor task_executor;
2185       stats = ref_processor()-&gt;process_discovered_references(
2186         is_alive_closure(), &amp;mark_and_push_closure, &amp;follow_stack_closure,
2187         &amp;task_executor, &amp;pt);
2188     } else {
2189       stats = ref_processor()-&gt;process_discovered_references(
2190         is_alive_closure(), &amp;mark_and_push_closure, &amp;follow_stack_closure, NULL,
2191         &amp;pt);
2192     }
2193 
2194     gc_tracer-&gt;report_gc_reference_stats(stats);
2195     pt.print_all_references();
2196   }
2197 
2198   // This is the point where the entire marking should have completed.
2199   assert(cm-&gt;marking_stacks_empty(), &quot;Marking should have completed&quot;);
2200 
2201   {
2202     GCTraceTime(Debug, gc, phases) tm(&quot;Weak Processing&quot;, &amp;_gc_timer);
2203     WeakProcessor::weak_oops_do(is_alive_closure(), &amp;do_nothing_cl);
2204   }
2205 
2206   {
2207     GCTraceTime(Debug, gc, phases) tm_m(&quot;Class Unloading&quot;, &amp;_gc_timer);
2208 
2209     // Follow system dictionary roots and unload classes.
2210     bool purged_class = SystemDictionary::do_unloading(&amp;_gc_timer);
2211 
2212     // Unload nmethods.
2213     CodeCache::do_unloading(is_alive_closure(), purged_class);
2214 
2215     // Prune dead klasses from subklass/sibling/implementor lists.
2216     Klass::clean_weak_klass_links(purged_class);
2217 
2218     // Clean JVMCI metadata handles.
2219     JVMCI_ONLY(JVMCI::do_unloading(purged_class));
2220   }
2221 
2222   _gc_tracer.report_object_count_after_gc(is_alive_closure());
2223 }
2224 
2225 void PSParallelCompact::adjust_roots(ParCompactionManager* cm) {
2226   // Adjust the pointers to reflect the new locations
2227   GCTraceTime(Info, gc, phases) tm(&quot;Adjust Roots&quot;, &amp;_gc_timer);
2228 
2229   // Need new claim bits when tracing through and adjusting pointers.
2230   ClassLoaderDataGraph::clear_claimed_marks();
2231 
2232   PCAdjustPointerClosure oop_closure(cm);
2233 
2234   // General strong roots.
2235   Universe::oops_do(&amp;oop_closure);
2236   Threads::oops_do(&amp;oop_closure, NULL);
2237   ObjectSynchronizer::oops_do(&amp;oop_closure);
2238   OopStorageSet::strong_oops_do(&amp;oop_closure);
2239   CLDToOopClosure cld_closure(&amp;oop_closure, ClassLoaderData::_claim_strong);
2240   ClassLoaderDataGraph::cld_do(&amp;cld_closure);
2241 
2242   // Now adjust pointers in remaining weak roots.  (All of which should
2243   // have been cleared if they pointed to non-surviving objects.)
2244   WeakProcessor::oops_do(&amp;oop_closure);
2245 
2246   CodeBlobToOopClosure adjust_from_blobs(&amp;oop_closure, CodeBlobToOopClosure::FixRelocations);
2247   CodeCache::blobs_do(&amp;adjust_from_blobs);
2248   AOT_ONLY(AOTLoader::oops_do(&amp;oop_closure);)
2249 
2250   ref_processor()-&gt;weak_oops_do(&amp;oop_closure);
2251   // Roots were visited so references into the young gen in roots
2252   // may have been scanned.  Process them also.
2253   // Should the reference processor have a span that excludes
2254   // young gen objects?
2255   PSScavenge::reference_processor()-&gt;weak_oops_do(&amp;oop_closure);
2256 }
2257 
2258 // Helper class to print 8 region numbers per line and then print the total at the end.
2259 class FillableRegionLogger : public StackObj {
2260 private:
2261   Log(gc, compaction) log;
2262   static const int LineLength = 8;
2263   size_t _regions[LineLength];
2264   int _next_index;
2265   bool _enabled;
2266   size_t _total_regions;
2267 public:
2268   FillableRegionLogger() : _next_index(0), _enabled(log_develop_is_enabled(Trace, gc, compaction)), _total_regions(0) { }
2269   ~FillableRegionLogger() {
2270     log.trace(SIZE_FORMAT &quot; initially fillable regions&quot;, _total_regions);
2271   }
2272 
2273   void print_line() {
2274     if (!_enabled || _next_index == 0) {
2275       return;
2276     }
2277     FormatBuffer&lt;&gt; line(&quot;Fillable: &quot;);
2278     for (int i = 0; i &lt; _next_index; i++) {
2279       line.append(&quot; &quot; SIZE_FORMAT_W(7), _regions[i]);
2280     }
2281     log.trace(&quot;%s&quot;, line.buffer());
2282     _next_index = 0;
2283   }
2284 
2285   void handle(size_t region) {
2286     if (!_enabled) {
2287       return;
2288     }
2289     _regions[_next_index++] = region;
2290     if (_next_index == LineLength) {
2291       print_line();
2292     }
2293     _total_regions++;
2294   }
2295 };
2296 
2297 void PSParallelCompact::prepare_region_draining_tasks(uint parallel_gc_threads)
2298 {
2299   GCTraceTime(Trace, gc, phases) tm(&quot;Drain Task Setup&quot;, &amp;_gc_timer);
2300 
2301   // Find the threads that are active
2302   uint worker_id = 0;
2303 
2304   // Find all regions that are available (can be filled immediately) and
2305   // distribute them to the thread stacks.  The iteration is done in reverse
2306   // order (high to low) so the regions will be removed in ascending order.
2307 
2308   const ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
2309 
2310   // id + 1 is used to test termination so unsigned  can
2311   // be used with an old_space_id == 0.
2312   FillableRegionLogger region_logger;
2313   for (unsigned int id = to_space_id; id + 1 &gt; old_space_id; --id) {
2314     SpaceInfo* const space_info = _space_info + id;
2315     MutableSpace* const space = space_info-&gt;space();
2316     HeapWord* const new_top = space_info-&gt;new_top();
2317 
2318     const size_t beg_region = sd.addr_to_region_idx(space_info-&gt;dense_prefix());
2319     const size_t end_region =
2320       sd.addr_to_region_idx(sd.region_align_up(new_top));
2321 
2322     for (size_t cur = end_region - 1; cur + 1 &gt; beg_region; --cur) {
2323       if (sd.region(cur)-&gt;claim_unsafe()) {
2324         ParCompactionManager* cm = ParCompactionManager::manager_array(worker_id);
2325         bool result = sd.region(cur)-&gt;mark_normal();
2326         assert(result, &quot;Must succeed at this point.&quot;);
2327         cm-&gt;region_stack()-&gt;push(cur);
2328         region_logger.handle(cur);
2329         // Assign regions to tasks in round-robin fashion.
2330         if (++worker_id == parallel_gc_threads) {
2331           worker_id = 0;
2332         }
2333       }
2334     }
2335     region_logger.print_line();
2336   }
2337 }
2338 
2339 class TaskQueue : StackObj {
2340   volatile uint _counter;
2341   uint _size;
2342   uint _insert_index;
2343   PSParallelCompact::UpdateDensePrefixTask* _backing_array;
2344 public:
2345   explicit TaskQueue(uint size) : _counter(0), _size(size), _insert_index(0), _backing_array(NULL) {
2346     _backing_array = NEW_C_HEAP_ARRAY(PSParallelCompact::UpdateDensePrefixTask, _size, mtGC);
2347   }
2348   ~TaskQueue() {
2349     assert(_counter &gt;= _insert_index, &quot;not all queue elements were claimed&quot;);
2350     FREE_C_HEAP_ARRAY(T, _backing_array);
2351   }
2352 
2353   void push(const PSParallelCompact::UpdateDensePrefixTask&amp; value) {
2354     assert(_insert_index &lt; _size, &quot;too small backing array&quot;);
2355     _backing_array[_insert_index++] = value;
2356   }
2357 
2358   bool try_claim(PSParallelCompact::UpdateDensePrefixTask&amp; reference) {
2359     uint claimed = Atomic::fetch_and_add(&amp;_counter, 1u);
2360     if (claimed &lt; _insert_index) {
2361       reference = _backing_array[claimed];
2362       return true;
2363     } else {
2364       return false;
2365     }
2366   }
2367 };
2368 
2369 #define PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING 4
2370 
2371 void PSParallelCompact::enqueue_dense_prefix_tasks(TaskQueue&amp; task_queue,
2372                                                    uint parallel_gc_threads) {
2373   GCTraceTime(Trace, gc, phases) tm(&quot;Dense Prefix Task Setup&quot;, &amp;_gc_timer);
2374 
2375   ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
2376 
2377   // Iterate over all the spaces adding tasks for updating
2378   // regions in the dense prefix.  Assume that 1 gc thread
2379   // will work on opening the gaps and the remaining gc threads
2380   // will work on the dense prefix.
2381   unsigned int space_id;
2382   for (space_id = old_space_id; space_id &lt; last_space_id; ++ space_id) {
2383     HeapWord* const dense_prefix_end = _space_info[space_id].dense_prefix();
2384     const MutableSpace* const space = _space_info[space_id].space();
2385 
2386     if (dense_prefix_end == space-&gt;bottom()) {
2387       // There is no dense prefix for this space.
2388       continue;
2389     }
2390 
2391     // The dense prefix is before this region.
2392     size_t region_index_end_dense_prefix =
2393         sd.addr_to_region_idx(dense_prefix_end);
2394     RegionData* const dense_prefix_cp =
2395       sd.region(region_index_end_dense_prefix);
2396     assert(dense_prefix_end == space-&gt;end() ||
2397            dense_prefix_cp-&gt;available() ||
2398            dense_prefix_cp-&gt;claimed(),
2399            &quot;The region after the dense prefix should always be ready to fill&quot;);
2400 
2401     size_t region_index_start = sd.addr_to_region_idx(space-&gt;bottom());
2402 
2403     // Is there dense prefix work?
2404     size_t total_dense_prefix_regions =
2405       region_index_end_dense_prefix - region_index_start;
2406     // How many regions of the dense prefix should be given to
2407     // each thread?
2408     if (total_dense_prefix_regions &gt; 0) {
2409       uint tasks_for_dense_prefix = 1;
2410       if (total_dense_prefix_regions &lt;=
2411           (parallel_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING)) {
2412         // Don&#39;t over partition.  This assumes that
2413         // PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING is a small integer value
2414         // so there are not many regions to process.
2415         tasks_for_dense_prefix = parallel_gc_threads;
2416       } else {
2417         // Over partition
2418         tasks_for_dense_prefix = parallel_gc_threads *
2419           PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING;
2420       }
2421       size_t regions_per_thread = total_dense_prefix_regions /
2422         tasks_for_dense_prefix;
2423       // Give each thread at least 1 region.
2424       if (regions_per_thread == 0) {
2425         regions_per_thread = 1;
2426       }
2427 
2428       for (uint k = 0; k &lt; tasks_for_dense_prefix; k++) {
2429         if (region_index_start &gt;= region_index_end_dense_prefix) {
2430           break;
2431         }
2432         // region_index_end is not processed
2433         size_t region_index_end = MIN2(region_index_start + regions_per_thread,
2434                                        region_index_end_dense_prefix);
2435         task_queue.push(UpdateDensePrefixTask(SpaceId(space_id),
2436                                               region_index_start,
2437                                               region_index_end));
2438         region_index_start = region_index_end;
2439       }
2440     }
2441     // This gets any part of the dense prefix that did not
2442     // fit evenly.
2443     if (region_index_start &lt; region_index_end_dense_prefix) {
2444       task_queue.push(UpdateDensePrefixTask(SpaceId(space_id),
2445                                             region_index_start,
2446                                             region_index_end_dense_prefix));
2447     }
2448   }
2449 }
2450 
2451 #ifdef ASSERT
2452 // Write a histogram of the number of times the block table was filled for a
2453 // region.
2454 void PSParallelCompact::write_block_fill_histogram()
2455 {
2456   if (!log_develop_is_enabled(Trace, gc, compaction)) {
2457     return;
2458   }
2459 
2460   Log(gc, compaction) log;
2461   ResourceMark rm;
2462   LogStream ls(log.trace());
2463   outputStream* out = &amp;ls;
2464 
2465   typedef ParallelCompactData::RegionData rd_t;
2466   ParallelCompactData&amp; sd = summary_data();
2467 
2468   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
2469     MutableSpace* const spc = _space_info[id].space();
2470     if (spc-&gt;bottom() != spc-&gt;top()) {
2471       const rd_t* const beg = sd.addr_to_region_ptr(spc-&gt;bottom());
2472       HeapWord* const top_aligned_up = sd.region_align_up(spc-&gt;top());
2473       const rd_t* const end = sd.addr_to_region_ptr(top_aligned_up);
2474 
2475       size_t histo[5] = { 0, 0, 0, 0, 0 };
2476       const size_t histo_len = sizeof(histo) / sizeof(size_t);
2477       const size_t region_cnt = pointer_delta(end, beg, sizeof(rd_t));
2478 
2479       for (const rd_t* cur = beg; cur &lt; end; ++cur) {
2480         ++histo[MIN2(cur-&gt;blocks_filled_count(), histo_len - 1)];
2481       }
2482       out-&gt;print(&quot;Block fill histogram: %u %-4s&quot; SIZE_FORMAT_W(5), id, space_names[id], region_cnt);
2483       for (size_t i = 0; i &lt; histo_len; ++i) {
2484         out-&gt;print(&quot; &quot; SIZE_FORMAT_W(5) &quot; %5.1f%%&quot;,
2485                    histo[i], 100.0 * histo[i] / region_cnt);
2486       }
2487       out-&gt;cr();
2488     }
2489   }
2490 }
2491 #endif // #ifdef ASSERT
2492 
2493 static void compaction_with_stealing_work(TaskTerminator* terminator, uint worker_id) {
2494   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);
2495 
2496   ParCompactionManager* cm =
2497     ParCompactionManager::gc_thread_compaction_manager(worker_id);
2498 
2499   // Drain the stacks that have been preloaded with regions
2500   // that are ready to fill.
2501 
2502   cm-&gt;drain_region_stacks();
2503 
2504   guarantee(cm-&gt;region_stack()-&gt;is_empty(), &quot;Not empty&quot;);
2505 
2506   size_t region_index = 0;
2507 
2508   while (true) {
2509     if (ParCompactionManager::steal(worker_id, region_index)) {
2510       PSParallelCompact::fill_and_update_region(cm, region_index);
2511       cm-&gt;drain_region_stacks();
2512     } else if (PSParallelCompact::steal_unavailable_region(cm, region_index)) {
2513       // Fill and update an unavailable region with the help of a shadow region
2514       PSParallelCompact::fill_and_update_shadow_region(cm, region_index);
2515       cm-&gt;drain_region_stacks();
2516     } else {
2517       if (terminator-&gt;offer_termination()) {
2518         break;
2519       }
2520       // Go around again.
2521     }
2522   }
2523   return;
2524 }
2525 
2526 class UpdateDensePrefixAndCompactionTask: public AbstractGangTask {
2527   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;
2528   TaskQueue&amp; _tq;
2529   TaskTerminator _terminator;
2530   uint _active_workers;
2531 
2532 public:
2533   UpdateDensePrefixAndCompactionTask(TaskQueue&amp; tq, uint active_workers) :
2534       AbstractGangTask(&quot;UpdateDensePrefixAndCompactionTask&quot;),
2535       _tq(tq),
2536       _terminator(active_workers, ParCompactionManager::region_task_queues()),
2537       _active_workers(active_workers) {
2538   }
2539   virtual void work(uint worker_id) {
2540     ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);
2541 
2542     for (PSParallelCompact::UpdateDensePrefixTask task; _tq.try_claim(task); /* empty */) {
2543       PSParallelCompact::update_and_deadwood_in_dense_prefix(cm,
2544                                                              task._space_id,
2545                                                              task._region_index_start,
2546                                                              task._region_index_end);
2547     }
2548 
2549     // Once a thread has drained it&#39;s stack, it should try to steal regions from
2550     // other threads.
2551     compaction_with_stealing_work(&amp;_terminator, worker_id);
2552   }
2553 };
2554 
2555 void PSParallelCompact::compact() {
2556   GCTraceTime(Info, gc, phases) tm(&quot;Compaction Phase&quot;, &amp;_gc_timer);
2557 
2558   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
2559   PSOldGen* old_gen = heap-&gt;old_gen();
2560   old_gen-&gt;start_array()-&gt;reset();
2561   uint active_gc_threads = ParallelScavengeHeap::heap()-&gt;workers().active_workers();
2562 
2563   // for [0..last_space_id)
2564   //     for [0..active_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING)
2565   //         push
2566   //     push
2567   //
2568   // max push count is thus: last_space_id * (active_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING + 1)
2569   TaskQueue task_queue(last_space_id * (active_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING + 1));
2570   initialize_shadow_regions(active_gc_threads);
2571   prepare_region_draining_tasks(active_gc_threads);
2572   enqueue_dense_prefix_tasks(task_queue, active_gc_threads);
2573 
2574   {
2575     GCTraceTime(Trace, gc, phases) tm(&quot;Par Compact&quot;, &amp;_gc_timer);
2576 
2577     UpdateDensePrefixAndCompactionTask task(task_queue, active_gc_threads);
2578     ParallelScavengeHeap::heap()-&gt;workers().run_task(&amp;task);
2579 
2580 #ifdef  ASSERT
2581     // Verify that all regions have been processed before the deferred updates.
2582     for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
2583       verify_complete(SpaceId(id));
2584     }
2585 #endif
2586   }
2587 
2588   {
2589     // Update the deferred objects, if any.  Any compaction manager can be used.
2590     GCTraceTime(Trace, gc, phases) tm(&quot;Deferred Updates&quot;, &amp;_gc_timer);
2591     ParCompactionManager* cm = ParCompactionManager::manager_array(0);
2592     for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
2593       update_deferred_objects(cm, SpaceId(id));
2594     }
2595   }
2596 
2597   DEBUG_ONLY(write_block_fill_histogram());
2598 }
2599 
2600 #ifdef  ASSERT
2601 void PSParallelCompact::verify_complete(SpaceId space_id) {
2602   // All Regions between space bottom() to new_top() should be marked as filled
2603   // and all Regions between new_top() and top() should be available (i.e.,
2604   // should have been emptied).
2605   ParallelCompactData&amp; sd = summary_data();
2606   SpaceInfo si = _space_info[space_id];
2607   HeapWord* new_top_addr = sd.region_align_up(si.new_top());
2608   HeapWord* old_top_addr = sd.region_align_up(si.space()-&gt;top());
2609   const size_t beg_region = sd.addr_to_region_idx(si.space()-&gt;bottom());
2610   const size_t new_top_region = sd.addr_to_region_idx(new_top_addr);
2611   const size_t old_top_region = sd.addr_to_region_idx(old_top_addr);
2612 
2613   bool issued_a_warning = false;
2614 
2615   size_t cur_region;
2616   for (cur_region = beg_region; cur_region &lt; new_top_region; ++cur_region) {
2617     const RegionData* const c = sd.region(cur_region);
2618     if (!c-&gt;completed()) {
2619       log_warning(gc)(&quot;region &quot; SIZE_FORMAT &quot; not filled: destination_count=%u&quot;,
2620                       cur_region, c-&gt;destination_count());
2621       issued_a_warning = true;
2622     }
2623   }
2624 
2625   for (cur_region = new_top_region; cur_region &lt; old_top_region; ++cur_region) {
2626     const RegionData* const c = sd.region(cur_region);
2627     if (!c-&gt;available()) {
2628       log_warning(gc)(&quot;region &quot; SIZE_FORMAT &quot; not empty: destination_count=%u&quot;,
2629                       cur_region, c-&gt;destination_count());
2630       issued_a_warning = true;
2631     }
2632   }
2633 
2634   if (issued_a_warning) {
2635     print_region_ranges();
2636   }
2637 }
2638 #endif  // #ifdef ASSERT
2639 
2640 inline void UpdateOnlyClosure::do_addr(HeapWord* addr) {
2641   _start_array-&gt;allocate_block(addr);
2642   compaction_manager()-&gt;update_contents(oop(addr));
2643 }
2644 
2645 // Update interior oops in the ranges of regions [beg_region, end_region).
2646 void
2647 PSParallelCompact::update_and_deadwood_in_dense_prefix(ParCompactionManager* cm,
2648                                                        SpaceId space_id,
2649                                                        size_t beg_region,
2650                                                        size_t end_region) {
2651   ParallelCompactData&amp; sd = summary_data();
2652   ParMarkBitMap* const mbm = mark_bitmap();
2653 
2654   HeapWord* beg_addr = sd.region_to_addr(beg_region);
2655   HeapWord* const end_addr = sd.region_to_addr(end_region);
2656   assert(beg_region &lt;= end_region, &quot;bad region range&quot;);
2657   assert(end_addr &lt;= dense_prefix(space_id), &quot;not in the dense prefix&quot;);
2658 
2659 #ifdef  ASSERT
2660   // Claim the regions to avoid triggering an assert when they are marked as
2661   // filled.
2662   for (size_t claim_region = beg_region; claim_region &lt; end_region; ++claim_region) {
2663     assert(sd.region(claim_region)-&gt;claim_unsafe(), &quot;claim() failed&quot;);
2664   }
2665 #endif  // #ifdef ASSERT
2666 
2667   if (beg_addr != space(space_id)-&gt;bottom()) {
2668     // Find the first live object or block of dead space that *starts* in this
2669     // range of regions.  If a partial object crosses onto the region, skip it;
2670     // it will be marked for &#39;deferred update&#39; when the object head is
2671     // processed.  If dead space crosses onto the region, it is also skipped; it
2672     // will be filled when the prior region is processed.  If neither of those
2673     // apply, the first word in the region is the start of a live object or dead
2674     // space.
2675     assert(beg_addr &gt; space(space_id)-&gt;bottom(), &quot;sanity&quot;);
2676     const RegionData* const cp = sd.region(beg_region);
2677     if (cp-&gt;partial_obj_size() != 0) {
2678       beg_addr = sd.partial_obj_end(beg_region);
2679     } else if (dead_space_crosses_boundary(cp, mbm-&gt;addr_to_bit(beg_addr))) {
2680       beg_addr = mbm-&gt;find_obj_beg(beg_addr, end_addr);
2681     }
2682   }
2683 
2684   if (beg_addr &lt; end_addr) {
2685     // A live object or block of dead space starts in this range of Regions.
2686      HeapWord* const dense_prefix_end = dense_prefix(space_id);
2687 
2688     // Create closures and iterate.
2689     UpdateOnlyClosure update_closure(mbm, cm, space_id);
2690     FillClosure fill_closure(cm, space_id);
2691     ParMarkBitMap::IterationStatus status;
2692     status = mbm-&gt;iterate(&amp;update_closure, &amp;fill_closure, beg_addr, end_addr,
2693                           dense_prefix_end);
2694     if (status == ParMarkBitMap::incomplete) {
2695       update_closure.do_addr(update_closure.source());
2696     }
2697   }
2698 
2699   // Mark the regions as filled.
2700   RegionData* const beg_cp = sd.region(beg_region);
2701   RegionData* const end_cp = sd.region(end_region);
2702   for (RegionData* cp = beg_cp; cp &lt; end_cp; ++cp) {
2703     cp-&gt;set_completed();
2704   }
2705 }
2706 
2707 // Return the SpaceId for the space containing addr.  If addr is not in the
2708 // heap, last_space_id is returned.  In debug mode it expects the address to be
2709 // in the heap and asserts such.
2710 PSParallelCompact::SpaceId PSParallelCompact::space_id(HeapWord* addr) {
2711   assert(ParallelScavengeHeap::heap()-&gt;is_in_reserved(addr), &quot;addr not in the heap&quot;);
2712 
2713   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
2714     if (_space_info[id].space()-&gt;contains(addr)) {
2715       return SpaceId(id);
2716     }
2717   }
2718 
2719   assert(false, &quot;no space contains the addr&quot;);
2720   return last_space_id;
2721 }
2722 
2723 void PSParallelCompact::update_deferred_objects(ParCompactionManager* cm,
2724                                                 SpaceId id) {
2725   assert(id &lt; last_space_id, &quot;bad space id&quot;);
2726 
2727   ParallelCompactData&amp; sd = summary_data();
2728   const SpaceInfo* const space_info = _space_info + id;
2729   ObjectStartArray* const start_array = space_info-&gt;start_array();
2730 
2731   const MutableSpace* const space = space_info-&gt;space();
2732   assert(space_info-&gt;dense_prefix() &gt;= space-&gt;bottom(), &quot;dense_prefix not set&quot;);
2733   HeapWord* const beg_addr = space_info-&gt;dense_prefix();
2734   HeapWord* const end_addr = sd.region_align_up(space_info-&gt;new_top());
2735 
2736   const RegionData* const beg_region = sd.addr_to_region_ptr(beg_addr);
2737   const RegionData* const end_region = sd.addr_to_region_ptr(end_addr);
2738   const RegionData* cur_region;
2739   for (cur_region = beg_region; cur_region &lt; end_region; ++cur_region) {
2740     HeapWord* const addr = cur_region-&gt;deferred_obj_addr();
2741     if (addr != NULL) {
2742       if (start_array != NULL) {
2743         start_array-&gt;allocate_block(addr);
2744       }
2745       cm-&gt;update_contents(oop(addr));
2746       assert(oopDesc::is_oop_or_null(oop(addr)), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(oop(addr)));
2747     }
2748   }
2749 }
2750 
2751 // Skip over count live words starting from beg, and return the address of the
2752 // next live word.  Unless marked, the word corresponding to beg is assumed to
2753 // be dead.  Callers must either ensure beg does not correspond to the middle of
2754 // an object, or account for those live words in some other way.  Callers must
2755 // also ensure that there are enough live words in the range [beg, end) to skip.
2756 HeapWord*
2757 PSParallelCompact::skip_live_words(HeapWord* beg, HeapWord* end, size_t count)
2758 {
2759   assert(count &gt; 0, &quot;sanity&quot;);
2760 
2761   ParMarkBitMap* m = mark_bitmap();
2762   idx_t bits_to_skip = m-&gt;words_to_bits(count);
2763   idx_t cur_beg = m-&gt;addr_to_bit(beg);
2764   const idx_t search_end = m-&gt;align_range_end(m-&gt;addr_to_bit(end));
2765 
2766   do {
2767     cur_beg = m-&gt;find_obj_beg(cur_beg, search_end);
2768     idx_t cur_end = m-&gt;find_obj_end(cur_beg, search_end);
2769     const size_t obj_bits = cur_end - cur_beg + 1;
2770     if (obj_bits &gt; bits_to_skip) {
2771       return m-&gt;bit_to_addr(cur_beg + bits_to_skip);
2772     }
2773     bits_to_skip -= obj_bits;
2774     cur_beg = cur_end + 1;
2775   } while (bits_to_skip &gt; 0);
2776 
2777   // Skipping the desired number of words landed just past the end of an object.
2778   // Find the start of the next object.
2779   cur_beg = m-&gt;find_obj_beg(cur_beg, search_end);
2780   assert(cur_beg &lt; m-&gt;addr_to_bit(end), &quot;not enough live words to skip&quot;);
2781   return m-&gt;bit_to_addr(cur_beg);
2782 }
2783 
2784 HeapWord* PSParallelCompact::first_src_addr(HeapWord* const dest_addr,
2785                                             SpaceId src_space_id,
2786                                             size_t src_region_idx)
2787 {
2788   assert(summary_data().is_region_aligned(dest_addr), &quot;not aligned&quot;);
2789 
2790   const SplitInfo&amp; split_info = _space_info[src_space_id].split_info();
2791   if (split_info.dest_region_addr() == dest_addr) {
2792     // The partial object ending at the split point contains the first word to
2793     // be copied to dest_addr.
2794     return split_info.first_src_addr();
2795   }
2796 
2797   const ParallelCompactData&amp; sd = summary_data();
2798   ParMarkBitMap* const bitmap = mark_bitmap();
2799   const size_t RegionSize = ParallelCompactData::RegionSize;
2800 
2801   assert(sd.is_region_aligned(dest_addr), &quot;not aligned&quot;);
2802   const RegionData* const src_region_ptr = sd.region(src_region_idx);
2803   const size_t partial_obj_size = src_region_ptr-&gt;partial_obj_size();
2804   HeapWord* const src_region_destination = src_region_ptr-&gt;destination();
2805 
2806   assert(dest_addr &gt;= src_region_destination, &quot;wrong src region&quot;);
2807   assert(src_region_ptr-&gt;data_size() &gt; 0, &quot;src region cannot be empty&quot;);
2808 
2809   HeapWord* const src_region_beg = sd.region_to_addr(src_region_idx);
2810   HeapWord* const src_region_end = src_region_beg + RegionSize;
2811 
2812   HeapWord* addr = src_region_beg;
2813   if (dest_addr == src_region_destination) {
2814     // Return the first live word in the source region.
2815     if (partial_obj_size == 0) {
2816       addr = bitmap-&gt;find_obj_beg(addr, src_region_end);
2817       assert(addr &lt; src_region_end, &quot;no objects start in src region&quot;);
2818     }
2819     return addr;
2820   }
2821 
2822   // Must skip some live data.
2823   size_t words_to_skip = dest_addr - src_region_destination;
2824   assert(src_region_ptr-&gt;data_size() &gt; words_to_skip, &quot;wrong src region&quot;);
2825 
2826   if (partial_obj_size &gt;= words_to_skip) {
2827     // All the live words to skip are part of the partial object.
2828     addr += words_to_skip;
2829     if (partial_obj_size == words_to_skip) {
2830       // Find the first live word past the partial object.
2831       addr = bitmap-&gt;find_obj_beg(addr, src_region_end);
2832       assert(addr &lt; src_region_end, &quot;wrong src region&quot;);
2833     }
2834     return addr;
2835   }
2836 
2837   // Skip over the partial object (if any).
2838   if (partial_obj_size != 0) {
2839     words_to_skip -= partial_obj_size;
2840     addr += partial_obj_size;
2841   }
2842 
2843   // Skip over live words due to objects that start in the region.
2844   addr = skip_live_words(addr, src_region_end, words_to_skip);
2845   assert(addr &lt; src_region_end, &quot;wrong src region&quot;);
2846   return addr;
2847 }
2848 
2849 void PSParallelCompact::decrement_destination_counts(ParCompactionManager* cm,
2850                                                      SpaceId src_space_id,
2851                                                      size_t beg_region,
2852                                                      HeapWord* end_addr)
2853 {
2854   ParallelCompactData&amp; sd = summary_data();
2855 
2856 #ifdef ASSERT
2857   MutableSpace* const src_space = _space_info[src_space_id].space();
2858   HeapWord* const beg_addr = sd.region_to_addr(beg_region);
2859   assert(src_space-&gt;contains(beg_addr) || beg_addr == src_space-&gt;end(),
2860          &quot;src_space_id does not match beg_addr&quot;);
2861   assert(src_space-&gt;contains(end_addr) || end_addr == src_space-&gt;end(),
2862          &quot;src_space_id does not match end_addr&quot;);
2863 #endif // #ifdef ASSERT
2864 
2865   RegionData* const beg = sd.region(beg_region);
2866   RegionData* const end = sd.addr_to_region_ptr(sd.region_align_up(end_addr));
2867 
2868   // Regions up to new_top() are enqueued if they become available.
2869   HeapWord* const new_top = _space_info[src_space_id].new_top();
2870   RegionData* const enqueue_end =
2871     sd.addr_to_region_ptr(sd.region_align_up(new_top));
2872 
2873   for (RegionData* cur = beg; cur &lt; end; ++cur) {
2874     assert(cur-&gt;data_size() &gt; 0, &quot;region must have live data&quot;);
2875     cur-&gt;decrement_destination_count();
2876     if (cur &lt; enqueue_end &amp;&amp; cur-&gt;available() &amp;&amp; cur-&gt;claim()) {
2877       if (cur-&gt;mark_normal()) {
2878         cm-&gt;push_region(sd.region(cur));
2879       } else if (cur-&gt;mark_copied()) {
2880         // Try to copy the content of the shadow region back to its corresponding
2881         // heap region if the shadow region is filled. Otherwise, the GC thread
2882         // fills the shadow region will copy the data back (see
2883         // MoveAndUpdateShadowClosure::complete_region).
2884         copy_back(sd.region_to_addr(cur-&gt;shadow_region()), sd.region_to_addr(cur));
2885         ParCompactionManager::push_shadow_region_mt_safe(cur-&gt;shadow_region());
2886         cur-&gt;set_completed();
2887       }
2888     }
2889   }
2890 }
2891 
2892 size_t PSParallelCompact::next_src_region(MoveAndUpdateClosure&amp; closure,
2893                                           SpaceId&amp; src_space_id,
2894                                           HeapWord*&amp; src_space_top,
2895                                           HeapWord* end_addr)
2896 {
2897   typedef ParallelCompactData::RegionData RegionData;
2898 
2899   ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
2900   const size_t region_size = ParallelCompactData::RegionSize;
2901 
2902   size_t src_region_idx = 0;
2903 
2904   // Skip empty regions (if any) up to the top of the space.
2905   HeapWord* const src_aligned_up = sd.region_align_up(end_addr);
2906   RegionData* src_region_ptr = sd.addr_to_region_ptr(src_aligned_up);
2907   HeapWord* const top_aligned_up = sd.region_align_up(src_space_top);
2908   const RegionData* const top_region_ptr =
2909     sd.addr_to_region_ptr(top_aligned_up);
2910   while (src_region_ptr &lt; top_region_ptr &amp;&amp; src_region_ptr-&gt;data_size() == 0) {
2911     ++src_region_ptr;
2912   }
2913 
2914   if (src_region_ptr &lt; top_region_ptr) {
2915     // The next source region is in the current space.  Update src_region_idx
2916     // and the source address to match src_region_ptr.
2917     src_region_idx = sd.region(src_region_ptr);
2918     HeapWord* const src_region_addr = sd.region_to_addr(src_region_idx);
2919     if (src_region_addr &gt; closure.source()) {
2920       closure.set_source(src_region_addr);
2921     }
2922     return src_region_idx;
2923   }
2924 
2925   // Switch to a new source space and find the first non-empty region.
2926   unsigned int space_id = src_space_id + 1;
2927   assert(space_id &lt; last_space_id, &quot;not enough spaces&quot;);
2928 
2929   HeapWord* const destination = closure.destination();
2930 
2931   do {
2932     MutableSpace* space = _space_info[space_id].space();
2933     HeapWord* const bottom = space-&gt;bottom();
2934     const RegionData* const bottom_cp = sd.addr_to_region_ptr(bottom);
2935 
2936     // Iterate over the spaces that do not compact into themselves.
2937     if (bottom_cp-&gt;destination() != bottom) {
2938       HeapWord* const top_aligned_up = sd.region_align_up(space-&gt;top());
2939       const RegionData* const top_cp = sd.addr_to_region_ptr(top_aligned_up);
2940 
2941       for (const RegionData* src_cp = bottom_cp; src_cp &lt; top_cp; ++src_cp) {
2942         if (src_cp-&gt;live_obj_size() &gt; 0) {
2943           // Found it.
2944           assert(src_cp-&gt;destination() == destination,
2945                  &quot;first live obj in the space must match the destination&quot;);
2946           assert(src_cp-&gt;partial_obj_size() == 0,
2947                  &quot;a space cannot begin with a partial obj&quot;);
2948 
2949           src_space_id = SpaceId(space_id);
2950           src_space_top = space-&gt;top();
2951           const size_t src_region_idx = sd.region(src_cp);
2952           closure.set_source(sd.region_to_addr(src_region_idx));
2953           return src_region_idx;
2954         } else {
2955           assert(src_cp-&gt;data_size() == 0, &quot;sanity&quot;);
2956         }
2957       }
2958     }
2959   } while (++space_id &lt; last_space_id);
2960 
2961   assert(false, &quot;no source region was found&quot;);
2962   return 0;
2963 }
2964 
2965 void PSParallelCompact::fill_region(ParCompactionManager* cm, MoveAndUpdateClosure&amp; closure, size_t region_idx)
2966 {
2967   typedef ParMarkBitMap::IterationStatus IterationStatus;
2968   ParMarkBitMap* const bitmap = mark_bitmap();
2969   ParallelCompactData&amp; sd = summary_data();
2970   RegionData* const region_ptr = sd.region(region_idx);
2971 
2972   // Get the source region and related info.
2973   size_t src_region_idx = region_ptr-&gt;source_region();
2974   SpaceId src_space_id = space_id(sd.region_to_addr(src_region_idx));
2975   HeapWord* src_space_top = _space_info[src_space_id].space()-&gt;top();
2976   HeapWord* dest_addr = sd.region_to_addr(region_idx);
2977 
2978   closure.set_source(first_src_addr(dest_addr, src_space_id, src_region_idx));
2979 
2980   // Adjust src_region_idx to prepare for decrementing destination counts (the
2981   // destination count is not decremented when a region is copied to itself).
2982   if (src_region_idx == region_idx) {
2983     src_region_idx += 1;
2984   }
2985 
2986   if (bitmap-&gt;is_unmarked(closure.source())) {
2987     // The first source word is in the middle of an object; copy the remainder
2988     // of the object or as much as will fit.  The fact that pointer updates were
2989     // deferred will be noted when the object header is processed.
2990     HeapWord* const old_src_addr = closure.source();
2991     closure.copy_partial_obj();
2992     if (closure.is_full()) {
2993       decrement_destination_counts(cm, src_space_id, src_region_idx,
2994                                    closure.source());
2995       region_ptr-&gt;set_deferred_obj_addr(NULL);
2996       closure.complete_region(cm, dest_addr, region_ptr);
2997       return;
2998     }
2999 
3000     HeapWord* const end_addr = sd.region_align_down(closure.source());
3001     if (sd.region_align_down(old_src_addr) != end_addr) {
3002       // The partial object was copied from more than one source region.
3003       decrement_destination_counts(cm, src_space_id, src_region_idx, end_addr);
3004 
3005       // Move to the next source region, possibly switching spaces as well.  All
3006       // args except end_addr may be modified.
3007       src_region_idx = next_src_region(closure, src_space_id, src_space_top,
3008                                        end_addr);
3009     }
3010   }
3011 
3012   do {
3013     HeapWord* const cur_addr = closure.source();
3014     HeapWord* const end_addr = MIN2(sd.region_align_up(cur_addr + 1),
3015                                     src_space_top);
3016     IterationStatus status = bitmap-&gt;iterate(&amp;closure, cur_addr, end_addr);
3017 
3018     if (status == ParMarkBitMap::incomplete) {
3019       // The last obj that starts in the source region does not end in the
3020       // region.
3021       assert(closure.source() &lt; end_addr, &quot;sanity&quot;);
3022       HeapWord* const obj_beg = closure.source();
3023       HeapWord* const range_end = MIN2(obj_beg + closure.words_remaining(),
3024                                        src_space_top);
3025       HeapWord* const obj_end = bitmap-&gt;find_obj_end(obj_beg, range_end);
3026       if (obj_end &lt; range_end) {
3027         // The end was found; the entire object will fit.
3028         status = closure.do_addr(obj_beg, bitmap-&gt;obj_size(obj_beg, obj_end));
3029         assert(status != ParMarkBitMap::would_overflow, &quot;sanity&quot;);
3030       } else {
3031         // The end was not found; the object will not fit.
3032         assert(range_end &lt; src_space_top, &quot;obj cannot cross space boundary&quot;);
3033         status = ParMarkBitMap::would_overflow;
3034       }
3035     }
3036 
3037     if (status == ParMarkBitMap::would_overflow) {
3038       // The last object did not fit.  Note that interior oop updates were
3039       // deferred, then copy enough of the object to fill the region.
3040       region_ptr-&gt;set_deferred_obj_addr(closure.destination());
3041       status = closure.copy_until_full(); // copies from closure.source()
3042 
3043       decrement_destination_counts(cm, src_space_id, src_region_idx,
3044                                    closure.source());
3045       closure.complete_region(cm, dest_addr, region_ptr);
3046       return;
3047     }
3048 
3049     if (status == ParMarkBitMap::full) {
3050       decrement_destination_counts(cm, src_space_id, src_region_idx,
3051                                    closure.source());
3052       region_ptr-&gt;set_deferred_obj_addr(NULL);
3053       closure.complete_region(cm, dest_addr, region_ptr);
3054       return;
3055     }
3056 
3057     decrement_destination_counts(cm, src_space_id, src_region_idx, end_addr);
3058 
3059     // Move to the next source region, possibly switching spaces as well.  All
3060     // args except end_addr may be modified.
3061     src_region_idx = next_src_region(closure, src_space_id, src_space_top,
3062                                      end_addr);
3063   } while (true);
3064 }
3065 
3066 void PSParallelCompact::fill_and_update_region(ParCompactionManager* cm, size_t region_idx)
3067 {
3068   MoveAndUpdateClosure cl(mark_bitmap(), cm, region_idx);
3069   fill_region(cm, cl, region_idx);
3070 }
3071 
3072 void PSParallelCompact::fill_and_update_shadow_region(ParCompactionManager* cm, size_t region_idx)
3073 {
3074   // Get a shadow region first
3075   ParallelCompactData&amp; sd = summary_data();
3076   RegionData* const region_ptr = sd.region(region_idx);
3077   size_t shadow_region = ParCompactionManager::pop_shadow_region_mt_safe(region_ptr);
3078   // The InvalidShadow return value indicates the corresponding heap region is available,
3079   // so use MoveAndUpdateClosure to fill the normal region. Otherwise, use
3080   // MoveAndUpdateShadowClosure to fill the acquired shadow region.
3081   if (shadow_region == ParCompactionManager::InvalidShadow) {
3082     MoveAndUpdateClosure cl(mark_bitmap(), cm, region_idx);
3083     region_ptr-&gt;shadow_to_normal();
3084     return fill_region(cm, cl, region_idx);
3085   } else {
3086     MoveAndUpdateShadowClosure cl(mark_bitmap(), cm, region_idx, shadow_region);
3087     return fill_region(cm, cl, region_idx);
3088   }
3089 }
3090 
3091 void PSParallelCompact::copy_back(HeapWord *shadow_addr, HeapWord *region_addr)
3092 {
3093   Copy::aligned_conjoint_words(shadow_addr, region_addr, _summary_data.RegionSize);
3094 }
3095 
3096 bool PSParallelCompact::steal_unavailable_region(ParCompactionManager* cm, size_t &amp;region_idx)
3097 {
3098   size_t next = cm-&gt;next_shadow_region();
3099   ParallelCompactData&amp; sd = summary_data();
3100   size_t old_new_top = sd.addr_to_region_idx(_space_info[old_space_id].new_top());
3101   uint active_gc_threads = ParallelScavengeHeap::heap()-&gt;workers().active_workers();
3102 
3103   while (next &lt; old_new_top) {
3104     if (sd.region(next)-&gt;mark_shadow()) {
3105       region_idx = next;
3106       return true;
3107     }
3108     next = cm-&gt;move_next_shadow_region_by(active_gc_threads);
3109   }
3110 
3111   return false;
3112 }
3113 
3114 // The shadow region is an optimization to address region dependencies in full GC. The basic
3115 // idea is making more regions available by temporally storing their live objects in empty
3116 // shadow regions to resolve dependencies between them and the destination regions. Therefore,
3117 // GC threads need not wait destination regions to be available before processing sources.
3118 //
3119 // A typical workflow would be:
3120 // After draining its own stack and failing to steal from others, a GC worker would pick an
3121 // unavailable region (destination count &gt; 0) and get a shadow region. Then the worker fills
3122 // the shadow region by copying live objects from source regions of the unavailable one. Once
3123 // the unavailable region becomes available, the data in the shadow region will be copied back.
3124 // Shadow regions are empty regions in the to-space and regions between top and end of other spaces.
3125 //
3126 // For more details, please refer to §4.2 of the VEE&#39;19 paper:
3127 // Haoyu Li, Mingyu Wu, Binyu Zang, and Haibo Chen. 2019. ScissorGC: scalable and efficient
3128 // compaction for Java full garbage collection. In Proceedings of the 15th ACM SIGPLAN/SIGOPS
3129 // International Conference on Virtual Execution Environments (VEE 2019). ACM, New York, NY, USA,
3130 // 108-121. DOI: https://doi.org/10.1145/3313808.3313820
3131 void PSParallelCompact::initialize_shadow_regions(uint parallel_gc_threads)
3132 {
3133   const ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
3134 
3135   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
3136     SpaceInfo* const space_info = _space_info + id;
3137     MutableSpace* const space = space_info-&gt;space();
3138 
3139     const size_t beg_region =
3140       sd.addr_to_region_idx(sd.region_align_up(MAX2(space_info-&gt;new_top(), space-&gt;top())));
3141     const size_t end_region =
3142       sd.addr_to_region_idx(sd.region_align_down(space-&gt;end()));
3143 
3144     for (size_t cur = beg_region; cur &lt; end_region; ++cur) {
3145       ParCompactionManager::push_shadow_region(cur);
3146     }
3147   }
3148 
3149   size_t beg_region = sd.addr_to_region_idx(_space_info[old_space_id].dense_prefix());
3150   for (uint i = 0; i &lt; parallel_gc_threads; i++) {
3151     ParCompactionManager *cm = ParCompactionManager::manager_array(i);
3152     cm-&gt;set_next_shadow_region(beg_region + i);
3153   }
3154 }
3155 
3156 void PSParallelCompact::fill_blocks(size_t region_idx)
3157 {
3158   // Fill in the block table elements for the specified region.  Each block
3159   // table element holds the number of live words in the region that are to the
3160   // left of the first object that starts in the block.  Thus only blocks in
3161   // which an object starts need to be filled.
3162   //
3163   // The algorithm scans the section of the bitmap that corresponds to the
3164   // region, keeping a running total of the live words.  When an object start is
3165   // found, if it&#39;s the first to start in the block that contains it, the
3166   // current total is written to the block table element.
3167   const size_t Log2BlockSize = ParallelCompactData::Log2BlockSize;
3168   const size_t Log2RegionSize = ParallelCompactData::Log2RegionSize;
3169   const size_t RegionSize = ParallelCompactData::RegionSize;
3170 
3171   ParallelCompactData&amp; sd = summary_data();
3172   const size_t partial_obj_size = sd.region(region_idx)-&gt;partial_obj_size();
3173   if (partial_obj_size &gt;= RegionSize) {
3174     return; // No objects start in this region.
3175   }
3176 
3177   // Ensure the first loop iteration decides that the block has changed.
3178   size_t cur_block = sd.block_count();
3179 
3180   const ParMarkBitMap* const bitmap = mark_bitmap();
3181 
3182   const size_t Log2BitsPerBlock = Log2BlockSize - LogMinObjAlignment;
3183   assert((size_t)1 &lt;&lt; Log2BitsPerBlock ==
3184          bitmap-&gt;words_to_bits(ParallelCompactData::BlockSize), &quot;sanity&quot;);
3185 
3186   size_t beg_bit = bitmap-&gt;words_to_bits(region_idx &lt;&lt; Log2RegionSize);
3187   const size_t range_end = beg_bit + bitmap-&gt;words_to_bits(RegionSize);
3188   size_t live_bits = bitmap-&gt;words_to_bits(partial_obj_size);
3189   beg_bit = bitmap-&gt;find_obj_beg(beg_bit + live_bits, range_end);
3190   while (beg_bit &lt; range_end) {
3191     const size_t new_block = beg_bit &gt;&gt; Log2BitsPerBlock;
3192     if (new_block != cur_block) {
3193       cur_block = new_block;
3194       sd.block(cur_block)-&gt;set_offset(bitmap-&gt;bits_to_words(live_bits));
3195     }
3196 
3197     const size_t end_bit = bitmap-&gt;find_obj_end(beg_bit, range_end);
3198     if (end_bit &lt; range_end - 1) {
3199       live_bits += end_bit - beg_bit + 1;
3200       beg_bit = bitmap-&gt;find_obj_beg(end_bit + 1, range_end);
3201     } else {
3202       return;
3203     }
3204   }
3205 }
3206 
3207 jlong PSParallelCompact::millis_since_last_gc() {
3208   // We need a monotonically non-decreasing time in ms but
3209   // os::javaTimeMillis() does not guarantee monotonicity.
3210   jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
3211   jlong ret_val = now - _time_of_last_gc;
3212   // XXX See note in genCollectedHeap::millis_since_last_gc().
3213   if (ret_val &lt; 0) {
3214     NOT_PRODUCT(log_warning(gc)(&quot;time warp: &quot; JLONG_FORMAT, ret_val);)
3215     return 0;
3216   }
3217   return ret_val;
3218 }
3219 
3220 void PSParallelCompact::reset_millis_since_last_gc() {
3221   // We need a monotonically non-decreasing time in ms but
3222   // os::javaTimeMillis() does not guarantee monotonicity.
3223   _time_of_last_gc = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
3224 }
3225 
3226 ParMarkBitMap::IterationStatus MoveAndUpdateClosure::copy_until_full()
3227 {
3228   if (source() != copy_destination()) {
3229     DEBUG_ONLY(PSParallelCompact::check_new_location(source(), destination());)
3230     Copy::aligned_conjoint_words(source(), copy_destination(), words_remaining());
3231   }
3232   update_state(words_remaining());
3233   assert(is_full(), &quot;sanity&quot;);
3234   return ParMarkBitMap::full;
3235 }
3236 
3237 void MoveAndUpdateClosure::copy_partial_obj()
3238 {
3239   size_t words = words_remaining();
3240 
3241   HeapWord* const range_end = MIN2(source() + words, bitmap()-&gt;region_end());
3242   HeapWord* const end_addr = bitmap()-&gt;find_obj_end(source(), range_end);
3243   if (end_addr &lt; range_end) {
3244     words = bitmap()-&gt;obj_size(source(), end_addr);
3245   }
3246 
3247   // This test is necessary; if omitted, the pointer updates to a partial object
3248   // that crosses the dense prefix boundary could be overwritten.
3249   if (source() != copy_destination()) {
3250     DEBUG_ONLY(PSParallelCompact::check_new_location(source(), destination());)
3251     Copy::aligned_conjoint_words(source(), copy_destination(), words);
3252   }
3253   update_state(words);
3254 }
3255 
3256 void MoveAndUpdateClosure::complete_region(ParCompactionManager *cm, HeapWord *dest_addr,
3257                                            PSParallelCompact::RegionData *region_ptr) {
3258   assert(region_ptr-&gt;shadow_state() == ParallelCompactData::RegionData::NormalRegion, &quot;Region should be finished&quot;);
3259   region_ptr-&gt;set_completed();
3260 }
3261 
3262 ParMarkBitMapClosure::IterationStatus
3263 MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {
3264   assert(destination() != NULL, &quot;sanity&quot;);
3265   assert(bitmap()-&gt;obj_size(addr) == words, &quot;bad size&quot;);
3266 
3267   _source = addr;
3268   assert(PSParallelCompact::summary_data().calc_new_pointer(source(), compaction_manager()) ==
3269          destination(), &quot;wrong destination&quot;);
3270 
3271   if (words &gt; words_remaining()) {
3272     return ParMarkBitMap::would_overflow;
3273   }
3274 
3275   // The start_array must be updated even if the object is not moving.
3276   if (_start_array != NULL) {
3277     _start_array-&gt;allocate_block(destination());
3278   }
3279 
3280   if (copy_destination() != source()) {
3281     DEBUG_ONLY(PSParallelCompact::check_new_location(source(), destination());)
3282     Copy::aligned_conjoint_words(source(), copy_destination(), words);
3283   }
3284 
3285   oop moved_oop = (oop) copy_destination();
3286   compaction_manager()-&gt;update_contents(moved_oop);
3287   assert(oopDesc::is_oop_or_null(moved_oop), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(moved_oop));
3288 
3289   update_state(words);
3290   assert(copy_destination() == cast_from_oop&lt;HeapWord*&gt;(moved_oop) + moved_oop-&gt;size(), &quot;sanity&quot;);
3291   return is_full() ? ParMarkBitMap::full : ParMarkBitMap::incomplete;
3292 }
3293 
3294 void MoveAndUpdateShadowClosure::complete_region(ParCompactionManager *cm, HeapWord *dest_addr,
3295                                                  PSParallelCompact::RegionData *region_ptr) {
3296   assert(region_ptr-&gt;shadow_state() == ParallelCompactData::RegionData::ShadowRegion, &quot;Region should be shadow&quot;);
3297   // Record the shadow region index
3298   region_ptr-&gt;set_shadow_region(_shadow);
3299   // Mark the shadow region as filled to indicate the data is ready to be
3300   // copied back
3301   region_ptr-&gt;mark_filled();
3302   // Try to copy the content of the shadow region back to its corresponding
3303   // heap region if available; the GC thread that decreases the destination
3304   // count to zero will do the copying otherwise (see
3305   // PSParallelCompact::decrement_destination_counts).
3306   if (((region_ptr-&gt;available() &amp;&amp; region_ptr-&gt;claim()) || region_ptr-&gt;claimed()) &amp;&amp; region_ptr-&gt;mark_copied()) {
3307     region_ptr-&gt;set_completed();
3308     PSParallelCompact::copy_back(PSParallelCompact::summary_data().region_to_addr(_shadow), dest_addr);
3309     ParCompactionManager::push_shadow_region_mt_safe(_shadow);
3310   }
3311 }
3312 
3313 UpdateOnlyClosure::UpdateOnlyClosure(ParMarkBitMap* mbm,
3314                                      ParCompactionManager* cm,
3315                                      PSParallelCompact::SpaceId space_id) :
3316   ParMarkBitMapClosure(mbm, cm),
3317   _space_id(space_id),
3318   _start_array(PSParallelCompact::start_array(space_id))
3319 {
3320 }
3321 
3322 // Updates the references in the object to their new values.
3323 ParMarkBitMapClosure::IterationStatus
3324 UpdateOnlyClosure::do_addr(HeapWord* addr, size_t words) {
3325   do_addr(addr);
3326   return ParMarkBitMap::incomplete;
3327 }
3328 
3329 FillClosure::FillClosure(ParCompactionManager* cm, PSParallelCompact::SpaceId space_id) :
3330   ParMarkBitMapClosure(PSParallelCompact::mark_bitmap(), cm),
3331   _start_array(PSParallelCompact::start_array(space_id))
3332 {
3333   assert(space_id == PSParallelCompact::old_space_id,
3334          &quot;cannot use FillClosure in the young gen&quot;);
3335 }
3336 
3337 ParMarkBitMapClosure::IterationStatus
3338 FillClosure::do_addr(HeapWord* addr, size_t size) {
3339   CollectedHeap::fill_with_objects(addr, size);
3340   HeapWord* const end = addr + size;
3341   do {
3342     _start_array-&gt;allocate_block(addr);
3343     addr += oop(addr)-&gt;size();
3344   } while (addr &lt; end);
3345   return ParMarkBitMap::incomplete;
3346 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>